<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ShapeRunner</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Rajdhani:wght@500;700&display=swap');
        
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Orbitron', 'Rajdhani', sans-serif;
            color: #00FFFF;
        }
        
        canvas {
            display: block;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 10;
        }
        
        #pause-btn {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 40px;
            height: 40px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 2px solid #00FFFF;
            border-radius: 4px;
            cursor: pointer;
            box-shadow: 0 0 10px #00FFFF, inset 0 0 5px #00FFFF;
            transition: all 0.2s ease;
        }
        
        #pause-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 15px #00FFFF, inset 0 0 10px #00FFFF;
        }
        
        #pause-btn:active {
            transform: scale(0.95);
        }
        
        #pause-btn div {
            width: 5px;
            height: 20px;
            background-color: #00FFFF;
            margin: 0 3px;
            border-radius: 2px;
            box-shadow: 0 0 5px #00FFFF;
        }
        
        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background-color: rgba(0, 0, 0, 0.8);
            border: 2px solid #00FFFF;
            border-radius: 8px;
            padding: 20px 40px;
            box-shadow: 0 0 20px #00FFFF, inset 0 0 10px #00FFFF;
            display: none;
            z-index: 20;
        }
        
        #game-over h2 {
            font-size: 36px;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 10px #00FFFF;
            animation: neonPulse 1.5s infinite alternate;
        }
        
        #retry-btn {
            display: inline-block;
            background-color: transparent;
            color: #00FFFF;
            border: 2px solid #00FFFF;
            border-radius: 4px;
            padding: 10px 20px;
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            box-shadow: 0 0 10px #00FFFF;
            text-shadow: 0 0 5px #00FFFF;
            transition: all 0.2s ease;
            margin-top: 10px;
        }
        
        #retry-btn:hover {
            background-color: rgba(0, 255, 255, 0.2);
            transform: scale(1.1);
            box-shadow: 0 0 15px #00FFFF;
        }
        
        #retry-btn:active {
            transform: scale(0.95);
        }
        
        @keyframes neonPulse {
            from {
                text-shadow: 0 0 5px #00FFFF, 0 0 10px #00FFFF;
            }
            to {
                text-shadow: 0 0 10px #00FFFF, 0 0 20px #00FFFF, 0 0 30px #00FFFF;
            }
        }
        
        /* Debug console for errors */
        #debug-console {
            position: fixed;
            bottom: 10px;
            left: 10px;
            width: 80%;
            max-height: 150px;
            overflow-y: auto;
            background-color: rgba(0, 0, 0, 0.8);
            color: #FF5555;
            font-family: monospace;
            font-size: 12px;
            padding: 10px;
            border: 1px solid #FF0000;
            border-radius: 4px;
            z-index: 9999;
            display: none;
        }
    </style>
</head>
<body>
    <div id="ui">
        <div id="score-display">SCORE: 0</div>
    </div>
    
    <div id="pause-btn">
        <div></div>
        <div></div>
    </div>
    
    <div id="game-over">
        <h2>GAME OVER</h2>
        <div id="final-score">SCORE: 0</div>
        <button id="retry-btn">RETRY</button>
    </div>

    <div id="debug-console"></div>

    <!-- Load THREE.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // Debug logging
        const debug = document.getElementById('debug-console');
        debug.style.display = 'block'; // Always show initially
        
        function logDebug(message) {
            if (debug) {
                debug.innerHTML += `<div>${message}</div>`;
                debug.scrollTop = debug.scrollHeight;
            }
            console.log(message);
        }

        // Check if THREE is loaded
        if (typeof THREE === 'undefined') {
            logDebug("ERROR: THREE.js not loaded! Trying alternative CDN...");
            // Create a script element for the alternative CDN
            const script = document.createElement('script');
            script.src = "https://unpkg.com/three@0.128.0/build/three.min.js";
            script.onload = function() {
                logDebug("THREE.js loaded from alternative CDN");
                initGame();
            };
            script.onerror = function() {
                logDebug("CRITICAL ERROR: Could not load THREE.js from alternative source");
            };
            document.head.appendChild(script);
        } else {
            logDebug("THREE.js loaded successfully");
            initGame();
        }

        // Global error handling
        window.onerror = function(message, source, lineno, colno, error) {
            logDebug(`ERROR: ${message} at line ${lineno}:${colno}`);
        };

        // Wrap the game initialization in a function
        function initGame() {
            logDebug("Initializing ShapeRunner...");
            
            // Level data (embedded instead of loading from JSON files)
            const levelTitles = {
                start: {
                    title: "Starting Line",
                    description: "The player starts here on every level",
                    width: 10,
                    height: 8,
                    layout: [
                        "...........",
                        "...........",
                        "...........",
                        "...........",
                        "...........",
                        "....S......",
                        "BBBB.......",
                        "..........."
                    ]
                },
                end: {
                    title: "Finish Line",
                    description: "The end of every level with the exit portal",
                    width: 10,
                    height: 8,
                    layout: [
                        "...........",
                        "...........",
                        "......E....",
                        ".....BBB...",
                        "...........",
                        "...........",
                        "BBBBBBBBBB.",
                        "..........."
                    ]
                },
                title1: {
                    title: "Simple Platforms",
                    description: "Basic platform layout with some spikes",
                    width: 20,
                    height: 8,
                    layout: [
                        ".....................",
                        ".....................",
                        "........C............",
                        "......BBBB...........",
                        "..BBB................",
                        ".....................",
                        "B.........BBB........",
                        "...^...^.....^...^..."
                    ]
                },
                title2: {
                    title: "Jump and Slide",
                    description: "Jumps and slopes challenge",
                    width: 20,
                    height: 8,
                    layout: [
                        ".....................",
                        "............C........",
                        "..........BBBB.......",
                        "........./........C..",
                        "......../............",
                        "...J.../....C........",
                        "...B../...BBB........",
                        "^..../..^....^......."
                    ]
                },
                title3: {
                    title: "Dangerous Path",
                    description: "Navigate through spinning blades to find the key",
                    width: 20,
                    height: 8,
                    layout: [
                        ".....................",
                        "............K........",
                        "...........BBBB......",
                        ".....................",
                        ".....O...O...........",
                        "..BBB....BBB.........",
                        ".....................",
                        "^.^.^.^............^."
                    ]
                },
                title4: {
                    title: "Spike Gauntlet",
                    description: "Navigate through a dangerous spike field",
                    width: 20,
                    height: 8,
                    layout: [
                        ".....................",
                        "..........C..........",
                        "BBBB..........BBB....",
                        "....B........B.......",
                        "....B..^..^..B..C....",
                        "....BBBBBBBBB........",
                        "............J........",
                        "^.^.^.^.^.^.^B.^.^.^."
                    ]
                },
                title5: {
                    title: "Portal Finale",
                    description: "Final section with a portal to the next level",
                    width: 20,
                    height: 8,
                    layout: [
                        ".....................",
                        "..................P..",
                        "...................B.",
                        "..........C..........",
                        "........BBBB.........",
                        ".....J................",
                        "...BBB................",
                        "^.^.^.^.^............"
                    ]
                }
            };

            // LevelManager class
            class LevelManager {
                constructor() {
                    this.levelTitles = levelTitles;
                    this.currentLevel = 1;
                    this.portalPlaced = false;
                    this.startPlaced = false;
                }
                
                // Initialize the level manager
                async initialize() {
                    logDebug("Level manager initialized");
                    return true;
                }
                
                // Generate a complete level by combining multiple level titles
                generateLevel(levelNumber, difficulty = 1) {
                    try {
                        this.currentLevel = levelNumber;
                        this.portalPlaced = false;
                        this.startPlaced = false;
                        
                        logDebug(`Generating level ${levelNumber} with difficulty ${difficulty}`);
                        
                        // Always start with the 'start' title
                        const startTitle = this.levelTitles['start'];
                        
                        // Always end with the 'end' title
                        const endTitle = this.levelTitles['end'];
                        
                        // Get available middle titles (excluding start and end)
                        const availableTitles = Object.keys(this.levelTitles)
                            .filter(id => id !== 'start' && id !== 'end')
                            .map(id => this.levelTitles[id]);
                        
                        // Determine how many middle sections to include based on difficulty
                        // Higher difficulty = more sections
                        const sectionCount = 2 + Math.min(Math.floor(difficulty * 0.8), 4);
                        
                        // Randomly select middle titles
                        const selectedTitles = [];
                        for (let i = 0; i < sectionCount; i++) {
                            const randomIndex = Math.floor(Math.random() * availableTitles.length);
                            selectedTitles.push(availableTitles[randomIndex]);
                        }
                        
                        // Build the complete level by combining titles horizontally
                        // Each level title is a 2D array of ASCII characters
                        
                        // Start with a base set of empty rows
                        const maxHeight = Math.max(
                            startTitle.height,
                            endTitle.height,
                            ...selectedTitles.map(title => title.height)
                        );
                        
                        // Initialize the combined level with empty rows
                        const combinedLevel = [];
                        for (let i = 0; i < maxHeight; i++) {
                            combinedLevel.push([]);
                        }
                        
                        // Function to append a title's layout to the combined level
                        const appendTitle = (title) => {
                            const layout = title.layout;
                            
                            // For each row in the title's layout
                            for (let rowIndex = 0; rowIndex < layout.length; rowIndex++) {
                                // Get the row string and convert to array of characters
                                const rowChars = layout[rowIndex].split('');
                                
                                // Append these characters to the corresponding row in the combined level
                                const combinedRowIndex = maxHeight - layout.length + rowIndex;
                                if (combinedRowIndex >= 0) {
                                    combinedLevel[combinedRowIndex] = combinedLevel[combinedRowIndex].concat(rowChars);
                                }
                            }
                        };
                        
                        // Append titles in order: start, middle sections, end
                        appendTitle(startTitle);
                        selectedTitles.forEach(title => appendTitle(title));
                        appendTitle(endTitle);
                        
                        // Convert the 2D array back to a string format
                        const levelString = combinedLevel.map(row => row.join('')).join('\n');
                        
                        logDebug("Level generation complete");
                        return levelString;
                    } catch (error) {
                        logDebug("Error generating level: " + error.message);
                        // Return a simple fallback level if generation fails
                        return "...........\n...........\n...........\n...........\n....S......\n...........\nBBBBBBBBBBB\n...........";
                    }
                }
            }

            // Main game class
            class Game {
                constructor() {
                    logDebug("Initializing game...");
                    
                    // UI elements
                    this.scoreDisplay = document.getElementById('score-display');
                    this.pauseBtn = document.getElementById('pause-btn');
                    this.gameOverUI = document.getElementById('game-over');
                    this.finalScore = document.getElementById('final-score');
                    this.retryBtn = document.getElementById('retry-btn');
                    
                    // Event listeners
                    this.pauseBtn.addEventListener('click', () => this.togglePause());
                    this.retryBtn.addEventListener('click', () => this.restart());
                    window.addEventListener('keydown', this.handleKeyDown.bind(this));
                    window.addEventListener('resize', this.handleResize.bind(this));
                    
                    // Game properties
                    this.isRunning = false;
                    this.isPaused = false;
                    this.score = 0;
                    this.playerSize = 1;
                    this.speed = 10;
                    this.jumpForce = 15;
                    this.gravity = 25;
                    this.groundY = -8;
                    
                    // Colors
                    this.colors = {
                        background: 0x000033,
                        player: 0x00FFFF,
                        platform: 0x0066FF,
                        obstacle: 0xFF00FF,
                        collectible: 0xFFFF00
                    };
                    
                    // Level manager
                    this.levelManager = new LevelManager();
                    
                    // Initialize the game
                    this.init();
                }
                
                async init() {
                    try {
                        // Initialize level manager
                        await this.levelManager.initialize();
                        
                        // Create renderer
                        this.renderer = new THREE.WebGLRenderer({ antialias: true });
                        this.renderer.setSize(window.innerWidth, window.innerHeight);
                        document.body.appendChild(this.renderer.domElement);
                        
                        // Create scene
                        this.scene = new THREE.Scene();
                        this.scene.background = new THREE.Color(0x0A0A55); // Deeper blue like in the image
                        
                        // Create camera
                        const aspectRatio = window.innerWidth / window.innerHeight;
                        const cameraHeight = 20;
                        const cameraWidth = cameraHeight * aspectRatio;
                        this.camera = new THREE.OrthographicCamera(
                            -cameraWidth / 2, cameraWidth / 2,
                            cameraHeight / 2, -cameraHeight / 2,
                            0.1, 1000
                        );
                        this.camera.position.z = 10;
                        
                        // Add light
                        const light = new THREE.AmbientLight(0xFFFFFF, 1);
                        this.scene.add(light);
                        
                        // Create Tron grid
                        this.createGrid();
                        
                        // Create player
                        this.createPlayer();
                        
                        // Create level
                        this.createLevel();
                        
                        // Start animation loop
                        this.isRunning = true;
                        this.lastTime = performance.now();
                        this.animate();
                        
                        logDebug("Game initialized successfully");
                    } catch (error) {
                        logDebug("Error initializing game: " + error.message);
                    }
                }
                
                createGrid() {
                    // Grid size and properties
                    const gridSize = 1000;
                    const gridDivisions = 100;
                    const gridColor = 0x1144AA; // Darker blue grid lines to match image
                    
                    // Create grid with lines
                    const gridHelper = new THREE.GridHelper(gridSize, gridDivisions, gridColor, gridColor);
                    gridHelper.position.y = this.groundY - 0.4; // Slightly below ground
                    gridHelper.material.transparent = true;
                    gridHelper.material.opacity = 0.2;
                    gridHelper.material.blending = THREE.AdditiveBlending;
                    this.scene.add(gridHelper);
                    
                    // Rotate grid to make it horizontal
                    gridHelper.rotation.x = Math.PI / 2;
                    
                    // Add a plane with a grid texture for additional effect
                    const gridPlaneGeometry = new THREE.PlaneGeometry(gridSize, gridSize);
                    const gridPlaneMaterial = new THREE.MeshBasicMaterial({
                        color: 0x0A0A44, // Very dark blue background
                        transparent: true,
                        opacity: 0.9
                    });
                    const gridPlane = new THREE.Mesh(gridPlaneGeometry, gridPlaneMaterial);
                    gridPlane.position.y = this.groundY - 0.45; // Just below the grid
                    gridPlane.rotation.x = -Math.PI / 2;
                    this.scene.add(gridPlane);
                }
                
                createPlayer() {
                    // Create a composite player object to match the reference image
                    this.player = new THREE.Group();
                    this.player.position.set(-5, this.groundY + this.playerSize/2 + 0.5, 0);
                    this.scene.add(this.player);
                    
                    // Create the main square shape without rotation (matches image)
                    const mainGeometry = new THREE.BoxGeometry(this.playerSize, this.playerSize, this.playerSize * 0.5);
                    const mainMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0x00FFFF, // Bright cyan like in the image
                        transparent: true,
                        opacity: 0.9
                    });
                    const mainMesh = new THREE.Mesh(mainGeometry, mainMaterial);
                    // No rotation - keep as square
                    this.player.add(mainMesh);
                    this.playerMainMesh = mainMesh;
                    
                    // Create inner box
                    const innerGeometry = new THREE.BoxGeometry(this.playerSize * 0.6, this.playerSize * 0.6, this.playerSize * 0.5);
                    const innerMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0x0088FF, 
                        transparent: true,
                        opacity: 0.9
                    });
                    const innerMesh = new THREE.Mesh(innerGeometry, innerMaterial);
                    this.player.add(innerMesh);
                    
                    // Add bright center point
                    const centerGeometry = new THREE.BoxGeometry(this.playerSize * 0.2, this.playerSize * 0.2, this.playerSize * 0.2);
                    const centerMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xFFFFFF,
                        transparent: false
                    });
                    const centerMesh = new THREE.Mesh(centerGeometry, centerMaterial);
                    this.player.add(centerMesh);
                    
                    // Add edge lines 
                    const edges = new THREE.EdgesGeometry(mainGeometry);
                    const lineMaterial = new THREE.LineBasicMaterial({ 
                        color: 0x40FFFF, 
                        linewidth: 2
                    });
                    const wireframe = new THREE.LineSegments(edges, lineMaterial);
                    this.player.add(wireframe);
                    
                    // Create outer glow
                    const glowGeometry = new THREE.BoxGeometry(
                        this.playerSize * 1.3, 
                        this.playerSize * 1.3, 
                        this.playerSize * 0.5
                    );
                    const glowMaterial = new THREE.MeshBasicMaterial({
                        color: 0x00FFFF,
                        transparent: true,
                        opacity: 0.3,
                        blending: THREE.AdditiveBlending
                    });
                    const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
                    this.player.add(glowMesh);
                    this.playerGlow = glowMesh;
                    
                    // Trail particles have been removed per request
                    this.trailParticles = null;
                    
                    // Initialize jump particle system
                    this.jumpParticles = [];
                    this.jumpPath = null;
                    this.jumpHistoryPoints = [];
                    
                    // Player physics
                    this.playerVelocity = { x: 5, y: 0 }; // Set x velocity to 5 to move forward
                    this.isJumping = false;
                    this.onGround = false;
                    
                    logDebug("Player created with Tron-like appearance");
                }
                
                // Create jump particles effect
                createJumpParticles() {
                    // Clear any existing jump particles
                    this.jumpParticles.forEach(particle => {
                        this.scene.remove(particle);
                    });
                    this.jumpParticles = [];
                    
                    // Create new particles
                    const particleCount = 10;
                    for (let i = 0; i < particleCount; i++) {
                        const size = 0.1 + Math.random() * 0.2;
                        const particleGeometry = new THREE.BoxGeometry(size, size, size);
                        const particleMaterial = new THREE.MeshBasicMaterial({
                            color: 0x40FFFF,
                            transparent: true,
                            opacity: 0.7,
                            blending: THREE.AdditiveBlending
                        });
                        
                        const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                        
                        // Position around player's feet
                        const angle = Math.random() * Math.PI * 2;
                        const radius = 0.3 + Math.random() * 0.3;
                        const offsetX = Math.cos(angle) * radius;
                        const offsetY = Math.sin(angle) * radius;
                        
                        particle.position.set(
                            this.player.position.x + offsetX,
                            this.player.position.y - this.playerSize/2 + offsetY,
                            0
                        );
                        
                        // Add velocity for animation
                        particle.userData.velocityX = offsetX * 2;
                        particle.userData.velocityY = 2 + Math.random() * 3;
                        particle.userData.life = 1.0; // Full life
                        
                        this.scene.add(particle);
                        this.jumpParticles.push(particle);
                    }
                    
                    // Reset jump path tracking
                    this.jumpHistoryPoints = [];
                    this.jumpHistoryPoints.push(new THREE.Vector3(
                        this.player.position.x,
                        this.player.position.y,
                        0
                    ));
                    
                    // Remove any existing jump path
                    if (this.jumpPath) {
                        this.scene.remove(this.jumpPath);
                        this.jumpPath = null;
                    }
                }
                
                // Update jump path visualization
                updateJumpPath() {
                    // Add current position to jump history
                    this.jumpHistoryPoints.push(new THREE.Vector3(
                        this.player.position.x,
                        this.player.position.y,
                        0
                    ));
                    
                    // Keep only the recent history (last 20 points)
                    if (this.jumpHistoryPoints.length > 20) {
                        this.jumpHistoryPoints.shift();
                    }
                    
                    // Remove existing path
                    if (this.jumpPath) {
                        this.scene.remove(this.jumpPath);
                    }
                    
                    // Create curve from points
                    const curve = new THREE.CatmullRomCurve3(this.jumpHistoryPoints);
                    const points = curve.getPoints(50);
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    
                    // Create path material with fade effect
                    const pathMaterial = new THREE.LineBasicMaterial({
                        color: 0x00FFFF,
                        transparent: true,
                        opacity: 0.6,
                        blending: THREE.AdditiveBlending
                    });
                    
                    // Create the path
                    this.jumpPath = new THREE.Line(geometry, pathMaterial);
                    this.scene.add(this.jumpPath);
                }
                
                createLevel() {
                    logDebug("Creating level...");
                    
                    // Clear existing level objects
                    if (this.platforms) {
                        this.platforms.forEach(platform => this.scene.remove(platform));
                    }
                    if (this.obstacles) {
                        this.obstacles.forEach(obstacle => this.scene.remove(obstacle));
                    }
                    if (this.collectibles) {
                        this.collectibles.forEach(coin => this.scene.remove(coin));
                    }
                    
                    // Initialize collections
                    this.platforms = [];
                    this.obstacles = [];
                    this.collectibles = [];
                    this.portalObject = null;
                    
                    // Create ground - darker with bright outline like in the image
                    const groundGeometry = new THREE.BoxGeometry(100, 0.5, 1);
                    const groundMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0x000066, // Dark blue/black ground
                        transparent: true,
                        opacity: 0.6
                    });
                    this.ground = new THREE.Mesh(groundGeometry, groundMaterial);
                    this.ground.position.set(0, this.groundY, 0);
                    this.scene.add(this.ground);
                    this.platforms.push(this.ground);
                    
                    // Add glow effect to ground
                    const groundEdges = new THREE.EdgesGeometry(groundGeometry);
                    const groundLineMaterial = new THREE.LineBasicMaterial({ 
                        color: 0x00FFFF, 
                        linewidth: 2
                    });
                    const groundWireframe = new THREE.LineSegments(groundEdges, groundLineMaterial);
                    this.ground.add(groundWireframe);
                    
                    // Add subtle glow at ground level
                    const groundGlowGeometry = new THREE.BoxGeometry(100, 0.05, 1.5);
                    const groundGlowMaterial = new THREE.MeshBasicMaterial({
                        color: 0x00CCFF,
                        transparent: true,
                        opacity: 0.15,
                        blending: THREE.AdditiveBlending
                    });
                    const groundGlow = new THREE.Mesh(groundGlowGeometry, groundGlowMaterial);
                    groundGlow.position.y = 0.3; // Slightly above the ground
                    this.ground.add(groundGlow);
                    
                    // Generate level from level manager
                    const levelData = this.levelManager.generateLevel(1, 2);
                    this.parseLevel(levelData);
                    
                    logDebug("Level created with Tron-like effects");
                }
                
                parseLevel(levelData) {
                    const rows = levelData.split("\n");
                    
                    // Position tracking
                    let xPos = -40; // Start position
                    const tileSize = 2; // Size of each tile
                    
                    // Parse each character in the level data
                    for (let col = 0; col < rows[0].length; col++) {
                        for (let row = 0; row < rows.length; row++) {
                            // Invert row to make bottom row the ground level
                            const invertedRow = rows.length - 1 - row;
                            
                            // Get the character at this position
                            const char = rows[invertedRow][col];
                            
                            // Calculate y position - ensure everything starts from the ground level up
                            const yPos = this.groundY + 0.5 + row * tileSize;
                            
                            // Process based on character type
                            this.createTile(char, xPos, yPos);
                        }
                        
                        // Move to the next column
                        xPos += tileSize;
                    }
                }
                
                createTile(type, x, y) {
                    switch (type) {
                        case 'B': // Block/Platform
                            const platformGeometry = new THREE.BoxGeometry(2, 1, 1);
                            const platformMaterial = new THREE.MeshBasicMaterial({ 
                                color: 0x000033, // Dark blue/black platforms like in image
                                transparent: true,
                                opacity: 0.8
                            });
                            const platform = new THREE.Mesh(platformGeometry, platformMaterial);
                            platform.position.set(x, y, 0);
                            platform.userData.type = 'platform';
                            platform.userData.width = 2;
                            platform.userData.height = 1;
                            this.scene.add(platform);
                            this.platforms.push(platform);
                            
                            // Add bright edges glow effect to platforms - cyan like in image
                            const edges = new THREE.EdgesGeometry(platformGeometry);
                            const lineMaterial = new THREE.LineBasicMaterial({ 
                                color: 0x00FFFF, 
                                linewidth: 2
                            });
                            const wireframe = new THREE.LineSegments(edges, lineMaterial);
                            platform.add(wireframe);
                            
                            break;
                            
                        case '^': // Spike
                            // Use a custom triangle geometry for spike to match the image
                            const spikeShape = new THREE.Shape();
                            spikeShape.moveTo(0, 1); // Top point
                            spikeShape.lineTo(-0.6, -0.2); // Bottom left
                            spikeShape.lineTo(0.6, -0.2); // Bottom right
                            spikeShape.lineTo(0, 1); // Back to top
                            
                            const spikeGeometry = new THREE.ShapeGeometry(spikeShape);
                            const spikeMaterial = new THREE.MeshBasicMaterial({ 
                                color: 0x40FFFF, // Cyan triangles like in the image
                                transparent: true,
                                opacity: 0.8
                            });
                            const spike = new THREE.Mesh(spikeGeometry, spikeMaterial);
                            
                            // Ensure spike is above the ground, not inside it
                            if (y <= this.groundY + 0.5) {
                                y = this.groundY + 0.5; // Place the spike on top of the ground
                            }
                            
                            spike.position.set(x, y, 0);
                            spike.userData.type = 'obstacle';
                            spike.userData.width = 1.2;
                            spike.userData.height = 1.2;
                            this.scene.add(spike);
                            this.obstacles.push(spike);
                            
                            // Add glow edge effect to spikes using line segments
                            const spikeEdgesGeometry = new THREE.BufferGeometry();
                            const spikeVertices = new Float32Array([
                                0, 1, 0,       // Top point
                                -0.6, -0.2, 0, // Bottom left
                                0.6, -0.2, 0,  // Bottom right
                                0, 1, 0        // Back to top
                            ]);
                            spikeEdgesGeometry.setAttribute('position', new THREE.BufferAttribute(spikeVertices, 3));
                            
                            const spikeEdgesMaterial = new THREE.LineBasicMaterial({
                                color: 0x00FFFF,
                                linewidth: 2
                            });
                            const spikeEdges = new THREE.Line(spikeEdgesGeometry, spikeEdgesMaterial);
                            spike.add(spikeEdges);
                            
                            // Add subtle glow effect to spikes
                            const spikeGlowShape = new THREE.Shape();
                            spikeGlowShape.moveTo(0, 1.2); // Top point
                            spikeGlowShape.lineTo(-0.8, -0.3); // Bottom left
                            spikeGlowShape.lineTo(0.8, -0.3); // Bottom right
                            spikeGlowShape.lineTo(0, 1.2); // Back to top
                            
                            const spikeGlowGeometry = new THREE.ShapeGeometry(spikeGlowShape);
                            const spikeGlowMaterial = new THREE.MeshBasicMaterial({
                                color: 0x00FFFF,
                                transparent: true, 
                                opacity: 0.2,
                                blending: THREE.AdditiveBlending
                            });
                            const spikeGlow = new THREE.Mesh(spikeGlowGeometry, spikeGlowMaterial);
                            spikeGlow.position.z = -0.1; // Place slightly behind the spike
                            spike.add(spikeGlow);
                            
                            break;
                            
                        case 'C': // Coin
                            const coinGeometry = new THREE.CircleGeometry(0.5, 16);
                            const coinMaterial = new THREE.MeshBasicMaterial({ 
                                color: 0xFFFF00, // Yellow coins
                                transparent: true,
                                opacity: 0.9,
                                side: THREE.DoubleSide
                            });
                            const coin = new THREE.Mesh(coinGeometry, coinMaterial);
                            coin.position.set(x, y, 0);
                            coin.userData.type = 'coin';
                            coin.userData.width = 1;
                            coin.userData.height = 1;
                            coin.userData.collected = false;
                            this.scene.add(coin);
                            this.collectibles.push(coin);
                            
                            // Add glow effect to coins
                            const coinGlowGeometry = new THREE.CircleGeometry(0.7, 16);
                            const coinGlowMaterial = new THREE.MeshBasicMaterial({
                                color: 0xFFFF00,
                                transparent: true,
                                opacity: 0.4,
                                blending: THREE.AdditiveBlending,
                                side: THREE.DoubleSide
                            });
                            const coinGlow = new THREE.Mesh(coinGlowGeometry, coinGlowMaterial);
                            coin.add(coinGlow);
                            
                            break;
                            
                        case 'J': // Jump pad
                            const jumpPadGeometry = new THREE.BoxGeometry(1.5, 0.5, 1);
                            const jumpPadMaterial = new THREE.MeshBasicMaterial({ 
                                color: 0xFFFF00,
                                transparent: true,
                                opacity: 0.8
                            });
                            const jumpPad = new THREE.Mesh(jumpPadGeometry, jumpPadMaterial);
                            jumpPad.position.set(x, y, 0);
                            jumpPad.userData.type = 'jumpPad';
                            jumpPad.userData.width = 1.5;
                            jumpPad.userData.height = 0.5;
                            this.scene.add(jumpPad);
                            this.platforms.push(jumpPad);
                            
                            // Add edges glow effect to jump pads
                            const jumpPadEdges = new THREE.EdgesGeometry(jumpPadGeometry);
                            const jumpPadLineMaterial = new THREE.LineBasicMaterial({ 
                                color: 0xFFFF00, 
                                linewidth: 2
                            });
                            const jumpPadWireframe = new THREE.LineSegments(jumpPadEdges, jumpPadLineMaterial);
                            jumpPad.add(jumpPadWireframe);
                            
                            // Add pulse glow effect
                            const jumpPadGlowGeometry = new THREE.BoxGeometry(1.7, 0.7, 1.2);
                            const jumpPadGlowMaterial = new THREE.MeshBasicMaterial({
                                color: 0xFFFF00,
                                transparent: true,
                                opacity: 0.4,
                                blending: THREE.AdditiveBlending
                            });
                            const jumpPadGlow = new THREE.Mesh(jumpPadGlowGeometry, jumpPadGlowMaterial);
                            jumpPad.add(jumpPadGlow);
                            
                            // Store the glow mesh for animation
                            jumpPad.userData.glowMesh = jumpPadGlow;
                            break;
                            
                        case 'P': // Portal
                            const portalGeometry = new THREE.RingGeometry(0.7, 1, 32);
                            const portalMaterial = new THREE.MeshBasicMaterial({ 
                                color: 0x40FF40, // Make portals green to match the image
                                side: THREE.DoubleSide,
                                transparent: true,
                                opacity: 0.9
                            });
                            const portal = new THREE.Mesh(portalGeometry, portalMaterial);
                            
                            // Place portal at the ground level as seen in the image
                            const portalY = this.groundY + 0.75;
                            portal.position.set(x, portalY, 0);
                            
                            portal.userData.type = 'portal';
                            portal.userData.width = 2;
                            portal.userData.height = 1.5; // Reduced height
                            this.scene.add(portal);
                            this.portalObject = portal;
                            
                            // Add glow effect to portal
                            const portalGlowGeometry = new THREE.RingGeometry(0.5, 1.3, 32);
                            const portalGlowMaterial = new THREE.MeshBasicMaterial({
                                color: 0x40FF40, // Green glow
                                transparent: true,
                                opacity: 0.5,
                                blending: THREE.AdditiveBlending,
                                side: THREE.DoubleSide
                            });
                            const portalGlow = new THREE.Mesh(portalGlowGeometry, portalGlowMaterial);
                            portal.add(portalGlow);
                            
                            // Add number display on portal for level indication
                            const textGeometry = new THREE.BoxGeometry(0.6, 0.6, 0.2);
                            const textMaterial = new THREE.MeshBasicMaterial({
                                color: 0x00FF00,
                                transparent: false
                            });
                            const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                            textMesh.position.z = 0.1;
                            portal.add(textMesh);
                            
                            // Store the glow mesh for animation
                            portal.userData.glowMesh = portalGlow;
                            break;
                            
                        case 'S': // Start position
                            // Move player to start position
                            if (this.player) {
                                // Position player above the ground/marker with proper offset
                                this.player.position.set(x, y + this.playerSize/2 + 0.1, 0);
                            }
                            break;
                    }
                }
                
                handleKeyDown(event) {
                    if ((event.code === 'Space' || event.code === 'ArrowUp') && !this.isJumping && (this.onGround || this.onPlatform)) {
                        this.playerVelocity.y = this.jumpForce;
                        this.isJumping = true;
                        this.onGround = false;
                        this.onPlatform = false;
                        
                        // Create jump particles and start path tracking
                        this.createJumpParticles();
                    }
                    
                    // Increase speed when right arrow is pressed
                    if (event.code === 'ArrowRight') {
                        this.playerVelocity.x = 10; // Double speed temporarily
                        setTimeout(() => {
                            if (this.isRunning) this.playerVelocity.x = 5; // Return to normal speed after 0.5 seconds
                        }, 500);
                    }
                    
                    if (event.code === 'KeyP' || event.code === 'Escape') {
                        this.togglePause();
                    }
                }
                
                handleResize() {
                    const width = window.innerWidth;
                    const height = window.innerHeight;
                    
                    this.renderer.setSize(width, height);
                    
                    const aspectRatio = width / height;
                    const cameraHeight = 20;
                    const cameraWidth = cameraHeight * aspectRatio;
                    
                    this.camera.left = -cameraWidth / 2;
                    this.camera.right = cameraWidth / 2;
                    this.camera.top = cameraHeight / 2;
                    this.camera.bottom = -cameraHeight / 2;
                    this.camera.updateProjectionMatrix();
                }
                
                togglePause() {
                    this.isPaused = !this.isPaused;
                    logDebug("Game " + (this.isPaused ? "paused" : "resumed"));
                }
                
                restart() {
                    logDebug("Restarting game");
                    this.score = 0;
                    this.gameOverUI.style.display = 'none';
                    this.isRunning = true;
                    this.isPaused = false;
                    
                    // Reset player
                    this.player.position.set(-5, this.groundY + this.playerSize/2 + 0.5, 0);
                    this.playerVelocity.x = 5;
                    this.playerVelocity.y = 0;
                    this.isJumping = false;
                    
                    // Trail particles have been removed per request
                    
                    // Recreate level
                    this.createLevel();
                    
                    // Update UI
                    this.updateScoreDisplay();
                }
                
                animate() {
                    requestAnimationFrame(this.animate.bind(this));
                    
                    if (!this.isRunning || this.isPaused) return;
                    
                    // Calculate delta time for smooth animation
                    const now = performance.now();
                    const deltaTime = (now - this.lastTime) / 1000; // in seconds
                    this.lastTime = now;
                    
                    // Limit delta time to avoid large jumps
                    const limitedDelta = Math.min(deltaTime, 0.1);
                    
                    // Update game state
                    this.update(limitedDelta);
                    
                    // Render scene
                    this.renderer.render(this.scene, this.camera);
                }
                
                update(deltaTime) {
                    // Apply gravity to player
                    this.playerVelocity.y -= this.gravity * deltaTime;
                    
                    // Limit vertical velocity
                    this.playerVelocity.y = Math.max(this.playerVelocity.y, -30);
                    
                    // Ensure player is always moving forward
                    if (this.playerVelocity.x < 5) {
                        this.playerVelocity.x = 5;
                        logDebug("Restoring forward velocity");
                    }
                    
                    // Update player position
                    this.player.position.x += this.playerVelocity.x * deltaTime;
                    this.player.position.y += this.playerVelocity.y * deltaTime;
                    
                    // Update jump particles
                    if (this.jumpParticles.length > 0) {
                        for (let i = this.jumpParticles.length - 1; i >= 0; i--) {
                            const particle = this.jumpParticles[i];
                            
                            // Update position based on velocity
                            particle.position.x += particle.userData.velocityX * deltaTime;
                            particle.position.y += particle.userData.velocityY * deltaTime;
                            
                            // Apply gravity to particles
                            particle.userData.velocityY -= 15 * deltaTime;
                            
                            // Reduce life
                            particle.userData.life -= deltaTime * 1.5;
                            
                            // Update opacity based on life
                            particle.material.opacity = particle.userData.life * 0.7;
                            
                            // Remove if life is depleted
                            if (particle.userData.life <= 0) {
                                this.scene.remove(particle);
                                this.jumpParticles.splice(i, 1);
                            }
                        }
                    }
                    
                    // Update jump path if jumping
                    if (this.isJumping && this.jumpHistoryPoints.length > 0) {
                        this.updateJumpPath();
                    }
                    
                    // Fade out jump path when landing
                    if (!this.isJumping && this.jumpPath) {
                        this.jumpPath.material.opacity -= deltaTime * 2;
                        if (this.jumpPath.material.opacity <= 0) {
                            this.scene.remove(this.jumpPath);
                            this.jumpPath = null;
                        }
                    }
                    
                    // Trail particles have been removed per request
                    
                    // Ground collision
                    if (this.player.position.y - this.playerSize/2 < this.groundY + 0.5) { // Add a small offset to ensure player is on top
                        this.player.position.y = this.groundY + this.playerSize/2 + 0.5;
                        this.playerVelocity.y = 0;
                        this.isJumping = false;
                        this.onGround = true;
                        
                        // Gradually fade out jump path after landing
                        if (this.jumpPath) {
                            this.jumpPath.material.opacity -= deltaTime * 3;
                            if (this.jumpPath.material.opacity <= 0) {
                                this.scene.remove(this.jumpPath);
                                this.jumpPath = null;
                            }
                        }
                    } else {
                        this.onGround = false;
                    }
                    
                    // Check collisions
                    this.checkCollisions();
                    
                    // Camera follows player
                    this.camera.position.x = this.player.position.x;
                    
                    // Update UI
                    this.score += deltaTime * 10;
                    this.updateScoreDisplay();
                    
                    // Animate player glow effect
                    if (this.playerGlow) {
                        this.playerGlow.scale.x = 1 + Math.sin(performance.now() * 0.005) * 0.1;
                        this.playerGlow.scale.y = 1 + Math.sin(performance.now() * 0.005) * 0.1;
                        this.playerGlow.scale.z = 1 + Math.sin(performance.now() * 0.005) * 0.1;
                    }
                    
                    // Additional player animation during motion - square player should not rotate
                    if (this.playerMainMesh) {
                        this.playerMainMesh.rotation.z = 0;
                    }
                    
                    // Keep player upright even while jumping (no rotation), matching the image
                    this.player.rotation.z = 0;
                    
                    // Animate other elements with glow effect
                    // Animate jump pads
                    this.platforms.forEach(platform => {
                        if (platform.userData.type === 'jumpPad' && platform.userData.glowMesh) {
                            const glow = platform.userData.glowMesh;
                            glow.scale.x = 1 + Math.sin(performance.now() * 0.01) * 0.2;
                            glow.scale.y = 1 + Math.sin(performance.now() * 0.01) * 0.2;
                            glow.material.opacity = 0.3 + Math.sin(performance.now() * 0.01) * 0.2;
                        }
                    });
                    
                    // Animate portal if it exists
                    if (this.portalObject && this.portalObject.userData.glowMesh) {
                        const portalGlow = this.portalObject.userData.glowMesh;
                        portalGlow.rotation.z += deltaTime * 2;
                        portalGlow.scale.x = 1 + Math.sin(performance.now() * 0.003) * 0.15;
                        portalGlow.scale.y = 1 + Math.sin(performance.now() * 0.003) * 0.15;
                    }
                }
                
                checkCollisions() {
                    // Platform collisions
                    this.onPlatform = false;
                    
                    this.platforms.forEach(platform => {
                        if (platform === this.ground) return; // Skip ground platform
                        
                        const playerBottom = this.player.position.y - this.playerSize/2;
                        const playerTop = this.player.position.y + this.playerSize/2;
                        const playerLeft = this.player.position.x - this.playerSize/2;
                        const playerRight = this.player.position.x + this.playerSize/2;
                        
                        const platformWidth = platform.userData.width;
                        const platformHeight = platform.userData.height;
                        const platformTop = platform.position.y + platformHeight/2;
                        const platformBottom = platform.position.y - platformHeight/2;
                        const platformLeft = platform.position.x - platformWidth/2;
                        const platformRight = platform.position.x + platformWidth/2;
                        
                        // Check for collision
                        if (playerRight > platformLeft && playerLeft < platformRight &&
                            playerBottom < platformTop && playerTop > platformBottom) {
                            
                            // Coming from above (landing on platform)
                            if (this.playerVelocity.y < 0 && 
                                playerBottom - this.playerVelocity.y > platformTop - 0.1) { // Add small tolerance
                                
                                // Land on platform
                                this.player.position.y = platformTop + this.playerSize/2 + 0.01; // Small offset to prevent sticking
                                this.playerVelocity.y = 0;
                                this.isJumping = false;
                                this.onPlatform = true;
                                
                                // Check if it's a jump pad
                                if (platform.userData.type === 'jumpPad') {
                                    this.playerVelocity.y = this.jumpForce * 1.5;
                                    this.isJumping = true;
                                    this.onPlatform = false;
                                }
                            }
                            // Hit ceiling
                            else if (this.playerVelocity.y > 0 && 
                                    playerTop - this.playerVelocity.y < platformBottom + 0.1) { // Add small tolerance
                                this.player.position.y = platformBottom - this.playerSize/2 - 0.01; // Small offset
                                this.playerVelocity.y = 0;
                            }
                        }
                    });
                    
                    // Obstacle collisions
                    this.obstacles.forEach(obstacle => {
                        const playerLeft = this.player.position.x - this.playerSize/2;
                        const playerRight = this.player.position.x + this.playerSize/2;
                        const playerBottom = this.player.position.y - this.playerSize/2;
                        const playerTop = this.player.position.y + this.playerSize/2;
                        
                        const obstacleWidth = obstacle.userData.width;
                        const obstacleHeight = obstacle.userData.height;
                        const obstacleLeft = obstacle.position.x - obstacleWidth/2;
                        const obstacleRight = obstacle.position.x + obstacleWidth/2;
                        const obstacleBottom = obstacle.position.y - obstacleHeight/2;
                        const obstacleTop = obstacle.position.y + obstacleHeight/2;
                        
                        // Ensure the obstacle is not below ground or hidden within ground
                        if (obstacleTop <= this.groundY + 0.5) {
                            return; // Skip obstacles that are hidden in the ground
                        }
                        
                        // Check for collision with reduced hitbox for better gameplay feel
                        if (playerRight > obstacleLeft + 0.2 && 
                            playerLeft < obstacleRight - 0.2 &&
                            playerBottom < obstacleTop - 0.2 && 
                            playerTop > obstacleBottom + 0.2) {
                            this.gameOver();
                        }
                    });
                    
                    // Collectible collisions
                    for (let i = this.collectibles.length - 1; i >= 0; i--) {
                        const coin = this.collectibles[i];
                        if (coin.userData.collected) continue;
                        
                        const playerLeft = this.player.position.x - this.playerSize/2;
                        const playerRight = this.player.position.x + this.playerSize/2;
                        const playerBottom = this.player.position.y - this.playerSize/2;
                        const playerTop = this.player.position.y + this.playerSize/2;
                        
                        const coinWidth = coin.userData.width;
                        const coinHeight = coin.userData.height;
                        const coinLeft = coin.position.x - coinWidth/2;
                        const coinRight = coin.position.x + coinWidth/2;
                        const coinBottom = coin.position.y - coinHeight/2;
                        const coinTop = coin.position.y + coinHeight/2;
                        
                        // Check for collision
                        if (playerRight > coinLeft && playerLeft < coinRight &&
                            playerBottom < coinTop && playerTop > coinBottom) {
                            // Collect coin
                            coin.userData.collected = true;
                            this.scene.remove(coin);
                            
                            // Add to score
                            this.score += 100;
                            this.updateScoreDisplay();
                        }
                    }
                    
                    // Portal collision
                    if (this.portalObject) {
                        const playerX = this.player.position.x;
                        const playerY = this.player.position.y;
                        const portalX = this.portalObject.position.x;
                        const portalY = this.portalObject.position.y;
                        
                        // Simple distance check
                        const dx = playerX - portalX;
                        const dy = playerY - portalY;
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        
                        if (distance < 2) {
                            // Next level
                            logDebug("Portal reached - level complete!");
                            this.createLevel(); // Just reload the level for now
                        }
                    }
                }
                
                updateScoreDisplay() {
                    this.scoreDisplay.textContent = `SCORE: ${Math.floor(this.score)}`;
                }
                
                gameOver() {
                    logDebug("Game over");
                    this.isRunning = false;
                    this.finalScore.textContent = `SCORE: ${Math.floor(this.score)}`;
                    this.gameOverUI.style.display = 'block';
                }
            }

            // Initialize the game
            const game = new Game();
            
            // Keep debug console visible longer
            setTimeout(() => {
                const debugConsole = document.getElementById('debug-console');
                if (debugConsole) {
                    debugConsole.style.display = 'none';
                }
            }, 10000); // Show for 10 seconds instead of 3
            
            // Add keyboard control instructions
            logDebug("CONTROLS: Press SPACE or UP ARROW to jump");
            logDebug("Press RIGHT ARROW for temporary speed boost");
            logDebug("Game automatically moves forward");
            logDebug("Avoid spikes and collect coins!");
        }
    </script>
</body>
</html> 