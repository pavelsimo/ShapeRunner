<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ShapeRunner</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
<a target="_blank" href="https://jam.pieter.com"
   style="font-family: 'system-ui', sans-serif; position: fixed; bottom: -1px; right: -1px; padding: 7px; font-size: 14px; font-weight: bold; background: #fff; color: #000; text-decoration: none; z-index: 10; border-top-left-radius: 12px; z-index: 10000; border: 1px solid #fff;">üïπÔ∏è
    Vibe Jam 2025</a>
<div id="ui">
    <div id="score-display">SCORE: 0</div>
</div>

<div id="level-display">LEVEL 1</div>

<div id="pause-btn">
    <div></div>
    <div></div>
</div>

<div id="game-over">
    <h2>GAME OVER</h2>
    <div id="final-score">SCORE: 0</div>
    <div id="high-score">HIGH SCORE: 0</div>
    <button id="retry-btn">RETRY</button>
</div>

<div id="debug-console"></div>

<!-- Load THREE.js from CDN -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
    // Debug logging utility
    const debug = document.getElementById('debug-console');
    debug.style.display = 'block';

    // Cookie management functions
    function setCookie(name, value, days) {
        let expires = "";
        if (days) {
            const date = new Date();
            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
            expires = "; expires=" + date.toUTCString();
        }
        document.cookie = name + "=" + (value || "") + expires + "; path=/";
    }

    function getCookie(name) {
        const nameEQ = name + "=";
        const ca = document.cookie.split(';');
        for(let i = 0; i < ca.length; i++) {
            let c = ca[i];
            while (c.charAt(0) === ' ') c = c.substring(1, c.length);
            if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
        }
        return null;
    }

    function updateHighScore(score) {
        const currentHighScore = parseInt(getCookie('highScore') || '0');
        if (score > currentHighScore) {
            setCookie('highScore', score, 365); // Store for 1 year
            return score;
        }
        return currentHighScore;
    }

    function logDebug(message) {
        if (debug) {
            debug.innerHTML += `<div>${message}</div>`;
            debug.scrollTop = debug.scrollHeight;
        }
        console.log(message);
    }

    // Check if THREE.js is loaded, and if not, load an alternative CDN version.
    if (typeof THREE === 'undefined') {
        logDebug("ERROR: THREE.js not loaded! Trying alternative CDN...");
        const script = document.createElement('script');
        script.src = "https://unpkg.com/three@0.128.0/build/three.min.js";
        script.onload = function () {
            logDebug("THREE.js loaded from alternative CDN");
            initGame();
        };
        script.onerror = function () {
            logDebug("CRITICAL ERROR: Could not load THREE.js from alternative source");
        };
        document.head.appendChild(script);
    } else {
        logDebug("THREE.js loaded successfully");
        initGame();
    }

    // Global error handling
    window.onerror = function (message, source, lineno, colno, error) {
        logDebug(`ERROR: ${message} at line ${lineno}:${colno}`);
    };

    /**
     * Redirects based on the "start portal" logic.
     * This method checks if the URL contains a 'portal' parameter,
     * waits 5 seconds, then reads the 'ref' parameter to build the target URL.
     */
    function startPortalRedirection() {
        logDebug("Starting portal redirection: " + window.location.search);        
        const urlParams = new URLSearchParams(window.location.search);
        const refUrl = urlParams.get('ref');
        if (refUrl) {
            let url = refUrl;
            // Prepend 'https://' if protocol is missing.
            if (!url.startsWith('http://') && !url.startsWith('https://')) {
                url = 'https://' + url;
            }
            // Rebuild URL parameters excluding 'ref'
            const currentParams = new URLSearchParams(window.location.search);
            const newParams = new URLSearchParams();
            for (const [key, value] of currentParams) {
                if (key !== 'ref') {
                    newParams.append(key, value);
                }
            }
            const paramString = newParams.toString();
            window.location.href = url + (paramString ? '?' + paramString : '');
        }
    }

    /**
     * Redirects based on the "exit portal" logic.
     * This method constructs a new URL by appending several parameters and all existing ones,
     * preloads the target page in a hidden iframe, then immediately redirects.
     */
    function exitPortalRedirection() {
        const currentParams = new URLSearchParams(window.location.search);
        const newParams = new URLSearchParams();

        // Append additional parameters (using default values if globals are not set)
        newParams.append('portal', true);
        newParams.append('username', typeof selfUsername !== 'undefined' ? selfUsername : 'defaultUser');
        newParams.append('color', 'white');
        newParams.append('speed', typeof currentSpeed !== 'undefined' ? currentSpeed : 'defaultSpeed');

        // Append all existing URL parameters
        for (const [key, value] of currentParams) {
            newParams.append(key, value);
        }
        const paramString = newParams.toString();
        const nextPage = 'https://portal.pieter.com' + (paramString ? '?' + paramString : '');

        // Preload the target page in a hidden iframe (if not already present)
        if (!document.getElementById('preloadFrame')) {
            const iframe = document.createElement('iframe');
            iframe.id = 'preloadFrame';
            iframe.style.display = 'none';
            iframe.src = nextPage;
            document.body.appendChild(iframe);
        }

        // Redirect to the target page
        window.location.href = nextPage;
    }


    // Main game initialization ‚Äì note that the large unused level data has been removed.
    function initGame() {
        logDebug("Initializing ShapeRunner...");

        // LevelManager class handles level generation via simple ASCII section layouts.
        class LevelManager {
            constructor(game) {
                this.game = game;
                this.currentLevel = 1;
                this.maxLevels = 20;

                // Define level sections (each section is 18 rows tall - increased from 6)
                this.levelTitles = {
                    "start": [
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "S    ",
                        "BBBBB"
                    ],
                    "end": [
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "   E ",
                        "     ",
                        "     ",
                        "     ",
                        "BBBBB"
                    ],
                    "tile1": [
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        " CCC ",
                        " BBB ",
                        " VVV ",
                        "     ",
                        "     ",
                        "BBBBB"
                    ],
                    "tile2": [
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        " ^^^ ",
                        " BBB ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "BBBBB"
                    ],
                    "tile3": [
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        " CCC ",
                        " BBB ",
                        "     ",
                        "     ",
                        "     ",
                        "B^^^B"
                    ],
                    "tile4": [
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "   BB",
                        "   VV",
                        "     ",
                        "     ",
                        "^^BBB"
                    ],
                    "tile5": [
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        " ^^^ ",
                        " BBB ",
                        "     ",
                        "     ",
                        "BBB  ",
                        "VVV  ",
                        "     ",
                        "     ",
                        "BBBBB"
                    ],
                    "tile6": [
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "^^   ",
                        "BB   ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        " CCC ",
                        "BBBBB"
                    ],
                    "tile7": [
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "  J  ",
                        "     ",
                        "     ",
                        "     ",
                        "BBBBB"
                    ],
                    "tile8": [
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "CCCCC",
                        "BBBBB",
                        "VVVVV",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "BBBBB"
                    ],
                    "tile9": [
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "BB   ",
                        "VV   ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "BBB^^"
                    ],
                    "tile10": [
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "   BB",
                        "     ",
                        "     ",
                        " <B O",
                        "BBBBB"
                    ],    
                    "tile11": [
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "   BB",
                        "     ",
                        "     ",
                        " <B Q",
                        "BBBBB"
                    ],  
                    "tile12": [
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        " WW  ",
                        "     ",
                        "     ",
                        "     ",
                        "BBBBB"
                    ],   
                    "tile13": [
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "  BBB",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "BBBBB"
                    ],    
                    "tile14": [
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        " <BB ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "BBBBB"
                    ],  
                    "tile15": [
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "  C  ",
                        "  J  ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "BBBBB",
                    ],
                    "tile16": [
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        " CCC ",
                        "     ",
                        "     ",
                        "BB^^B"  
                    ],
                    "tile17": [
                        "     ",
                        "     ",
                        "     ",
                        "     ", 
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "   C ",
                        "     ",
                        "  <B ",
                        "  <B ",
                        "BBBBB"  
                    ],
                    "tile18": [
                        "     ",
                        "     ",
                        "     ",
                        "     ", 
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",                                                
                        "     ",
                        " <B> ",
                        " <B> ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "BBBBB"  
                    ],
                    "tile19": [
                        "     ",
                        "     ",
                        "     ",
                        "     ", 
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",                                                
                        "     ",
                        "     ",
                        "     ",
                        "  =  ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "BBBBB"  
                    ],
                    "tile20": [
                        "     ",
                        "     ",
                        "     ",
                        "     ", 
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",                                                
                        "     ",
                        "     ",
                        "     ",
                        "  *  ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "BBBBB"  
                    ],
                    "tile21": [
                        "     ",
                        "     ",
                        "     ",
                        "     ", 
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",                                                
                        "     ",
                        "     ",
                        "     ",
                        "  X  ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "BBBBB"  
                    ],
                    "tile22": [
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        " WWW ",
                        "     ",
                        "     ",
                        "     ",
                        "BBBBB"
                    ],
                    "tile23": [
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        " MMM ",
                        "     ",
                        "     ",
                        "     ",
                        "BBBBB"
                    ],
                    "tile24": [
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "  U  ",   
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "BBBBB"
                    ],            
                    "tile25": [
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        " <B  ",
                        " <B  ",
                        "     ",
                        "     ",
                        "     ",
                        "     ",
                        " <B  ",
                        " <B  ",
                        "BBBBB"
                    ]                    
                };
            }

            async initialize() {
                logDebug("Level manager initialized");
                return true;
            }

            nextLevel() {
                this.currentLevel++;
                if (this.currentLevel > this.maxLevels) {
                    this.currentLevel = 1;
                }
                return this.currentLevel;
            }

            generateLevel(levelNumber, difficulty = 1) {
                try {
                    this.currentLevel = levelNumber;
                    logDebug(`Generating level ${levelNumber}`);

                    const levelDisplay = document.getElementById('level-display');
                    if (levelDisplay) {
                        levelDisplay.textContent = `LEVEL ${levelNumber}`;
                    }

                    const maxHeight = 18;
                    const combinedLevel = Array.from({length: maxHeight}, () => []);

                    const appendTitle = (title) => {
                        for (let rowIndex = 0; rowIndex < title.length; rowIndex++) {
                            combinedLevel[rowIndex] = combinedLevel[rowIndex].concat(title[rowIndex].split(''));
                        }
                    };

                    // Always start with the "start" section
                    appendTitle(this.levelTitles['start']);

                    // Calculate number of sections based on level number
                    const baseNumSections = 30;
                    const additionalSections = Math.min(Math.floor(levelNumber / 2), 15);
                    const numSections = baseNumSections + additionalSections;

                    // Track special tile appearances
                    const specialCounts = {
                        magnet: 0,        // '='
                        invisibility: 0,  // '*'
                        enterPortal: 0,   // 'Q'
                        exitPortal: 0     // 'O'
                    };

                    // Helper function to check if a tile contains any special items
                    const hasSpecialItem = (tile) => {
                        const tileContent = this.levelTitles[tile].join('');
                        return tileContent.includes('=') || 
                               tileContent.includes('*') || 
                               tileContent.includes('Q') || 
                               tileContent.includes('O');
                    };

                    // Helper function to count special items in a tile
                    const countSpecialItems = (tile) => {
                        const tileContent = this.levelTitles[tile].join('');
                        if (tileContent.includes('=')) specialCounts.magnet++;
                        if (tileContent.includes('*')) specialCounts.invisibility++;
                        if (tileContent.includes('Q')) specialCounts.enterPortal++;
                        if (tileContent.includes('O')) specialCounts.exitPortal++;
                    };

                    // Randomly choose between available tiles for each section
                    const availableTiles = Object.keys(this.levelTitles).filter(key =>
                        key !== 'start' && key !== 'end'
                    );
                    logDebug(`Available tiles: ${availableTiles.join(', ')}`);

                    // Track the last 3 tiles to prevent repetition within that window
                    const recentTiles = [];
                    const maxHistorySize = 3;

                    for (let i = 0; i < numSections; i++) {
                        // Filter out tiles based on special item limits
                        let validTiles = availableTiles.filter(tile => {
                            const tileContent = this.levelTitles[tile].join('');
                            if (specialCounts.magnet >= 1 && tileContent.includes('=')) return false;
                            if (specialCounts.invisibility >= 1 && tileContent.includes('*')) return false;
                            if (specialCounts.enterPortal >= 1 && tileContent.includes('Q')) return false;
                            if (specialCounts.exitPortal >= 1 && tileContent.includes('O')) return false;
                            return !recentTiles.includes(tile);
                        });

                        // If no valid tiles available, use any tile except special items and recent ones
                        if (validTiles.length === 0) {
                            validTiles = availableTiles.filter(tile => 
                                !hasSpecialItem(tile) && tile !== recentTiles[recentTiles.length - 1]
                            );
                        }

                        // Select a random tile from valid options
                        const randomIndex = Math.floor(Math.random() * validTiles.length);
                        const tileType = validTiles[randomIndex];

                        logDebug(`Adding tile: ${tileType}`);
                        appendTitle(this.levelTitles[tileType]);

                        // Update special item counts
                        countSpecialItems(tileType);

                        // Update recent tiles history
                        recentTiles.push(tileType);
                        if (recentTiles.length > maxHistorySize) {
                            recentTiles.shift();
                        }
                    }

                    // Always end with the "end" section
                    appendTitle(this.levelTitles['end']);

                    const levelString = combinedLevel.map(row => row.join('')).join('\n');
                    logDebug(`Level generation complete. Special items: Magnet=${specialCounts.magnet}, ` +
                            `Invisibility=${specialCounts.invisibility}, Enter Portal=${specialCounts.enterPortal}, ` +
                            `Exit Portal=${specialCounts.exitPortal}`);
                    return levelString;
                } catch (error) {
                    logDebug("Error generating level: " + error.message);
                    return "...........\n...........\n...........\n...........\n....S......\n...........\nBBBBBBBBBBB\n...........";
                }
            }
        }

        // Main Game class.
        class Game {
            constructor() {
                logDebug("Initializing game...");

                // UI elements
                this.scoreDisplay = document.getElementById('score-display');
                this.pauseBtn = document.getElementById('pause-btn');
                this.gameOverUI = document.getElementById('game-over');
                this.finalScore = document.getElementById('final-score');
                this.retryBtn = document.getElementById('retry-btn');
                this.highScore = document.getElementById('high-score');

                // Add isMuted property
                this.isMuted = false;

                // Constants
                this.tileSize = 2;
                this.groundY = -8;
                // Remove fixed player color to allow for adaptive colors

                // Event listeners
                this.pauseBtn.addEventListener('click', () => this.togglePause());
                this.retryBtn.addEventListener('click', () => this.restart());
                window.addEventListener('keydown', this.handleKeyDown.bind(this));
                window.addEventListener('resize', this.handleResize.bind(this));
                // Add touch event listener for mobile devices
                window.addEventListener('touchstart', () => this.jump());

                // Game properties
                this.isRunning = false;
                this.isPaused = false;
                this.score = 0;
                this.playerSize = 1;
                this.speed = 15; // Doubled from 10 to 20
                this.baseVelocity = 7.5; // Base x-velocity for the player
                this.boostVelocity = 10; // Velocity when using speed boost
                this.jumpForce = 15;
                this.gravity = 25;
                this.portal = null;
                this.portalPosition = {x: 0, y: 0};
                this.isInvincible = false; // Add invincibility flag
                
                // Magnet powerup properties
                this.hasMagnet = false;
                this.magnetTimer = null;
                this.magnetDuration = 10000; // 10 seconds
                this.magnetRange = 10; // Range in world units
                this.magnetAttractionSpeed = 15; // Speed at which coins move towards player

                // Invisibility powerup properties
                this.isInvisible = false;
                this.invisibilityTimer = null;
                this.invisibilityDuration = 10000; // 10 seconds
                this.originalPlayerOpacity = 0.9;

                // Level themes
                this.themes = [
                    { // Level 1 - Cyan
                        background: 0x0A0A55,
                        grid: 0x1144AA,
                        player: 0xFF00FF, // Magenta - good contrast with dark purple
                        platform: 0x000033,
                        platformEdge: 0x00FFFF,
                        obstacle: 0x40FFFF,
                        obstacleEdge: 0x00FFFF,
                        collectible: 0xFFFF00,
                        portal: 0x00FFFF,
                        portalEdge: 0x80FFFF,
                        jumpPad: 0x004466,
                        jumpPadEdge: 0x00FFFF,
                        scoreGlow: '#00FFFF',
                        levelGlow: '#00FFFF'
                    },
                    { // Level 2 - Purple
                        background: 0x110033,
                        grid: 0x4400AA,
                        player: 0x00FFFF, // Cyan - good contrast with dark blue
                        platform: 0x220033,
                        platformEdge: 0xFF00FF,
                        obstacle: 0xFF00AA,
                        obstacleEdge: 0xFF00FF,
                        collectible: 0xFFFF00,
                        portal: 0xFF00FF,
                        portalEdge: 0xFF80FF,
                        jumpPad: 0x440066,
                        jumpPadEdge: 0xFF00FF,
                        scoreGlow: '#FF00FF',
                        levelGlow: '#FF00FF'
                    },
                    { // Level 3 - Green
                        background: 0x002222,
                        grid: 0x006644,
                        player: 0xFF1493, // Hot pink - good contrast with dark green
                        platform: 0x003322,
                        platformEdge: 0x00FF88,
                        obstacle: 0x00CC66,
                        obstacleEdge: 0x00FF88,
                        collectible: 0xFFFF00,
                        portal: 0x00FF88,
                        portalEdge: 0x80FFB0,
                        jumpPad: 0x004433,
                        jumpPadEdge: 0x00FF88,
                        scoreGlow: '#00FF88',
                        levelGlow: '#00FF88'
                    },
                    { // Level 4 - Orange
                        background: 0x221100,
                        grid: 0x663300,
                        player: 0x00FFFF, // Cyan - good contrast with dark orange
                        platform: 0x331100,
                        platformEdge: 0xFF6600,
                        obstacle: 0xFF8800,
                        obstacleEdge: 0xFF6600,
                        collectible: 0xFFFF00,
                        portal: 0xFF6600,
                        portalEdge: 0xFFAA80,
                        jumpPad: 0x663300,
                        jumpPadEdge: 0xFF6600,
                        scoreGlow: '#FF6600',
                        levelGlow: '#FF6600'
                    },
                    { // Level 5 - Blue
                        background: 0x000033,
                        grid: 0x0033CC,
                        player: 0xFF00FF, // Magenta - good contrast with dark blue
                        platform: 0x000044,
                        platformEdge: 0x3399FF,
                        obstacle: 0x0066FF,
                        obstacleEdge: 0x3399FF,
                        collectible: 0xFFFF00,
                        portal: 0x3399FF,
                        portalEdge: 0x80C0FF,
                        jumpPad: 0x001144,
                        jumpPadEdge: 0x3399FF,
                        scoreGlow: '#3399FF',
                        levelGlow: '#3399FF'
                    },
                    { // Level 6 - Red
                        background: 0x330000,
                        grid: 0x660000,
                        player: 0x00FFFF,
                        platform: 0x440000,
                        platformEdge: 0xFF0000,
                        obstacle: 0xFF3333,
                        obstacleEdge: 0xFF0000,
                        collectible: 0xFFFF00,
                        portal: 0xFF0000,
                        portalEdge: 0xFF8080,
                        jumpPad: 0x660000,
                        jumpPadEdge: 0xFF0000,
                        scoreGlow: '#FF0000',
                        levelGlow: '#FF0000'
                    },
                    { // Level 7 - Gold
                        background: 0x332200,
                        grid: 0x664400,
                        player: 0x00FFFF,
                        platform: 0x443300,
                        platformEdge: 0xFFD700,
                        obstacle: 0xFFC000,
                        obstacleEdge: 0xFFD700,
                        collectible: 0xFFFF00,
                        portal: 0xFFD700,
                        portalEdge: 0xFFE680,
                        jumpPad: 0x664400,
                        jumpPadEdge: 0xFFD700,
                        scoreGlow: '#FFD700',
                        levelGlow: '#FFD700'
                    },
                    { // Level 8 - Pink
                        background: 0x330033,
                        grid: 0x660066,
                        player: 0x00FFFF,
                        platform: 0x440044,
                        platformEdge: 0xFF69B4,
                        obstacle: 0xFF99CC,
                        obstacleEdge: 0xFF69B4,
                        collectible: 0xFFFF00,
                        portal: 0xFF69B4,
                        portalEdge: 0xFFB4DA,
                        jumpPad: 0x660066,
                        jumpPadEdge: 0xFF69B4,
                        scoreGlow: '#FF69B4',
                        levelGlow: '#FF69B4'
                    },
                    { // Level 9 - Turquoise
                        background: 0x003333,
                        grid: 0x006666,
                        player: 0xFF1493,
                        platform: 0x004444,
                        platformEdge: 0x40E0D0,
                        obstacle: 0x66E6D9,
                        obstacleEdge: 0x40E0D0,
                        collectible: 0xFFFF00,
                        portal: 0x40E0D0,
                        portalEdge: 0xA0F0E8,
                        jumpPad: 0x006666,
                        jumpPadEdge: 0x40E0D0,
                        scoreGlow: '#40E0D0',
                        levelGlow: '#40E0D0'
                    },
                    { // Level 10 - Lime
                        background: 0x223300,
                        grid: 0x446600,
                        player: 0xFF1493,
                        platform: 0x334400,
                        platformEdge: 0x32CD32,
                        obstacle: 0x66E632,
                        obstacleEdge: 0x32CD32,
                        collectible: 0xFFFF00,
                        portal: 0x32CD32,
                        portalEdge: 0x99E699,
                        jumpPad: 0x446600,
                        jumpPadEdge: 0x32CD32,
                        scoreGlow: '#32CD32',
                        levelGlow: '#32CD32'
                    },
                    { // Level 11 - Silver
                        background: 0x222222,
                        grid: 0x444444,
                        player: 0x00FFFF,
                        platform: 0x333333,
                        platformEdge: 0xC0C0C0,
                        obstacle: 0xD9D9D9,
                        obstacleEdge: 0xC0C0C0,
                        collectible: 0xFFFF00,
                        portal: 0xC0C0C0,
                        portalEdge: 0xE0E0E0,
                        jumpPad: 0x444444,
                        jumpPadEdge: 0xC0C0C0,
                        scoreGlow: '#C0C0C0',
                        levelGlow: '#C0C0C0'
                    },
                    { // Level 12 - Bronze
                        background: 0x332211,
                        grid: 0x664422,
                        player: 0x00FFFF,
                        platform: 0x443322,
                        platformEdge: 0xCD7F32,
                        obstacle: 0xE69C5B,
                        obstacleEdge: 0xCD7F32,
                        collectible: 0xFFFF00,
                        portal: 0xCD7F32,
                        portalEdge: 0xE6BF99,
                        jumpPad: 0x664422,
                        jumpPadEdge: 0xCD7F32,
                        scoreGlow: '#CD7F32',
                        levelGlow: '#CD7F32'
                    },
                    { // Level 13 - Emerald
                        background: 0x003322,
                        grid: 0x006644,
                        player: 0xFF1493,
                        platform: 0x004433,
                        platformEdge: 0x50C878,
                        obstacle: 0x79D98C,
                        obstacleEdge: 0x50C878,
                        collectible: 0xFFFF00,
                        portal: 0x50C878,
                        portalEdge: 0xA8E4BC,
                        jumpPad: 0x006644,
                        jumpPadEdge: 0x50C878,
                        scoreGlow: '#50C878',
                        levelGlow: '#50C878'
                    },
                    { // Level 14 - Ruby
                        background: 0x330011,
                        grid: 0x660022,
                        player: 0x00FFFF,
                        platform: 0x440022,
                        platformEdge: 0xE0115F,
                        obstacle: 0xE6598C,
                        obstacleEdge: 0xE0115F,
                        collectible: 0xFFFF00,
                        portal: 0xE0115F,
                        portalEdge: 0xF088AF,
                        jumpPad: 0x660022,
                        jumpPadEdge: 0xE0115F,
                        scoreGlow: '#E0115F',
                        levelGlow: '#E0115F'
                    },
                    { // Level 15 - Sapphire
                        background: 0x001133,
                        grid: 0x002266,
                        player: 0xFF1493,
                        platform: 0x002244,
                        platformEdge: 0x0F52BA,
                        obstacle: 0x4785D9,
                        obstacleEdge: 0x0F52BA,
                        collectible: 0xFFFF00,
                        portal: 0x0F52BA,
                        portalEdge: 0x87A9E6,
                        jumpPad: 0x002266,
                        jumpPadEdge: 0x0F52BA,
                        scoreGlow: '#0F52BA',
                        levelGlow: '#0F52BA'
                    },
                    { // Level 16 - Amethyst
                        background: 0x220033,
                        grid: 0x440066,
                        player: 0x00FFFF,
                        platform: 0x330044,
                        platformEdge: 0x9966CC,
                        obstacle: 0xB28CE6,
                        obstacleEdge: 0x9966CC,
                        collectible: 0xFFFF00,
                        portal: 0x9966CC,
                        portalEdge: 0xCCB3E6,
                        jumpPad: 0x440066,
                        jumpPadEdge: 0x9966CC,
                        scoreGlow: '#9966CC',
                        levelGlow: '#9966CC'
                    },
                    { // Level 17 - Aquamarine
                        background: 0x003344,
                        grid: 0x006688,
                        player: 0xFF1493,
                        platform: 0x004455,
                        platformEdge: 0x7FFFD4,
                        obstacle: 0xA6FFE3,
                        obstacleEdge: 0x7FFFD4,
                        collectible: 0xFFFF00,
                        portal: 0x7FFFD4,
                        portalEdge: 0xBFFFEA,
                        jumpPad: 0x006688,
                        jumpPadEdge: 0x7FFFD4,
                        scoreGlow: '#7FFFD4',
                        levelGlow: '#7FFFD4'
                    },
                    { // Level 18 - Coral
                        background: 0x331111,
                        grid: 0x662222,
                        player: 0x00FFFF,
                        platform: 0x442222,
                        platformEdge: 0xFF7F50,
                        obstacle: 0xFFA679,
                        obstacleEdge: 0xFF7F50,
                        collectible: 0xFFFF00,
                        portal: 0xFF7F50,
                        portalEdge: 0xFFBFA8,
                        jumpPad: 0x662222,
                        jumpPadEdge: 0xFF7F50,
                        scoreGlow: '#FF7F50',
                        levelGlow: '#FF7F50'
                    },
                    { // Level 19 - Indigo
                        background: 0x110033,
                        grid: 0x220066,
                        player: 0x00FFFF,
                        platform: 0x220044,
                        platformEdge: 0x4B0082,
                        obstacle: 0x7433B5,
                        obstacleEdge: 0x4B0082,
                        collectible: 0xFFFF00,
                        portal: 0x4B0082,
                        portalEdge: 0x9580C1,
                        jumpPad: 0x220066,
                        jumpPadEdge: 0x4B0082,
                        scoreGlow: '#4B0082',
                        levelGlow: '#4B0082'
                    },
                    { // Level 20 - Rainbow
                        background: 0x000000,
                        grid: 0x333333,
                        player: 0xFFFFFF,
                        platform: 0x222222,
                        platformEdge: 0xFF1493,
                        obstacle: 0xFF69B4,
                        obstacleEdge: 0xFF1493,
                        collectible: 0xFFFF00,
                        portal: 0xFF1493,
                        portalEdge: 0xFF8AC9,
                        jumpPad: 0x333333,
                        jumpPadEdge: 0xFF1493,
                        scoreGlow: '#FF1493',
                        levelGlow: '#FF1493'
                    }
                ];

                // Default colors (if needed)
                this.colors = {
                    background: 0x000033,
                    player: 0x00FFFF,
                    platform: 0x0066FF,
                    obstacle: 0xFF00FF,
                    collectible: 0xFFFF00
                };

                // Level manager
                this.levelManager = new LevelManager(this);

                // Other game state collections
                this.platforms = [];
                this.obstacles = [];
                this.collectibles = [];
                this.floorTilePositions = [];

                // Initialize sound effects
                this.initSounds();

                // Start initialization
                this.init();
            }

            // Initialize sound effects
            initSounds() {
                try {
                    // Create audio elements using local files from assets folder
                    this.sounds = {
                        coin: new Audio("assets/coin.wav"),
                        jump: new Audio("assets/jump.wav"),
                        death: new Audio("assets/death.wav")
                    };

                    // Preload all sounds
                    Object.values(this.sounds).forEach(audio => {
                        audio.load();
                        audio.volume = 0.5;
                    });

                    // Initialize background music
                    this.backgroundMusic = new Audio("assets/background.mp3");
                    this.backgroundMusic.loop = true;
                    this.backgroundMusic.volume = 0.3; // Lower volume for background music
                    this.backgroundMusic.load();

                    logDebug("Sound effects initialized from assets folder");
                } catch (error) {
                    logDebug("Error initializing sound effects: " + error.message);
                }
            }

            // Play a sound with the given name
            playSound(name, volume = 0.5) {
                try {
                    if (!this.sounds[name] || this.isMuted) return;

                    // Clone the audio to allow overlapping sounds
                    const sound = this.sounds[name].cloneNode();
                    sound.volume = volume;

                    // Play the sound
                    sound.play().catch(error => {
                        // Handle autoplay restrictions
                        logDebug(`Error playing sound ${name}: ${error.message}`);
                    });
                } catch (error) {
                    logDebug(`Error playing sound ${name}: ${error.message}`);
                }
            }

            // Play background music
            playBackgroundMusic() {
                if (!this.backgroundMusic) return;

                this.backgroundMusic.volume = this.isMuted ? 0 : 0.3;
                this.backgroundMusic.play().catch(error => {
                    // Handle autoplay restrictions - try again after user interaction
                    logDebug(`Error playing background music: ${error.message}`);

                    // Add one-time click listener to start music after user interaction
                    const startAudio = () => {
                        this.backgroundMusic.volume = this.isMuted ? 0 : 0.3;
                        this.backgroundMusic.play();
                        document.removeEventListener('click', startAudio);
                        document.removeEventListener('keydown', startAudio);
                    };

                    document.addEventListener('click', startAudio);
                    document.addEventListener('keydown', startAudio);
                });
            }

            // Pause background music
            pauseBackgroundMusic() {
                if (this.backgroundMusic) {
                    this.backgroundMusic.pause();
                }
            }

            // Helper to get the current theme based on level.
            getTheme() {
                const themeIndex = (this.levelManager.currentLevel - 1) % this.themes.length;
                return this.themes[themeIndex];
            }

            async init() {
                try {
                    await this.levelManager.initialize();

                    this.renderer = new THREE.WebGLRenderer({antialias: true});
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                    document.body.appendChild(this.renderer.domElement);

                    this.scene = new THREE.Scene();
                    this.scene.background = new THREE.Color(this.getTheme().background);

                    const aspectRatio = window.innerWidth / window.innerHeight;
                    const cameraHeight = 20;
                    const cameraWidth = cameraHeight * aspectRatio;
                    this.camera = new THREE.OrthographicCamera(
                        -cameraWidth / 2, cameraWidth / 2,
                        cameraHeight / 2, -cameraHeight / 2,
                        0.1, 1000
                    );
                    this.camera.position.z = 10;

                    const light = new THREE.AmbientLight(0xFFFFFF, 1);
                    this.scene.add(light);

                    this.createGrid();
                    this.createPlayer();
                    this.createLevel();
                    this.updateUITheme();

                    this.isRunning = true;
                    this.lastTime = performance.now();
                    this.animate();

                    // Start playing background music
                    this.playBackgroundMusic();

                    logDebug("Game initialized successfully");
                } catch (error) {
                    logDebug("Error initializing game: " + error.message);
                }
            }

            createGrid() {
                const theme = this.getTheme();
                const gridSize = 1000;
                const gridDivisions = 200;
                const gridColor = theme.grid;

                const gridHelper = new THREE.GridHelper(gridSize, gridDivisions, gridColor, gridColor);
                gridHelper.position.y = this.groundY - 0.4;
                gridHelper.material.transparent = true;
                gridHelper.material.opacity = 0.3;
                gridHelper.material.blending = THREE.AdditiveBlending;
                gridHelper.rotation.x = Math.PI / 2;
                gridHelper.isGridHelper = true;
                this.scene.add(gridHelper);

                const secondaryGridSize = 500;
                const secondaryGridDivisions = 50;
                const secondaryGridHelper = new THREE.GridHelper(secondaryGridSize, secondaryGridDivisions, gridColor, gridColor);
                secondaryGridHelper.position.y = this.groundY - 0.39;
                secondaryGridHelper.material.transparent = true;
                secondaryGridHelper.material.opacity = 0.4;
                secondaryGridHelper.material.blending = THREE.AdditiveBlending;
                secondaryGridHelper.rotation.x = Math.PI / 2;
                secondaryGridHelper.isGridHelper = true;
                this.scene.add(secondaryGridHelper);

                const gridPlaneGeometry = new THREE.PlaneGeometry(gridSize, gridSize);
                const gridPlaneMaterial = new THREE.MeshBasicMaterial({
                    color: 0x0A0A44,
                    transparent: true,
                    opacity: 0.9
                });
                const gridPlane = new THREE.Mesh(gridPlaneGeometry, gridPlaneMaterial);
                gridPlane.position.y = this.groundY - 0.45;
                gridPlane.rotation.x = -Math.PI / 2;
                gridPlane.isGridPlane = true;
                this.scene.add(gridPlane);
            }

            createPlayer() {
                const theme = this.getTheme();
                this.playerSize = 1.0;
                this.player = new THREE.Group();
                // Position the player on top of the floor (floor top is at groundY + 1.0)
                this.player.position.set(-5, this.groundY + 1.0 + this.playerSize / 2, 0);
                this.scene.add(this.player);

                const mainGeometry = new THREE.BoxGeometry(this.playerSize, this.playerSize, this.playerSize * 0.5);
                const mainMaterial = new THREE.MeshBasicMaterial({
                    color: theme.player, // Use the fixed player color
                    transparent: true,
                    opacity: 0.9
                });
                const mainMesh = new THREE.Mesh(mainGeometry, mainMaterial);
                this.player.add(mainMesh);
                this.playerMainMesh = mainMesh;

                // Create a lighter color for the inner box
                const innerColor = new THREE.Color(theme.player).multiplyScalar(1.4); // Make the color 40% brighter

                const innerGeometry = new THREE.BoxGeometry(this.playerSize * 0.6, this.playerSize * 0.6, this.playerSize * 0.5);
                const innerMaterial = new THREE.MeshBasicMaterial({
                    color: innerColor,
                    transparent: true,
                    opacity: 0.9
                });
                const innerMesh = new THREE.Mesh(innerGeometry, innerMaterial);
                this.player.add(innerMesh);

                const centerGeometry = new THREE.BoxGeometry(this.playerSize * 0.2, this.playerSize * 0.2, this.playerSize * 0.2);
                const centerMaterial = new THREE.MeshBasicMaterial({color: 0xFFFFFF});
                const centerMesh = new THREE.Mesh(centerGeometry, centerMaterial);
                this.player.add(centerMesh);

                const edges = new THREE.EdgesGeometry(mainGeometry);
                const lineMaterial = new THREE.LineBasicMaterial({
                    color: theme.player, // Use the fixed player color for edges too
                    linewidth: 2
                });
                const wireframe = new THREE.LineSegments(edges, lineMaterial);
                this.player.add(wireframe);
                this.playerWireframe = wireframe;

                const glowGeometry = new THREE.BoxGeometry(this.playerSize * 1.3, this.playerSize * 1.3, this.playerSize * 0.5);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: theme.player, // Use the fixed player color for glow
                    transparent: true,
                    opacity: 0.3,
                    blending: THREE.AdditiveBlending
                });
                const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
                this.player.add(glowMesh);
                this.playerGlow = glowMesh;

                this.jumpParticles = [];
                this.jumpPath = null;
                this.jumpHistoryPoints = [];

                this.playerVelocity = {x: this.baseVelocity, y: 0}; // Use baseVelocity instead of hardcoded value
                this.isJumping = false;
                this.onGround = false;
                this.onPlatform = false;

                this.levelDisplay = document.getElementById('level-display');
                this.currentPlayerThemeColor = theme.player;

                logDebug("Player created with Tron-like appearance");
            }

            createJumpParticles() {
                const theme = this.getTheme();
                const particleColor = theme.player; // Use the fixed player color
                this.jumpParticles.forEach(particle => this.scene.remove(particle));
                this.jumpParticles = [];
                const particleCount = 10;
                for (let i = 0; i < particleCount; i++) {
                    const size = 0.1 + Math.random() * 0.2;
                    const particleGeometry = new THREE.BoxGeometry(size, size, size);
                    const particleMaterial = new THREE.MeshBasicMaterial({
                        color: particleColor,
                        transparent: true,
                        opacity: 0.7,
                        blending: THREE.AdditiveBlending
                    });
                    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 0.3 + Math.random() * 0.3;
                    const offsetX = Math.cos(angle) * radius;
                    const offsetY = Math.sin(angle) * radius;
                    particle.position.set(
                        this.player.position.x + offsetX,
                        this.player.position.y - this.playerSize / 2 + offsetY,
                        0
                    );
                    particle.userData.velocityX = offsetX * 2;
                    particle.userData.velocityY = 2 + Math.random() * 3;
                    particle.userData.life = 1.0;
                    this.scene.add(particle);
                    this.jumpParticles.push(particle);
                }
                this.jumpHistoryPoints = [new THREE.Vector3(this.player.position.x, this.player.position.y, 0)];
                if (this.jumpPath) {
                    this.scene.remove(this.jumpPath);
                    this.jumpPath = null;
                }
            }

            updateJumpPath() {
                const theme = this.getTheme();
                const pathColor = theme.player; // Use the fixed player color
                this.jumpHistoryPoints.push(new THREE.Vector3(this.player.position.x, this.player.position.y, 0));
                if (this.jumpHistoryPoints.length > 20) this.jumpHistoryPoints.shift();
                if (this.jumpPath) this.scene.remove(this.jumpPath);
                const curve = new THREE.CatmullRomCurve3(this.jumpHistoryPoints);
                const numPoints = 50;
                const points = curve.getPoints(numPoints);
                const pathGeometry = new THREE.BufferGeometry();
                const positions = [];
                const indices = [];
                for (let i = 0; i < points.length; i++) {
                    const point = points[i];
                    const widthFactor = i / points.length;
                    const width = 0.05 + widthFactor * 0.2;
                    let tangent = i < points.length - 1 ? new THREE.Vector3().subVectors(points[i + 1], point).normalize() : new THREE.Vector3().subVectors(point, points[i - 1]).normalize();
                    const normal = new THREE.Vector3(-tangent.y, tangent.x, 0).normalize();
                    const v1 = new THREE.Vector3().addVectors(point, normal.clone().multiplyScalar(width));
                    const v2 = new THREE.Vector3().subVectors(point, normal.clone().multiplyScalar(width));
                    positions.push(v1.x, v1.y, v1.z, v2.x, v2.y, v2.z);
                    if (i > 0) {
                        const base = (i - 1) * 2;
                        indices.push(base, base + 1, base + 2, base + 1, base + 3, base + 2);
                    }
                }
                pathGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                pathGeometry.setIndex(indices);
                const pathMaterial = new THREE.MeshBasicMaterial({
                    color: pathColor,
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending,
                    side: THREE.DoubleSide
                });
                this.jumpPath = new THREE.Mesh(pathGeometry, pathMaterial);
                this.scene.add(this.jumpPath);
            }

            createLevel() {
                // First clear the existing level completely
                this.clearLevel();

                // Reset arrays for new level objects
                this.platforms = [];
                this.obstacles = [];
                this.collectibles = [];
                this.floorTilePositions = [];
                this.startPosition = null; // Reset start position

                // Set the theme for the new level
                const theme = this.getTheme();
                this.scene.background = new THREE.Color(theme.background);

                // Update player colors to match the new theme
                this.updatePlayerTheme();

                // Update UI to match the theme
                document.getElementById('score-display').style.textShadow =
                    `0 0 10px ${theme.scoreGlow}, 0 0 20px ${theme.scoreGlow}, 0 0 30px ${theme.scoreGlow}`;
                document.getElementById('level-display').style.textShadow =
                    `0 0 10px ${theme.levelGlow}, 0 0 20px ${theme.levelGlow}, 0 0 30px ${theme.levelGlow}`;

                // Generate and parse the level data
                const levelData = this.levelManager.generateLevel(this.levelManager.currentLevel, 2);
                this.parseLevel(levelData);

                // Position player at the beginning of the level
                // Default to left side if no start marker is found
                if (!this.startPosition) {
                    // Position at the far left of the level 
                    // (level starts around -40 based on parseLevel xPos initialization)
                    this.player.position.set(-39, this.groundY + 1.0 + this.playerSize / 2, 0);
                } else {
                    // Use the start position from the level 
                    this.player.position.set(this.startPosition.x, this.startPosition.y + this.playerSize / 2, 0);
                }

                // Reset velocities and ensure player is on ground
                this.playerVelocity.x = this.baseVelocity;
                this.playerVelocity.y = 0;
                this.isJumping = false;
                this.onGround = true;

                // Log completion
                logDebug("Level created");
            }

            parseLevel(levelData) {
                const rows = levelData.split("\n");
                // Use tileSpacing of 1 since we've already increased the number of rows
                const tileSpacing = 1;
                let xPos = -40;
                for (let col = 0; col < rows[0].length; col++) {
                    for (let row = 0; row < rows.length; row++) {
                        const invertedRow = rows.length - 1 - row;
                        const char = rows[invertedRow][col];
                        // Set yPos to align with grid cell bottom for consistent positioning
                        const yPos = this.groundY + row * tileSpacing;
                        const isBottomRow = (row === 0);
                        if (char === 'B' && isBottomRow) {
                            if (!this.floorTilePositions) this.floorTilePositions = [];
                            this.floorTilePositions.push(xPos);
                        }
                        // Always create tiles, even for bottom row - we'll handle special cases in createTile
                        this.createTile(char, xPos, yPos, isBottomRow);
                    }
                    xPos += tileSpacing;
                }
                this.createFloor();
            }

            createTile(type, x, y, isBottomRow) {
                const theme = this.getTheme();
                const platformHeight = 1;

                // Skip B blocks in bottom row as they'll be part of the main floor
                if (isBottomRow && type === 'B') return;

                // Helper function to properly dispose materials and geometries
                const disposeMesh = (mesh) => {
                    if (mesh.geometry) mesh.geometry.dispose();
                    if (mesh.material) {
                        if (Array.isArray(mesh.material)) {
                            mesh.material.forEach(mat => mat.dispose());
                        } else {
                            mesh.material.dispose();
                        }
                    }
                };

                switch (type) {
                    case 'B':
                    case 'M':
                    case 'W':
                        const platformGeometry = new THREE.BoxGeometry(1, 1, 1);
                        const platformMaterial = new THREE.MeshBasicMaterial({
                            color: theme.platform,
                            transparent: true,
                            opacity: 0.8
                        });
                        const platform = new THREE.Mesh(platformGeometry, platformMaterial);
                        // Position platform in center of grid cell
                        platform.position.set(x, y + platformHeight / 2, 0);
                        platform.userData = {
                            type: type === 'M' ? 'movingPlatformVertical' : 
                                  type === 'W' ? 'movingPlatformHorizontal' : 'platform',
                            width: 1, 
                            height: 1,
                            startPos: { x: x, y: y + platformHeight / 2 },
                            moveTime: 0,
                            moveSpeed: 2 // Complete one cycle every 2 seconds
                        };
                        this.scene.add(platform);
                        this.platforms.push(platform);
                        const edges = new THREE.EdgesGeometry(platformGeometry);
                        const lineMaterial = new THREE.LineBasicMaterial({color: theme.platformEdge, linewidth: 2});
                        const wireframe = new THREE.LineSegments(edges, lineMaterial);
                        platform.add(wireframe);
                        break;
                    case '^':
                        // Handle all upward spikes consistently - position them at the grid cell y-coordinate
                        // The base of the spike will be at exactly y, and the top will be at y + spikeSize
                        this.createSpike(x, y, 'up');
                        break;
                    case 'V':
                        // Downward spike
                        this.createSpike(x, y, 'down');
                        break;
                    case '<':
                        // Left spike
                        this.createSpike(x - 0.5, y, 'left');
                        break;
                    case '>':
                        // Right spike
                        this.createSpike(x + 0.5, y + 0.5, 'right');
                        break;
                    case 'S':
                        this.startPosition = {x, y: y + 0.5};
                        if (this.player && !this.player.hasMovedFromStart) {
                            this.player.position.set(x, y + 0.5, 0);
                        }
                        break;
                    case 'E':
                        this.createPortal(x, y + 0.5);
                        break;
                    case 'C':
                        this.createCollectible(x, y + 0.5);
                        break;
                    case 'J':
                        const jumpPadGeometry = new THREE.BoxGeometry(1, 0.5, 1);
                        const jumpPadMaterial = new THREE.MeshBasicMaterial({
                            color: 0xFFDD00,
                            transparent: true,
                            opacity: 0.8
                        });
                        const jumpPad = new THREE.Mesh(jumpPadGeometry, jumpPadMaterial);
                        jumpPad.position.set(x, y + 0.25, 0);
                        jumpPad.userData = {type: 'jumpPad', width: 1, height: 0.5};
                        this.scene.add(jumpPad);
                        this.platforms.push(jumpPad);
                        const jumpPadEdges = new THREE.EdgesGeometry(jumpPadGeometry);
                        const jumpPadLineMaterial = new THREE.LineBasicMaterial({color: 0xFFFF00, linewidth: 2});
                        const jumpPadWireframe = new THREE.LineSegments(jumpPadEdges, jumpPadLineMaterial);
                        jumpPad.add(jumpPadWireframe);
                        const glowGeometry = new THREE.BoxGeometry(1.2, 0.7, 1.1);
                        const glowMaterial = new THREE.MeshBasicMaterial({
                            color: 0xFFFF00,
                            transparent: true,
                            opacity: 0.3,
                            side: THREE.BackSide
                        });
                        const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                        jumpPad.add(glow);
                        break;
                    case 'P':
                        this.createSpecialCollectible(x, y);
                        break;
                    case 'Q':
                        if (new URLSearchParams(window.location.search).get('portal')) {
                            this.createEnterVibeVersePortal(x, y + 0.5);
                        }
                        break;                        
                    case 'O':
                        this.createExitVibeVersePortal(x, y + 0.5);
                        break;
                    case '=':
                        const magnetGeometry = new THREE.SphereGeometry(0.3, 16, 16);
                        const magnetMaterial = new THREE.MeshBasicMaterial({
                            color: 0xFF0000,
                            transparent: true,
                            opacity: 0.9
                        });
                        const magnet = new THREE.Mesh(magnetGeometry, magnetMaterial);
                        magnet.position.set(x, y + 0.5, 0);
                        magnet.userData = {
                            type: 'magnet',
                            width: 0.6,
                            height: 0.6,
                            collected: false
                        };
                        
                        // Add glow effect
                        const magnetGlowGeometry = new THREE.SphereGeometry(0.4, 16, 16);
                        const magnetGlowMaterial = new THREE.MeshBasicMaterial({
                            color: 0xFF0000,
                            transparent: true,
                            opacity: 0.3,
                            blending: THREE.AdditiveBlending,
                            side: THREE.BackSide
                        });
                        const magnetGlow = new THREE.Mesh(magnetGlowGeometry, magnetGlowMaterial);
                        magnet.add(magnetGlow);

                        // Add pulsing animation
                        const pulseAnimation = () => {
                            if (!magnet.parent) return; // Stop if magnet is removed
                            const scale = 1 + Math.sin(performance.now() * 0.005) * 0.1;
                            magnetGlow.scale.set(scale, scale, scale);
                            requestAnimationFrame(pulseAnimation);
                        };
                        pulseAnimation();

                        // Add rotating ring effect
                        const ringGeometry = new THREE.TorusGeometry(0.5, 0.03, 8, 24);
                        const ringMaterial = new THREE.MeshBasicMaterial({
                            color: 0xFF0000,
                            transparent: true,
                            opacity: 0.4,
                            blending: THREE.AdditiveBlending
                        });
                        const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                        ring.rotation.x = Math.PI / 2;
                        magnet.add(ring);

                        // Animate ring rotation
                        const rotateRing = () => {
                            if (!magnet.parent) return;
                            ring.rotation.z += 0.02;
                            requestAnimationFrame(rotateRing);
                        };
                        rotateRing();

                        this.scene.add(magnet);
                        this.collectibles.push(magnet);
                        break;
                    case '*':
                        const starGeometry = new THREE.SphereGeometry(0.3, 16, 16);
                        const starMaterial = new THREE.MeshBasicMaterial({
                            color: 0x00FFFF,
                            transparent: true,
                            opacity: 0.8
                        });
                        const star = new THREE.Mesh(starGeometry, starMaterial);
                        star.position.set(x, y + 0.5, 0);
                        star.userData = {
                            type: 'invisibility',
                            width: 0.6,
                            height: 0.6,
                            collected: false
                        };

                        // Add sparkle effect
                        const sparkleGeometry = new THREE.SphereGeometry(0.4, 16, 16);
                        const sparkleMaterial = new THREE.MeshBasicMaterial({
                            color: 0xFFFFFF,
                            transparent: true,
                            opacity: 0.3,
                            blending: THREE.AdditiveBlending,
                            side: THREE.BackSide
                        });
                        const sparkle = new THREE.Mesh(sparkleGeometry, sparkleMaterial);
                        star.add(sparkle);

                        // Add star points
                        const points = 5;
                        const innerRadius = 0.5;
                        const outerRadius = 0.7;
                        const starPointsGeometry = new THREE.BufferGeometry();
                        const positions = [];
                        
                        for (let i = 0; i < points * 2; i++) {
                            const radius = i % 2 === 0 ? outerRadius : innerRadius;
                            const angle = (i / (points * 2)) * Math.PI * 2;
                            positions.push(
                                Math.cos(angle) * radius,
                                Math.sin(angle) * radius,
                                0
                            );
                        }
                        // Close the star shape
                        positions.push(positions[0], positions[1], positions[2]);
                        
                        starPointsGeometry.setAttribute('position', 
                            new THREE.Float32BufferAttribute(positions, 3));
                        
                        const starPointsMaterial = new THREE.LineBasicMaterial({
                            color: 0x00FFFF,
                            transparent: true,
                            opacity: 0.5,
                            blending: THREE.AdditiveBlending
                        });
                        
                        const starPoints = new THREE.Line(starPointsGeometry, starPointsMaterial);
                        star.add(starPoints);

                        // Animate star rotation and sparkle
                        const animateStar = () => {
                            if (!star.parent) return;
                            star.rotation.z += 0.01;
                            starPoints.rotation.z -= 0.005;
                            const scale = 1 + Math.sin(performance.now() * 0.003) * 0.1;
                            sparkle.scale.set(scale, scale, scale);
                            sparkle.material.opacity = 0.3 + Math.sin(performance.now() * 0.003) * 0.2;
                            requestAnimationFrame(animateStar);
                        };
                        animateStar();

                        this.scene.add(star);
                        this.collectibles.push(star);
                        break;
                    case 'U':
                        // Create the black hole core
                        const blackHoleGeometry = new THREE.CircleGeometry(0.5, 32);
                        const blackHoleMaterial = new THREE.MeshBasicMaterial({
                            color: 0x000000,
                            transparent: true,
                            opacity: 0.95,
                            side: THREE.DoubleSide
                        });
                        const blackHole = new THREE.Mesh(blackHoleGeometry, blackHoleMaterial);
                        blackHole.position.set(x, y + 0.5, 0);
                        blackHole.userData = {
                            type: 'blackHole',
                            width: 1,
                            height: 1,
                            pullRadius: 3,
                            pullForce: 15,
                            deadly: true
                        };
                        this.scene.add(blackHole);
                        this.obstacles.push(blackHole);

                        // Add danger glow effect
                        const dangerGlowGeometry = new THREE.CircleGeometry(0.6, 32);
                        const dangerGlowMaterial = new THREE.MeshBasicMaterial({
                            color: 0xff0000,
                            transparent: true,
                            opacity: 0.4,
                            blending: THREE.AdditiveBlending,
                            side: THREE.DoubleSide
                        });
                        const dangerGlow = new THREE.Mesh(dangerGlowGeometry, dangerGlowMaterial);
                        blackHole.add(dangerGlow);

                        // Add outer purple glow
                        const blackHoleGlowGeometry = new THREE.CircleGeometry(0.8, 32);
                        const blackHoleGlowMaterial = new THREE.MeshBasicMaterial({
                            color: 0x4400ff,
                            transparent: true,
                            opacity: 0.3,
                            blending: THREE.AdditiveBlending,
                            side: THREE.DoubleSide
                        });
                        const blackHoleGlow = new THREE.Mesh(blackHoleGlowGeometry, blackHoleGlowMaterial);
                        blackHole.add(blackHoleGlow);

                        // Add multiple rotating rings for vortex effect
                        const ringColors = [0xff0000, 0x6600ff, 0x4400ff];
                        const ringScales = [0.7, 0.9, 1.1];
                        const ringRotationSpeeds = [3, 2, 1.5];

                        for (let i = 0; i < ringScales.length; i++) {
                            const blackHoleRingGeometry = new THREE.RingGeometry(
                                ringScales[i] - 0.1,
                                ringScales[i],
                                32,
                                1,
                                0,
                                Math.PI * 2
                            );
                            const blackHoleRingMaterial = new THREE.MeshBasicMaterial({
                                color: ringColors[i],
                                transparent: true,
                                opacity: 0.5 - (i * 0.1),
                                side: THREE.DoubleSide,
                                blending: THREE.AdditiveBlending
                            });
                            const blackHoleRing = new THREE.Mesh(blackHoleRingGeometry, blackHoleRingMaterial);
                            blackHoleRing.userData.rotationSpeed = ringRotationSpeeds[i];
                            blackHoleRing.userData.isVortexRing = true;
                            blackHole.add(blackHoleRing);
                        }

                        // Add warning spikes around the black hole
                        const spikeCount = 8;
                        for (let i = 0; i < spikeCount; i++) {
                            const angle = (i / spikeCount) * Math.PI * 2;
                            const spikeGeometry = new THREE.BufferGeometry();
                            const vertices = new Float32Array([
                                0, 0, 0,
                                Math.cos(angle) * 0.3, Math.sin(angle) * 0.3, 0,
                                Math.cos(angle + 0.1) * 0.3, Math.sin(angle + 0.1) * 0.3, 0
                            ]);
                            spikeGeometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                            const spikeMaterial = new THREE.MeshBasicMaterial({
                                color: 0xff0000,
                                transparent: true,
                                opacity: 0.7,
                                side: THREE.DoubleSide
                            });
                            const spike = new THREE.Mesh(spikeGeometry, spikeMaterial);
                            spike.position.set(1.2 * Math.cos(angle), 1.2 * Math.sin(angle), 0);
                            blackHole.add(spike);
                        }
                        break;
                }
            }

            createSpike(x, y, direction) {
                const spikeSize = 1.0;
                const halfSize = spikeSize / 2;
                const theme = this.getTheme();
                let vertices;

                if (direction === 'up') {
                    // Upward spike - point should be at the top
                    vertices = new Float32Array([
                        -halfSize, 0, 0,
                        halfSize, 0, 0,
                        0, spikeSize, 0
                    ]);
                } else if (direction === 'down') {
                    // Downward spike - point should be at the bottom
                    vertices = new Float32Array([
                        -halfSize, 0, 0,
                        halfSize, 0, 0,
                        0, -spikeSize, 0
                    ]);
                } else if (direction === 'left') {
                    // For left spikes, position at the right edge of the cell and offset up
                    vertices = new Float32Array([
                        0, -halfSize, 0,
                        0, halfSize, 0,
                        -spikeSize, 0, 0
                    ]);
                } else if (direction === 'right') {
                    // Right spike - point should be on the right
                    vertices = new Float32Array([
                        0, -halfSize, 0,
                        0, halfSize, 0,
                        spikeSize, 0, 0
                    ]);
                }

                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                geometry.setIndex([0, 1, 2]);
                geometry.computeVertexNormals();

                const material = new THREE.MeshBasicMaterial({
                    color: theme.obstacle,
                    side: THREE.DoubleSide
                });

                const spike = new THREE.Mesh(geometry, material);
                const outlineMaterial = new THREE.LineBasicMaterial({
                    color: theme.obstacleEdge || 0xFFFFFF,
                    linewidth: 2
                });

                const outlineGeometry = new THREE.EdgesGeometry(geometry);
                const outline = new THREE.LineSegments(outlineGeometry, outlineMaterial);
                spike.add(outline);

                const glowGeometry = new THREE.BufferGeometry().copy(geometry);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: theme.obstacle,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.3,
                    blending: THREE.AdditiveBlending
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.scale.set(1.2, 1.2, 1.2);
                spike.add(glow);

                // Position the spike appropriately based on direction
                if (direction === 'up') {
                    // Position the base of the upward spike exactly at the given y coordinate
                    spike.position.set(x, y, 0);
                } else if (direction === 'down') {
                    // For downward spikes, position at the top of the cell and move up to touch platform
                    spike.position.set(x, y + halfSize + 0.5, 0);
                } else if (direction === 'left') {
                    // For left spikes, position at the right edge of the cell and offset up
                    spike.position.set(x + halfSize + 0.5, y + 0.5, 0);
                } else if (direction === 'right') {
                    // For right spikes, position at the left edge of the cell
                    spike.position.set(x - halfSize - 0.5, y, 0);
                }

                this.scene.add(spike);
                this.obstacles.push(spike);

                spike.userData = {
                    type: 'spike',
                    deadly: true,
                    direction: direction,
                    width: spikeSize,
                    height: spikeSize
                };

                return spike;
            }

            createFloor() {
                if (!this.floorTilePositions || this.floorTilePositions.length === 0) {
                    logDebug("No floor tiles found in level data");
                    return;
                }

                // Create individual floor tiles instead of one continuous floor
                const theme = this.getTheme();

                for (let xPos of this.floorTilePositions) {
                    const groundGeometry = new THREE.BoxGeometry(1, 1, 1);
                    const groundMaterial = new THREE.MeshBasicMaterial({
                        color: theme.platform,
                        transparent: true,
                        opacity: 0.6
                    });

                    const groundTile = new THREE.Mesh(groundGeometry, groundMaterial);
                    groundTile.position.set(xPos, this.groundY + 0.5, 0);
                    groundTile.userData = {
                        type: 'platform',
                        width: 1,
                        height: 1
                    };

                    this.scene.add(groundTile);
                    this.platforms.push(groundTile);

                    const groundEdges = new THREE.EdgesGeometry(groundGeometry);
                    const groundLineMaterial = new THREE.LineBasicMaterial({
                        color: theme.platformEdge,
                        linewidth: 2
                    });
                    const groundWireframe = new THREE.LineSegments(groundEdges, groundLineMaterial);
                    groundTile.add(groundWireframe);

                    // Add subtle glow effect to each tile
                    const groundGlowGeometry = new THREE.BoxGeometry(1, 0.05, 1.5);
                    const groundGlowMaterial = new THREE.MeshBasicMaterial({
                        color: theme.platformEdge,
                        transparent: true,
                        opacity: 0.15,
                        blending: THREE.AdditiveBlending
                    });
                    const groundGlow = new THREE.Mesh(groundGlowGeometry, groundGlowMaterial);
                    groundGlow.position.y = 0.3;
                    groundTile.add(groundGlow);
                }

                // We no longer store a reference to a single ground object
                this.ground = null;
            }

            handleKeyDown(event) {
                // Don't handle input if game is over
                if (this.gameOverUI.style.display === 'block') return;
                
                if (!this.isRunning || this.isPaused) return;

                if (event.code === 'Space' || event.code === 'ArrowUp' || event.code === 'KeyW') {
                    this.jump();
                }
                if (event.code === 'ArrowRight') {
                    this.playerVelocity.x = this.boostVelocity; // Use boostVelocity for speed boost
                    setTimeout(() => {
                        if (this.isRunning) this.playerVelocity.x = this.baseVelocity; // Reset to baseVelocity
                    }, 500);
                }
                if (event.code === 'KeyP' || event.code === 'Escape') {
                    this.togglePause();
                }
                if (event.code === 'KeyM') {
                    // Toggle mute state
                    this.isMuted = !this.isMuted;
                    
                    // Update background music volume
                    if (this.backgroundMusic) {
                        this.backgroundMusic.volume = this.isMuted ? 0 : 0.3;
                    }
                    
                    // Update all sound effects volume
                    Object.values(this.sounds).forEach(sound => {
                        sound.volume = this.isMuted ? 0 : 0.5;
                    });
                    
                    logDebug("Audio " + (this.isMuted ? "muted" : "unmuted"));
                }
            }

            handleResize() {
                const width = window.innerWidth;
                const height = window.innerHeight;
                this.renderer.setSize(width, height);
                const aspectRatio = width / height;
                const cameraHeight = 20;
                const cameraWidth = cameraHeight * aspectRatio;
                this.camera.left = -cameraWidth / 2;
                this.camera.right = cameraWidth / 2;
                this.camera.top = cameraHeight / 2;
                this.camera.bottom = -cameraHeight / 2;
                this.camera.updateProjectionMatrix();
            }

            togglePause() {
                this.isPaused = !this.isPaused;

                // Pause or resume background music based on game state
                if (this.isPaused) {
                    this.pauseBackgroundMusic();
                } else {
                    this.playBackgroundMusic();
                }

                logDebug("Game " + (this.isPaused ? "paused" : "resumed"));
            }

            restart() {
                // Reset the game state
                this.score = 0;
                this.levelDeathCount = 0;
                this.currentLevel = 1;
                this.levelManager.currentLevel = 1;
                
                // Hide game over UI
                this.gameOverUI.style.display = 'none';
                
                // Generate a new level since it's a fresh start
                this.createLevel();
                
                // Reset the player
                this.resetPlayerInLevel();
                
                // Update UI
                this.scoreDisplay.textContent = `SCORE: ${Math.floor(this.score)}`;
                this.levelDisplay.textContent = `LEVEL ${this.currentLevel}`;
                
                // Restart the game
                this.isRunning = true;
                this.isPaused = false;
                
                // Restart background music
                this.playBackgroundMusic();
            }

            animate() {
                requestAnimationFrame(this.animate.bind(this));
                if (!this.isRunning || this.isPaused) return;
                const now = performance.now();
                const deltaTime = (now - this.lastTime) / 1000;
                this.lastTime = now;
                const limitedDelta = Math.min(deltaTime, 0.1);
                this.update(limitedDelta);
                this.renderer.render(this.scene, this.camera);
            }

            update(deltaTime) {
                // Don't update anything if game is over
                if (this.gameOverUI.style.display === 'block') {
                    this.renderer.render(this.scene, this.camera);
                    return;
                }

                // Don't update if game is not running
                if (!this.isRunning) {
                    this.renderer.render(this.scene, this.camera);
                    return;
                }

                // Update portal effects
                this.obstacles.forEach(obstacle => {
                    if (obstacle.userData.type === 'exitPortal') {
                        // Update animation time
                        obstacle.userData.animationData.time += deltaTime;
                        const time = obstacle.userData.animationData.time;

                        // Animate spikes
                        obstacle.children.forEach(child => {
                            if (child.geometry instanceof THREE.BufferGeometry && 
                                child.geometry.attributes.position.count === 3) {
                                const scale = 1 + Math.sin(time * child.userData.pulseSpeed) * 0.2;
                                child.scale.set(scale, scale, 1);
                            }
                        });

                        // Rotate the glow ring
                        obstacle.children.forEach(child => {
                            if (child.geometry instanceof THREE.RingGeometry) {
                                child.rotation.z += deltaTime * 2;
                            }
                        });

                        // Pulse the outer glow
                        const outerGlow = obstacle.children.find(child => 
                            child.geometry instanceof THREE.CircleGeometry);
                        if (outerGlow) {
                            const pulseScale = 1 + Math.sin(time * 3) * 0.1;
                            outerGlow.scale.set(pulseScale, pulseScale, 1);
                        }
                    }
                });

                // Update black holes
                this.obstacles.forEach(obstacle => {
                    if (obstacle.userData.type === 'blackHole') {
                        // Rotate the vortex rings with different speeds and pulsing
                        obstacle.children.forEach(child => {
                            if (child.userData.isVortexRing) {
                                child.rotation.z += child.userData.rotationSpeed * deltaTime;
                                
                                // Add pulsing effect to the rings
                                const pulseSpeed = 2;
                                const pulseAmount = 0.2;
                                child.scale.x = child.scale.y = 1 + Math.sin(this.lastTime * pulseSpeed * 0.001) * pulseAmount;
                            }
                        });

                        // Pulse the danger glow
                        const dangerGlow = obstacle.children[0];
                        if (dangerGlow) {
                            dangerGlow.material.opacity = 0.4 + Math.sin(this.lastTime * 0.005) * 0.2;
                        }

                        // Check if player is within pull radius
                        const dx = obstacle.position.x - this.player.position.x;
                        const dy = obstacle.position.y - this.player.position.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < obstacle.userData.pullRadius) {
                            // Calculate pull force based on distance
                            const pullStrength = (1 - distance / obstacle.userData.pullRadius) * obstacle.userData.pullForce;
                            
                            // Apply gravitational pull
                            const angle = Math.atan2(dy, dx);
                            this.playerVelocity.x += Math.cos(angle) * pullStrength * deltaTime;
                            this.playerVelocity.y += Math.sin(angle) * pullStrength * deltaTime;

                            // If too close, trigger explosion and death
                            if (distance < 0.8) {
                                this.createBlackHoleExplosion(this.player.position.x, this.player.position.y);
                                this.resetPlayerInLevel();
                                return;
                            }
                        }
                    }
                });

                // Update moving platforms
                this.platforms.forEach(platform => {
                    if (platform.userData.type === 'movingPlatformVertical' || 
                        platform.userData.type === 'movingPlatformHorizontal') {
                        
                        platform.userData.moveTime += deltaTime;
                        const t = (platform.userData.moveTime * Math.PI) / platform.userData.moveSpeed;
                        const offset = Math.sin(t);
                        
                        if (platform.userData.type === 'movingPlatformVertical') {
                            platform.position.y = platform.userData.startPos.y + offset;
                        } else {
                            platform.position.x = platform.userData.startPos.x + offset;
                        }
                    }
                });

                this.playerVelocity.y -= this.gravity * deltaTime;
                this.playerVelocity.y = Math.max(this.playerVelocity.y, -30);
                if (this.playerVelocity.x < this.baseVelocity) {
                    this.playerVelocity.x = this.baseVelocity;
                }
                this.player.position.x += this.playerVelocity.x * deltaTime;
                this.player.position.y += this.playerVelocity.y * deltaTime;

                // Only update score if game is not over
                if (!this.gameOverUI.style.display || this.gameOverUI.style.display === 'none') {
                    this.score += deltaTime * 10; // Score based on time
                    this.updateScoreDisplay();
                }

                // Handle player rotation during jumps
                if (this.isJumping) {
                    // Calculate rotation speed based on jump height/velocity
                    // Complete 180 degrees over the course of the jump
                    const rotationSpeed = Math.PI * deltaTime;
                    this.player.rotation.z -= rotationSpeed; // Negative for clockwise rotation

                    // Limit to -180 degrees (-PI radians) for clockwise rotation
                    if (this.player.rotation.z < -Math.PI) {
                        this.player.rotation.z = -Math.PI;
                    }
                }

                if (this.jumpParticles.length > 0) {
                    for (let i = this.jumpParticles.length - 1; i >= 0; i--) {
                        const particle = this.jumpParticles[i];
                        particle.position.x += particle.userData.velocityX * deltaTime;
                        particle.position.y += particle.userData.velocityY * deltaTime;
                        particle.userData.velocityY -= 15 * deltaTime;
                        particle.userData.life -= deltaTime * 1.5;
                        particle.material.opacity = particle.userData.life * 0.7;
                        if (particle.userData.life <= 0) {
                            this.scene.remove(particle);
                            this.jumpParticles.splice(i, 1);
                        }
                    }
                }
                if (this.isJumping && this.jumpHistoryPoints.length > 0) {
                    this.updateJumpPath();
                }
                if (!this.isJumping && this.jumpPath) {
                    this.scene.remove(this.jumpPath);
                    this.jumpPath = null;
                    this.jumpHistoryPoints = [];
                }

                // For grid reference, bottom of the world
                const absoluteBottom = this.groundY - 5;

                // Check if player has fallen off the platforms entirely
                if (this.player.position.y < absoluteBottom) {
                    logDebug("Player fell off platforms - resetting to level start");
                    this.resetPlayerInLevel();
                    return;
                }

                // Other behavior continues as before - platform collisions will handle
                // both the individual floor tiles and other platforms
                this.checkCollisions();
                this.updatePortal(deltaTime);
                this.camera.position.x = this.player.position.x;
                if (this.playerGlow) {
                    const scaleFactor = 1 + Math.sin(performance.now() * 0.005) * 0.1;
                    this.playerGlow.scale.set(scaleFactor, scaleFactor, scaleFactor);
                }

                // Only reset the main mesh rotation to make sure it stays upright
                // Don't reset the player group rotation, which will animate during jumps
                if (this.playerMainMesh) {
                    this.playerMainMesh.rotation.z = 0;
                }

                this.platforms.forEach(platform => {
                    if (platform.userData.type === 'jumpPad' && platform.userData.glowMesh) {
                        const glow = platform.userData.glowMesh;
                        glow.scale.set(
                            1 + Math.sin(performance.now() * 0.01) * 0.2,
                            1 + Math.sin(performance.now() * 0.01) * 0.2,
                            1
                        );
                        glow.material.opacity = 0.3 + Math.sin(performance.now() * 0.01) * 0.2;
                    }
                });
            }

            checkCollisions() {
                // Reset ground state at the beginning of collision checks
                let wasOnSurface = this.onGround || this.onPlatform;
                this.onGround = false;
                this.onPlatform = false;

                // Collision results tracking (to avoid multiple snap positions in a single frame)
                let collisionResolved = false;

                // Check platform collisions first - including floor tiles
                for (let i = 0; i < this.platforms.length; i++) {
                    const platform = this.platforms[i];
                    if (!platform || !platform.userData) continue;

                    const playerBottom = this.player.position.y - this.playerSize / 2;
                    const playerTop = this.player.position.y + this.playerSize / 2;
                    const playerLeft = this.player.position.x - this.playerSize / 2;
                    const playerRight = this.player.position.x + this.playerSize / 2;

                    const platformWidth = platform.userData.width || 1;
                    const platformHeight = platform.userData.height || 1;
                    const platformTop = platform.position.y + platformHeight / 2;
                    const platformBottom = platform.position.y - platformHeight / 2;
                    const platformLeft = platform.position.x - platformWidth / 2;
                    const platformRight = platform.position.x + platformWidth / 2;

                    // First check if the player overlaps with the platform horizontally
                    if (playerRight > platformLeft && playerLeft < platformRight) {

                        // Landing on top of a platform (more generous detection)
                        // Check if player's bottom is at or slightly above the platform's top
                        // AND player is moving downward or was already standing
                        if (!collisionResolved &&
                            (this.playerVelocity.y <= 0 || wasOnSurface) &&
                            playerBottom >= platformTop - 0.3 &&
                            playerBottom <= platformTop + 0.3) {

                            // Snap player to the top of the platform with a small offset
                            this.player.position.y = platformTop + this.playerSize / 2 + 0.01;
                            this.playerVelocity.y = 0;
                            this.isJumping = false;

                            // Reset player rotation when landing
                            this.player.rotation.z = 0;

                            collisionResolved = true;

                            // Handle whether it's a floor tile or other platform
                            if (platformBottom <= this.groundY + 0.1) {
                                this.onGround = true;
                            } else {
                                this.onPlatform = true;
                            }

                            if (this.jumpPath) {
                                this.scene.remove(this.jumpPath);
                                this.jumpPath = null;
                                this.jumpHistoryPoints = [];
                            }

                            if (platform.userData.type === 'jumpPad') {
                                this.playerVelocity.y = this.jumpForce * 1.5;
                                this.isJumping = true;
                                this.onPlatform = false;
                                this.onGround = false;
                                this.createJumpParticles();
                            }
                        }
                        // Hitting the bottom of a platform while moving upward
                        else if (!collisionResolved &&
                            this.playerVelocity.y > 0 &&
                            playerTop <= platformBottom + 0.3 &&
                            playerTop >= platformBottom - 0.3) {

                            this.player.position.y = platformBottom - this.playerSize / 2 - 0.01;
                            this.playerVelocity.y = 0;
                            collisionResolved = true;
                        }
                        // Check for side collisions if we're not landing or hitting top/bottom
                        else if (!collisionResolved &&
                            playerBottom < platformTop - 0.3 &&
                            playerTop > platformBottom + 0.3) {
                            // Coming from the left
                            if (playerRight > platformLeft && playerRight < platformLeft + 0.3) {
                                this.player.position.x = platformLeft - this.playerSize / 2 - 0.01;
                                collisionResolved = true;

                                // Reset rotation on side collision too
                                if (this.isJumping) {
                                    this.player.rotation.z = 0;
                                    this.isJumping = false;
                                }
                            }
                            // Coming from the right
                            else if (playerLeft < platformRight && playerLeft > platformRight - 0.3) {
                                this.player.position.x = platformRight + this.playerSize / 2 + 0.01;
                                collisionResolved = true;

                                // Reset rotation on side collision too
                                if (this.isJumping) {
                                    this.player.rotation.z = 0;
                                    this.isJumping = false;
                                }
                            }
                        }
                    }
                }

                // Check spike collisions
                this.checkSpikeCollisions();

                // Check collectible collisions
                this.checkCollectibleCollisions();
                
                // Check other obstacle collisions (like exit portal)
                this.checkGenericObstacleCollisions();
            }

            checkGenericObstacleCollisions() {
                // Check collisions with other types of obstacles (like exit portal)
                for (let i = 0; i < this.obstacles.length; i++) {
                    const obstacle = this.obstacles[i];
                    if (!obstacle || !obstacle.userData) continue;
                    
                    // Skip spikes as they're handled separately
                    if (obstacle.userData.type === 'spike') continue;
                    
                    const playerLeft = this.player.position.x - this.playerSize / 2;
                    const playerRight = this.player.position.x + this.playerSize / 2;
                    const playerBottom = this.player.position.y - this.playerSize / 2;
                    const playerTop = this.player.position.y + this.playerSize / 2;
                    
                    const obstacleWidth = obstacle.userData.width || 1;
                    const obstacleHeight = obstacle.userData.height || 1;
                    const obstacleLeft = obstacle.position.x - obstacleWidth / 2;
                    const obstacleRight = obstacle.position.x + obstacleWidth / 2;
                    const obstacleBottom = obstacle.position.y - obstacleHeight / 2;
                    const obstacleTop = obstacle.position.y + obstacleHeight / 2;
                    
                    // Check for collision
                    if (playerRight > obstacleLeft && playerLeft < obstacleRight &&
                        playerBottom < obstacleTop && playerTop > obstacleBottom) {
                        
                        // If there's an onCollision handler, call it
                        if (typeof obstacle.userData.onCollision === 'function') {
                            obstacle.userData.onCollision();
                        }
                    }
                }
            }
            
            createExitVibeVersePortal(x, y) {
                this.createTeleportPortal(x, y, 'VIBEVERSE PORTAL', 0x00ff00, () => {
                    logDebug("Player Exited VibeVerse!");                    
                    this.animatePlayerEnteringPortal(x, y, () => {
                        exitPortalRedirection();
                    });                  
                });
            }

            createEnterVibeVersePortal(x, y) {
                this.createTeleportPortal(x, y, 'METAVERSE PORTAL', 0xff0000, () => {                   
                    this.animatePlayerEnteringPortal(x, y, () => {
                        startPortalRedirection();
                    });                 
                });
            }
            
            createTeleportPortal(x, y, label, portalColor, onCollision) {
                // Create the portal with a vibrant glow effect based on the provided color
                const portalRadius = 0.7;
                const theme = this.getTheme();

                // Main portal circle - dark center
                const portalGeometry = new THREE.CircleGeometry(portalRadius, 32);
                const portalMaterial = new THREE.MeshBasicMaterial({
                    color: 0x000000,
                    transparent: true,
                    opacity: 0.9,
                    side: THREE.DoubleSide
                });
                const exitPortal = new THREE.Mesh(portalGeometry, portalMaterial);
                exitPortal.position.set(x, y + 0.5, 0);
                exitPortal.userData = {
                    type: 'exitPortal',
                    width: portalRadius * 2,
                    height: portalRadius * 2,
                    onCollision: onCollision || (() => {
                        logDebug("Player Collision with Portal!");
                    })
                };

                // Add intense glow ring with the specified color
                const glowRingGeometry = new THREE.RingGeometry(portalRadius * 0.9, portalRadius * 1.1, 32);
                const glowRingMaterial = new THREE.MeshBasicMaterial({
                    color: portalColor,
                    transparent: true,
                    opacity: 0.8,
                    side: THREE.DoubleSide,
                    blending: THREE.AdditiveBlending
                });
                const glowRing = new THREE.Mesh(glowRingGeometry, glowRingMaterial);
                glowRing.position.z = 0.01;
                exitPortal.add(glowRing);

                // Add outer glow layers with the specified color
                const outerGlowGeometry = new THREE.CircleGeometry(portalRadius * 1.3, 32);
                const outerGlowMaterial = new THREE.MeshBasicMaterial({
                    color: portalColor,
                    transparent: true,
                    opacity: 0.3,
                    blending: THREE.AdditiveBlending,
                    side: THREE.DoubleSide
                });
                const outerGlow = new THREE.Mesh(outerGlowGeometry, outerGlowMaterial);
                exitPortal.add(outerGlow);

                // Add spiky effect around the portal with the specified color
                const spikeCount = 16;
                for (let i = 0; i < spikeCount; i++) {
                    const angle = (i / spikeCount) * Math.PI * 2;
                    const spikeLength = 0.2 + Math.random() * 0.2;
                    const spikeGeometry = new THREE.BufferGeometry();
                    const vertices = new Float32Array([
                        0, 0, 0,
                        Math.cos(angle) * spikeLength, Math.sin(angle) * spikeLength, 0,
                        Math.cos(angle + 0.1) * spikeLength, Math.sin(angle + 0.1) * spikeLength, 0
                    ]);
                    spikeGeometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                    const spikeMaterial = new THREE.MeshBasicMaterial({
                        color: portalColor,
                        transparent: true,
                        opacity: 0.5,
                        side: THREE.DoubleSide,
                        blending: THREE.AdditiveBlending
                    });
                    const spike = new THREE.Mesh(spikeGeometry, spikeMaterial);
                    spike.position.set(
                        Math.cos(angle) * portalRadius,
                        Math.sin(angle) * portalRadius,
                        0.02
                    );
                    spike.userData = {
                        initialScale: 1,
                        pulseSpeed: 2 + Math.random()
                    };
                    exitPortal.add(spike);
                }

                // Add the label with neon effect matching the portal color
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 1024;
                canvas.height = 256;
                
                context.fillStyle = 'rgba(0, 0, 0, 0)';
                context.fillRect(0, 0, canvas.width, canvas.height);
                
                // Create clearer text with moderate glow
                context.fillStyle = '#ffffff'; // White base for better visibility
                context.font = 'bold 72px "Arial", sans-serif';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                
                // Convert portal color to CSS color string for canvas
                const colorHex = '#' + portalColor.toString(16).padStart(6, '0');
                
                // Add glow layers with the specified color
                context.shadowColor = colorHex;
                context.shadowBlur = 15;
                context.fillText(label, canvas.width / 2, canvas.height / 2); // Base text
                
                // Add a moderate outer glow
                context.shadowBlur = 8;
                context.fillStyle = colorHex;
                context.fillText(label, canvas.width / 2, canvas.height / 2);
                
                // Add final sharp text on top
                context.shadowBlur = 0;
                context.fillStyle = '#ffffff';
                context.fillText(label, canvas.width / 2, canvas.height / 2);
                
                const texture = new THREE.CanvasTexture(canvas);
                const labelMaterial = new THREE.MeshBasicMaterial({
                    map: texture,
                    transparent: true,
                    side: THREE.DoubleSide,
                    blending: THREE.AdditiveBlending
                });
                
                const labelGeometry = new THREE.PlaneGeometry(2.5, 0.6);
                const labelMesh = new THREE.Mesh(labelGeometry, labelMaterial);
                labelMesh.position.set(0, portalRadius * 1.8, 0.05);
                exitPortal.add(labelMesh);

                // Add animation data
                exitPortal.userData.animationData = {
                    time: 0,
                    pulseSpeed: 2
                };

                this.scene.add(exitPortal);
                this.obstacles.push(exitPortal);
            }

            checkSpikeCollisions() {
                // Skip collision check if player is invincible
                if (this.isInvincible) return;

                // Check spike collisions first.
                for (let i = 0; i < this.obstacles.length; i++) {
                    const obstacle = this.obstacles[i];
                    if (!obstacle || !obstacle.userData) continue;
                    if (obstacle.userData.type !== 'spike') continue;

                    const playerLeft = this.player.position.x - this.playerSize / 2;
                    const playerRight = this.player.position.x + this.playerSize / 2;
                    const playerBottom = this.player.position.y - this.playerSize / 2;
                    const playerTop = this.player.position.y + this.playerSize / 2;
                    const spikeSize = obstacle.userData.width || 1;
                    const spikeLeft = obstacle.position.x - spikeSize / 2;
                    const spikeRight = obstacle.position.x + spikeSize / 2;

                    let spikeBottom, spikeTop;
                    if (obstacle.userData.direction === 'up') {
                        // For upward spikes, the bottom is at the position and top is above
                        spikeBottom = obstacle.position.y;
                        spikeTop = obstacle.position.y + spikeSize;
                    } else {
                        // For downward spikes, the top is at the position and bottom is below
                        // Adjust for the new positioning
                        spikeBottom = obstacle.position.y - spikeSize;
                        spikeTop = obstacle.position.y;
                    }

                    // Use a more precise collision for triangular spikes
                    const spikeMiddleX = obstacle.position.x;
                    const spikeMiddleY = obstacle.userData.direction === 'up'
                        ? obstacle.position.y + spikeSize / 2
                        : obstacle.position.y - spikeSize / 2;

                    // Simple AABB collision detection first
                    if (playerRight > spikeLeft && playerLeft < spikeRight &&
                        playerBottom < spikeTop && playerTop > spikeBottom) {

                        // Refine collision with spike shape consideration
                        if (obstacle.userData.direction === 'up') {
                            // For upward spikes, player needs to be closer to the tip the higher they are
                            const relativeX = Math.abs(this.player.position.x - spikeMiddleX);
                            const relativeY = this.player.position.y - obstacle.position.y;
                            const collisionSlope = spikeSize / 2; // Half width at the spike's height

                            if (relativeX < (spikeSize / 2) * (1 - relativeY / spikeSize) + 0.2) {
                                logDebug("SPIKE COLLISION DETECTED! Resetting player...");
                                this.resetPlayerInLevel();
                                return;
                            }
                        } else {
                            // For downward spikes, player needs to be closer to the tip the lower they are
                            // Make collision area larger to match visual appearance
                            const relativeX = Math.abs(this.player.position.x - spikeMiddleX);
                            const relativeY = obstacle.position.y - this.player.position.y;
                            const collisionSlope = spikeSize / 2;

                            // Increase the collision area by reducing the slope factor and adding a buffer
                            if (relativeX < (spikeSize / 2) * (1 - relativeY / spikeSize) + 0.3) {
                                logDebug("DOWNWARD SPIKE COLLISION DETECTED! Resetting player...");
                                this.resetPlayerInLevel();
                                return;
                            }
                        }
                    }
                }
            }

            checkCollectibleCollisions() {
                // Check collectible collisions.
                for (let i = this.collectibles.length - 1; i >= 0; i--) {
                    const collectible = this.collectibles[i];
                    if (!collectible || collectible.userData.collected) continue;

                    const playerLeft = this.player.position.x - this.playerSize / 2;
                    const playerRight = this.player.position.x + this.playerSize / 2;
                    const playerBottom = this.player.position.y - this.playerSize / 2;
                    const playerTop = this.player.position.y + this.playerSize / 2;
                    const collectibleWidth = collectible.userData.width || 1;
                    const collectibleHeight = collectible.userData.height || 1;
                    const collectibleLeft = collectible.position.x - collectibleWidth / 2;
                    const collectibleRight = collectible.position.x + collectibleWidth / 2;
                    const collectibleBottom = collectible.position.y - collectibleHeight / 2;
                    const collectibleTop = collectible.position.y + collectibleHeight / 2;

                    // If magnet is active, move coins towards the player
                    if (this.hasMagnet && collectible.userData.type === 'coin') {
                        const distanceX = this.player.position.x - collectible.position.x;
                        const distanceY = this.player.position.y - collectible.position.y;
                        const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);
                        
                        if (distance < this.magnetRange) {
                            const directionX = distanceX / distance;
                            const directionY = distanceY / distance;
                            
                            collectible.position.x += directionX * this.magnetAttractionSpeed * 0.016; // Assuming 60fps
                            collectible.position.y += directionY * this.magnetAttractionSpeed * 0.016;
                            
                            // Update glow effect based on distance
                            if (collectible.children.length > 0) {
                                const glow = collectible.children[0];
                                const glowIntensity = 1 - (distance / this.magnetRange);
                                glow.material.opacity = 0.4 + glowIntensity * 0.4;
                                const glowScale = 1 + glowIntensity * 0.5;
                                glow.scale.set(glowScale, glowScale, glowScale);
                            }
                        }
                    }

                    if (playerRight > collectibleLeft && playerLeft < collectibleRight &&
                        playerBottom < collectibleTop && playerTop > collectibleBottom) {
                        
                        collectible.userData.collected = true;
                        this.scene.remove(collectible);
                        
                        if (collectible.userData.type === 'magnet') {
                            // Activate magnet powerup
                            this.activateMagnet();
                            // No score for magnet pickup
                        } else if (collectible.userData.type === 'invisibility') {
                            // Activate invisibility powerup
                            this.activateInvisibility();
                            // No score for invisibility pickup
                        } else {
                            // Regular coin collection
                            const coinValue = collectible.userData.value || 100;
                            this.score += coinValue;
                            this.updateScoreDisplay();
                            this.playSound('coin');
                        }
                    }
                }
            }

            activateMagnet() {
                this.hasMagnet = true;
                
                // Create visual effect to show magnet is active
                const magnetEffect = new THREE.Group();
                magnetEffect.name = 'magnetEffect';
                
                // Create magnetic field visualization
                const fieldGeometry = new THREE.RingGeometry(1, this.magnetRange, 32);
                const fieldMaterial = new THREE.MeshBasicMaterial({
                    color: 0xFF0000,
                    transparent: true,
                    opacity: 0.2,
                    side: THREE.DoubleSide,
                    blending: THREE.AdditiveBlending
                });
                const field = new THREE.Mesh(fieldGeometry, fieldMaterial);
                field.rotation.x = Math.PI / 2;
                magnetEffect.add(field);
                
                // Add pulsing animation
                const pulseAnimation = () => {
                    if (!this.hasMagnet) {
                        this.scene.remove(magnetEffect);
                        return;
                    }
                    const scale = 1 + Math.sin(performance.now() * 0.005) * 0.1;
                    field.material.opacity = 0.2 + Math.sin(performance.now() * 0.005) * 0.1;
                    requestAnimationFrame(pulseAnimation);
                };
                
                // Add the effect to the player
                this.player.add(magnetEffect);
                pulseAnimation();
                
                // Clear existing timer if any
                if (this.magnetTimer) {
                    clearTimeout(this.magnetTimer);
                }
                
                // Set timer to deactivate magnet
                this.magnetTimer = setTimeout(() => {
                    this.hasMagnet = false;
                    this.magnetTimer = null;
                    this.player.remove(magnetEffect);
                }, this.magnetDuration);
                
                // Play magnet activation sound
                const magnetSound = new Audio();
                magnetSound.src = 'assets/coin.wav'; // Reuse coin sound for now
                magnetSound.volume = 0.5;
                magnetSound.play().catch(error => {
                    logDebug("Error playing magnet sound: " + error.message);
                });
            }

            updateScoreDisplay() {
                if (!this.gameOverUI.style.display || this.gameOverUI.style.display === 'none') {
                    this.scoreDisplay.textContent = `SCORE: ${Math.floor(this.score)}`;
                }
            }

            updateLevelDisplay() {
                const levelDisplay = document.getElementById('level-display');
                if (levelDisplay) {
                    levelDisplay.textContent = `LEVEL ${this.levelManager.currentLevel}`;
                    levelDisplay.style.animation = 'none';
                    void levelDisplay.offsetWidth; // Trigger reflow
                    levelDisplay.style.animation = 'uiGlow 2s infinite alternate, levelUpdate 0.5s';
                }
                this.updateUITheme();
            }

            updateUITheme() {
                const theme = this.getTheme();
                const themeColor = '#' + theme.platformEdge.toString(16).padStart(6, '0');
                const scoreDisplay = document.getElementById('score-display');
                if (scoreDisplay) {
                    scoreDisplay.style.borderColor = themeColor;
                    scoreDisplay.style.boxShadow = `0 0 10px ${themeColor}, inset 0 0 5px ${themeColor}`;
                    scoreDisplay.style.textShadow = `0 0 5px ${themeColor}`;
                }
                const levelDisplay = document.getElementById('level-display');
                if (levelDisplay) {
                    levelDisplay.style.borderColor = themeColor;
                    levelDisplay.style.boxShadow = `0 0 10px ${themeColor}, inset 0 0 5px ${themeColor}`;
                    levelDisplay.style.textShadow = `0 0 5px ${themeColor}`;
                    levelDisplay.style.color = themeColor;
                }
                const pauseBtn = document.getElementById('pause-btn');
                if (pauseBtn) {
                    pauseBtn.style.borderColor = themeColor;
                    pauseBtn.style.boxShadow = `0 0 10px ${themeColor}, inset 0 0 5px ${themeColor}`;
                    const pauseBars = pauseBtn.querySelectorAll('div');
                    pauseBars.forEach(bar => {
                        bar.style.backgroundColor = themeColor;
                        bar.style.boxShadow = `0 0 5px ${themeColor}`;
                    });
                }
                document.documentElement.style.setProperty('--theme-color', themeColor);
            }

            updatePlayerTheme() {
                if (!this.player) return;

                // Get the current theme
                const theme = this.getTheme();

                // Update main player mesh color
                if (this.playerMainMesh) {
                    this.playerMainMesh.material.color.set(theme.player);
                }

                // Update inner box color (40% brighter)
                this.player.children.forEach(child => {
                    if (child.geometry &&
                        child.geometry.type === 'BoxGeometry' &&
                        child.geometry.parameters.width === this.playerSize * 0.6) {
                        const innerColor = new THREE.Color(theme.player);
                        innerColor.multiplyScalar(1.4); // Make it 40% brighter
                        child.material.color.set(innerColor);
                    }
                });

                // Update player wireframe color
                if (this.playerWireframe) {
                    this.playerWireframe.material.color.set(theme.player);
                }

                // Update player glow color
                if (this.playerGlow) {
                    this.playerGlow.material.color.set(theme.player);
                }

                // Update jump path color if it exists
                if (this.jumpPath && this.jumpPath.material) {
                    this.jumpPath.material.color.set(theme.player);
                }

                // Update jump particles
                if (this.jumpParticles && this.jumpParticles.length > 0) {
                    this.jumpParticles.forEach(particle => {
                        if (particle.material) {
                            particle.material.color.set(theme.player);
                        }
                    });
                }

                // Log the change
                logDebug("Updated player colors to match theme");
            }

            gameOver() {
                // Instead of ending the game, reset the player in the current level
                this.resetPlayerInLevel();
                const currentScore = Math.floor(this.score);
                const highScore = updateHighScore(currentScore);
                
                this.finalScore.textContent = `SCORE: ${currentScore}`;
                this.highScore.textContent = `HIGH SCORE: ${highScore}`;
                
                this.gameOverUI.style.display = 'block';
                // Pause background music on game over
                this.pauseBackgroundMusic();
            }

            realGameOver() {
                const currentScore = Math.floor(this.score);
                const highScore = updateHighScore(currentScore);
                
                this.finalScore.textContent = `SCORE: ${currentScore}`;
                this.highScore.textContent = `HIGH SCORE: ${highScore}`;
                
                this.gameOverUI.style.display = 'block';
                this.pauseBackgroundMusic();

                // Stop the game completely
                this.isRunning = false;
                this.isPaused = true;

                // Reset game state but don't create new level yet
                this.score = 0;
                this.levelDeathCount = 0;
                this.currentLevel = 1;
                this.levelManager.currentLevel = 1;
                
                // Update UI
                this.scoreDisplay.textContent = `SCORE: ${Math.floor(this.score)}`;
                this.levelDisplay.textContent = `LEVEL ${this.currentLevel}`;
            }

            resetPlayerInLevel() {
                logDebug("Player died - resetting to level start");

                // Track death count
                if (!this.levelDeathCount) this.levelDeathCount = 0;
                this.levelDeathCount++;

                // After 5 deaths on the same level, trigger real game over
                if (this.levelDeathCount >= 5) {
                    logDebug(`Too many deaths (${this.levelDeathCount}) - Game Over`);
                    this.createDeathEffect(this.player.position.x, this.player.position.y);
                    this.realGameOver();
                    return;
                }

                // Clean up visual effects
                this.cleanupVisualEffects();

                // Create a death effect at the player's current position
                const playerX = this.player.position.x;
                const playerY = this.player.position.y;
                this.createDeathEffect(playerX, playerY);

                // Reset player velocity and rotation
                this.playerVelocity.x = this.baseVelocity;
                this.playerVelocity.y = 0;
                this.isJumping = false;
                this.player.rotation.z = 0;

                // Position player at the beginning of the level
                if (!this.startPosition) {
                    // Position at the far left of the level
                    this.player.position.set(-39, this.groundY + 1.0 + this.playerSize / 2, 0);
                } else {
                    // Use the start position from the level
                    this.player.position.set(this.startPosition.x, this.startPosition.y + this.playerSize / 2, 0);
                }

                // Force ground state for immediate collision recognition
                this.onGround = true;
            }

            showInvincibilityEffect() {
                // Make player temporarily invincible with a visual effect
                this.isInvincible = true;

                // Flash player to indicate invincibility
                const flashInterval = setInterval(() => {
                    if (!this.isRunning) {
                        clearInterval(flashInterval);
                        return;
                    }

                    // Toggle visibility of player meshes
                    this.player.children.forEach(child => {
                        if (child.isMesh) {
                            if (child.material.opacity > 0.5) {
                                child.material.opacity = 0.3;
                            } else {
                                child.material.opacity = 0.9;
                            }
                        }
                    });
                }, 100);

                // End invincibility after 1.5 seconds
                setTimeout(() => {
                    if (!this.isRunning) return;

                    clearInterval(flashInterval);
                    this.isInvincible = false;

                    // Reset player opacity and colors
                    const theme = this.getTheme();
                    this.player.children.forEach(child => {
                        if (child.isMesh) {
                            // Reset opacity for all meshes
                            child.material.opacity = 0.9;

                            // Reset main mesh color
                            if (child === this.playerMainMesh) {
                                child.material.color.set(theme.player);
                            }
                            // Reset inner box color (40% brighter)
                            else if (child.geometry &&
                                child.geometry.type === 'BoxGeometry' &&
                                child.geometry.parameters.width === this.playerSize * 0.6) {
                                const innerColor = new THREE.Color(theme.player);
                                innerColor.multiplyScalar(1.4);
                                child.material.color.set(innerColor);
                            }
                            // Reset glow color
                            else if (child.geometry &&
                                child.geometry.type === 'BoxGeometry' &&
                                child.geometry.parameters.width === this.playerSize * 1.3) {
                                child.material.color.set(theme.player);
                            }
                        }
                    });

                    // Reset wireframe color
                    if (this.playerWireframe) {
                        this.playerWireframe.material.color.set(theme.player);
                    }
                }, 1500);
            }

            createPortal(x, y) {
                if (this.portal) {
                    this.scene.remove(this.portal);
                    this.portal = null;
                }
                const theme = this.getTheme();
                const portalColor = theme.portal;
                this.portal = new THREE.Group();
                this.portal.position.set(x, y, 0);
                this.portalPosition = {x, y};

                // Create an elliptical base for the portal.
                const portalRadius = 1.2;
                const portalDiscGeometry = new THREE.CircleGeometry(portalRadius, 32);
                const portalDiscMaterial = new THREE.MeshBasicMaterial({
                    color: 0x000022,
                    transparent: true,
                    opacity: 0.85,
                    side: THREE.DoubleSide
                });
                const portalDisc = new THREE.Mesh(portalDiscGeometry, portalDiscMaterial);
                portalDisc.rotation.x = Math.PI / 2;
                portalDisc.scale.set(1, 1.2, 1);
                this.portal.add(portalDisc);

                // Create the main ring.
                const ringWidth = 0.15;
                const segments = 16;
                const ringGeometry = new THREE.RingGeometry(portalRadius - ringWidth, portalRadius, segments);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: portalColor,
                    transparent: true,
                    opacity: 0.9,
                    side: THREE.DoubleSide
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = Math.PI / 2;
                ring.scale.set(1, 1.2, 1);
                this.portal.add(ring);

                // Add segments around the ring.
                const segmentCount = 12;
                for (let i = 0; i < segmentCount; i++) {
                    const angle = (i / segmentCount) * Math.PI * 2;
                    const segmentGeometry = new THREE.BoxGeometry(0.25, 0.25, 0.1);
                    const darkerColor = new THREE.Color(portalColor).multiplyScalar(0.4);
                    const segmentMaterial = new THREE.MeshBasicMaterial({
                        color: darkerColor,
                        transparent: true,
                        opacity: 0.9
                    });
                    const segment = new THREE.Mesh(segmentGeometry, segmentMaterial);
                    const xPos = Math.cos(angle) * portalRadius;
                    const yPos = Math.sin(angle) * portalRadius * 1.2;
                    segment.position.set(xPos, yPos, 0.05);
                    segment.rotation.z = angle + Math.PI / 2;
                    const glowGeometry = new THREE.BoxGeometry(0.35, 0.35, 0.15);
                    const glowMaterial = new THREE.MeshBasicMaterial({
                        color: portalColor,
                        transparent: true,
                        opacity: 0.5,
                        blending: THREE.AdditiveBlending
                    });
                    const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                    segment.userData.originalPos = {x: xPos, y: yPos};
                    segment.userData.angle = angle;
                    segment.userData.glowFactor = 0.7 + Math.random() * 0.6;
                    segment.userData.glowPhase = Math.random() * Math.PI * 2;
                    segment.add(glow);
                    this.portal.add(segment);
                }

                // Add additional glow rings.
                const edgeGlowGeometry = new THREE.RingGeometry(portalRadius - ringWidth - 0.05, portalRadius - ringWidth + 0.05, 32);
                const edgeGlowMaterial = new THREE.MeshBasicMaterial({
                    color: portalColor,
                    transparent: true,
                    opacity: 0.9,
                    side: THREE.DoubleSide,
                    blending: THREE.AdditiveBlending
                });
                const edgeGlow = new THREE.Mesh(edgeGlowGeometry, edgeGlowMaterial);
                edgeGlow.rotation.x = Math.PI / 2;
                edgeGlow.scale.set(1, 1.2, 1);
                this.portal.add(edgeGlow);

                const glowGeometry = new THREE.RingGeometry(portalRadius - 0.1, portalRadius + 0.4, 32);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: portalColor,
                    transparent: true,
                    opacity: 0.4,
                    blending: THREE.AdditiveBlending,
                    side: THREE.DoubleSide
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.rotation.x = Math.PI / 2;
                glow.scale.set(1, 1.2, 1);
                this.portal.add(glow);

                const wideGlowGeometry = new THREE.RingGeometry(portalRadius, portalRadius + 0.8, 32);
                const wideGlowMaterial = new THREE.MeshBasicMaterial({
                    color: portalColor,
                    transparent: true,
                    opacity: 0.2,
                    blending: THREE.AdditiveBlending,
                    side: THREE.DoubleSide
                });
                const wideGlow = new THREE.Mesh(wideGlowGeometry, wideGlowMaterial);
                wideGlow.rotation.x = Math.PI / 2;
                wideGlow.scale.set(1, 1.2, 1);
                this.portal.add(wideGlow);

                // Add portal particles.
                this.portalParticles = [];
                const particleCount = 30;
                for (let i = 0; i < particleCount; i++) {
                    const size = 0.04 + Math.random() * 0.1;
                    const particleGeometry = new THREE.BoxGeometry(size, size, size);
                    const particleMaterial = new THREE.MeshBasicMaterial({
                        color: portalColor,
                        transparent: true,
                        opacity: 0.5 + Math.random() * 0.5,
                        blending: THREE.AdditiveBlending
                    });
                    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                    let angle, radius;
                    const leftSide = Math.random() < 0.7;
                    if (leftSide) {
                        angle = Math.PI * 0.5 + (Math.random() - 0.5) * Math.PI;
                        radius = portalRadius * 1.2 + Math.random() * 2.0;
                    } else {
                        angle = Math.PI * 1.5 + (Math.random() - 0.5) * Math.PI;
                        radius = portalRadius * 1.1 + Math.random() * 1.2;
                    }
                    particle.position.x = Math.cos(angle) * radius;
                    particle.position.y = Math.sin(angle) * radius * 1.2;
                    particle.position.z = (Math.random() - 0.5) * 0.2;
                    particle.rotation.z = Math.random() * Math.PI * 2;
                    particle.userData = {
                        angle: angle,
                        radius: radius,
                        speed: 0.1 + Math.random() * 0.2,
                        pulseSpeed: 0.5 + Math.random() * 0.5,
                        originalSize: size,
                        driftX: (Math.random() - 0.5) * 0.2,
                        driftY: (Math.random() - 0.5) * 0.2
                    };
                    this.portal.add(particle);
                    this.portalParticles.push(particle);
                }
                this.portal.userData = {
                    type: 'portal',
                    width: 1.4,
                    height: 1.8
                };
                this.scene.add(this.portal);
            }

            updatePortal(deltaTime) {
                if (!this.portal) return;
                this.portal.children.forEach(child => {
                    if (child.userData.rotationSpeed) {
                        child.rotation.z += deltaTime * child.userData.rotationSpeed * child.userData.rotationDirection;
                    }
                    if (child.userData.angle !== undefined) {
                        const time = performance.now() * 0.001;
                        const glowIntensity = 0.5 + 0.4 * Math.sin(time * child.userData.glowFactor + child.userData.glowPhase);
                        if (child.children.length > 0) {
                            const glowMesh = child.children[0];
                            glowMesh.material.opacity = glowIntensity;
                            const scale = 1 + glowIntensity * 0.2;
                            glowMesh.scale.set(scale, scale, scale);
                            const wiggle = Math.sin(time * 2 + child.userData.angle) * 0.02;
                            child.position.x = child.userData.originalPos.x + wiggle;
                            child.position.y = child.userData.originalPos.y + wiggle;
                        }
                    }
                });
                const glowFactor = 1 + Math.sin(performance.now() * 0.003) * 0.2;
                this.portal.children.forEach(child => {
                    if (child.geometry && child.geometry.type.includes("RingGeometry")) {
                        child.scale.set(glowFactor, glowFactor * 1.2, 1);
                    }
                });
                if (this.portalParticles && this.portalParticles.length > 0) {
                    this.portalParticles.forEach(particle => {
                        particle.userData.angle += deltaTime * particle.userData.speed;
                        particle.position.x += particle.userData.driftX * deltaTime;
                        particle.position.y += particle.userData.driftY * deltaTime;
                        if (Math.random() < 0.01) {
                            particle.userData.driftX = (Math.random() - 0.5) * 0.3;
                            particle.userData.driftY = (Math.random() - 0.5) * 0.3;
                        }
                        const distanceFromCenter = Math.sqrt(
                            particle.position.x * particle.position.x +
                            particle.position.y * particle.position.y
                        );
                        if (distanceFromCenter > 4.0) {
                            const leftSide = Math.random() < 0.7;
                            if (leftSide) {
                                particle.userData.angle = Math.PI * 0.5 + (Math.random() - 0.5) * Math.PI;
                                particle.userData.radius = 1.2 * 1.2 + Math.random() * 2.0;
                            } else {
                                particle.userData.angle = Math.PI * 1.5 + (Math.random() - 0.5) * Math.PI;
                                particle.userData.radius = 1.2 * 1.1 + Math.random() * 1.2;
                            }
                            particle.position.x = Math.cos(particle.userData.angle) * particle.userData.radius;
                            particle.position.y = Math.sin(particle.userData.angle) * particle.userData.radius * 1.2;
                        }
                        particle.material.opacity = 0.3 + Math.sin(performance.now() * 0.002 * particle.userData.pulseSpeed) * 0.3;
                        particle.rotation.z += deltaTime * particle.userData.speed * 0.5;
                    });
                }
                const distanceToPortal = Math.sqrt(
                    Math.pow(this.player.position.x - this.portal.position.x, 2) +
                    Math.pow(this.player.position.y - this.portal.position.y, 2)
                );
                const proximityThreshold = 4.0;
                const playerLeft = this.player.position.x - this.playerSize / 2;
                const playerRight = this.player.position.x + this.playerSize / 2;
                const playerBottom = this.player.position.y - this.playerSize / 2;
                const playerTop = this.player.position.y + this.playerSize / 2;
                const portalLeft = this.portal.position.x - this.portal.userData.width / 2;
                const portalRight = this.portal.position.x + this.portal.userData.width / 2;
                const portalBottom = this.portal.position.y - this.portal.userData.height / 2;
                const portalTop = this.portal.position.y + this.portal.userData.height / 2;
                if ((playerRight > portalLeft && playerLeft < portalRight &&
                        playerBottom < portalTop && playerTop > portalBottom) ||
                    distanceToPortal < proximityThreshold) {
                    logDebug("Level complete - advancing to next level");

                    // Clean up all visual effects before level change
                    this.cleanupVisualEffects();

                    this.isJumping = false;
                    this.levelManager.nextLevel();
                    this.updateLevelDisplay();

                    // Reset death counter for the new level
                    this.levelDeathCount = 0;

                    // Create the new level - this will position the player correctly
                    this.createLevel();

                    // Reset velocities to ensure proper player movement at level start
                    this.playerVelocity.x = this.baseVelocity;
                    this.playerVelocity.y = 0;
                    this.onGround = true;
                }
            }

            cleanupVisualEffects() {
                // Clean up jump particles
                if (this.jumpParticles && this.jumpParticles.length > 0) {
                    this.jumpParticles.forEach(particle => {
                        this.scene.remove(particle);
                    });
                    this.jumpParticles = [];
                }

                // Clean up jump path
                if (this.jumpPath) {
                    this.scene.remove(this.jumpPath);
                    this.jumpPath = null;
                    this.jumpHistoryPoints = [];
                }

                // Remove any other visual artifacts
                const particlesToRemove = [];
                this.scene.traverse(object => {
                    // Look for any stray particle effects
                    if (object.isMesh && object.material &&
                        (object.material.blending === THREE.AdditiveBlending ||
                            object.material.transparent)) {
                        // Check if it's not part of main game objects
                        const isMainObject = this.platforms.includes(object) ||
                            this.obstacles.includes(object) ||
                            this.collectibles.includes(object) ||
                            (this.portal && this.portal.children.includes(object));

                        if (!isMainObject && !object.parent.userData?.type) {
                            particlesToRemove.push(object);
                        }
                    }
                });

                // Remove identified particles
                particlesToRemove.forEach(particle => {
                    this.scene.remove(particle);
                });
            }

            createCollectible(x, y) {
                const theme = this.getTheme();
                const collectibleGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                const collectibleMaterial = new THREE.MeshBasicMaterial({
                    color: theme.collectible,
                    transparent: true,
                    opacity: 0.9
                });
                const collectible = new THREE.Mesh(collectibleGeometry, collectibleMaterial);
                collectible.position.set(x, y, 0);
                collectible.userData = {type: 'coin', width: 0.5, height: 0.5, collected: false};
                this.scene.add(collectible);
                this.collectibles.push(collectible);
                const collectibleGlowGeometry = new THREE.BoxGeometry(0.7, 0.7, 0.7);
                const collectibleGlowMaterial = new THREE.MeshBasicMaterial({
                    color: theme.collectible,
                    transparent: true,
                    opacity: 0.4,
                    blending: THREE.AdditiveBlending
                });
                const collectibleGlow = new THREE.Mesh(collectibleGlowGeometry, collectibleGlowMaterial);
                collectible.add(collectibleGlow);
                const specialEffectGeometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
                const specialEffectMaterial = new THREE.MeshBasicMaterial({
                    color: theme.collectible,
                    transparent: true,
                    opacity: 0.5,
                    blending: THREE.AdditiveBlending
                });
                const specialEffect = new THREE.Mesh(specialEffectGeometry, specialEffectMaterial);
                specialEffect.position.set(0, 0.25, 0.1);
                collectible.add(specialEffect);
                const sound = new Audio();
                sound.src = 'path/to/special-collectible-sound.mp3';
                sound.autoplay = false;
                collectible.userData.sound = sound;
            }

            createSpecialCollectible(x, y) {
                const theme = this.getTheme();
                const specialCollectibleGeometry = new THREE.BoxGeometry(0.7, 0.7, 0.7);
                const specialCollectibleMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00FFAA,
                    transparent: true,
                    opacity: 0.9
                });
                const specialCollectible = new THREE.Mesh(specialCollectibleGeometry, specialCollectibleMaterial);
                specialCollectible.position.set(x, y, 0);
                specialCollectible.userData = {type: 'special', width: 1.4, height: 1.4, collected: false, value: 500};
                this.scene.add(specialCollectible);
                this.collectibles.push(specialCollectible);
                const specialCollectibleGlowGeometry = new THREE.BoxGeometry(0.9, 0.9, 0.9);
                const specialCollectibleGlowMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00FFAA,
                    transparent: true,
                    opacity: 0.4,
                    blending: THREE.AdditiveBlending
                });
                const specialCollectibleGlow = new THREE.Mesh(specialCollectibleGlowGeometry, specialCollectibleGlowMaterial);
                specialCollectible.add(specialCollectibleGlow);
                const sound = new Audio();
                sound.src = 'path/to/special-collectible-sound.mp3';
                sound.autoplay = false;
                specialCollectible.userData.sound = sound;
            }

            clearLevel() {
                // Clean up visual effects first
                this.cleanupVisualEffects();

                // Helper function to properly dispose of materials and geometries
                const disposeMesh = (object) => {
                    if (!object) return;

                    // Dispose of children first
                    if (object.children && object.children.length > 0) {
                        // Create a copy of the children array to avoid issues while removing
                        const children = [...object.children];
                        children.forEach(child => {
                            disposeMesh(child);
                        });
                    }

                    // Dispose geometry
                    if (object.geometry) {
                        object.geometry.dispose();
                    }

                    // Dispose material(s)
                    if (object.material) {
                        if (Array.isArray(object.material)) {
                            object.material.forEach(material => {
                                if (material.map) material.map.dispose();
                                material.dispose();
                            });
                        } else {
                            if (object.material.map) object.material.map.dispose();
                            object.material.dispose();
                        }
                    }

                    // Remove from parent
                    if (object.parent) {
                        object.parent.remove(object);
                    }
                };

                // Clean up game objects
                if (this.platforms) {
                    this.platforms.forEach(platform => {
                        if (platform && platform.parent) {
                            disposeMesh(platform);
                        }
                    });
                    this.platforms = [];
                }

                if (this.obstacles) {
                    this.obstacles.forEach(obstacle => {
                        if (obstacle && obstacle.parent) {
                            disposeMesh(obstacle);
                        }
                    });
                    this.obstacles = [];
                }

                if (this.collectibles) {
                    this.collectibles.forEach(coin => {
                        if (coin && coin.parent) {
                            disposeMesh(coin);
                        }
                    });
                    this.collectibles = [];
                }

                if (this.portal) {
                    disposeMesh(this.portal);
                    this.portal = null;
                    this.portalParticles = [];
                }

                // Clear floor tile positions
                this.floorTilePositions = [];

                this.clearGrids();
                this.updateUITheme();
                this.updatePlayerTheme();

                // Final scene cleanup - remove any stray objects
                const objectsToRemove = [];
                this.scene.traverse(object => {
                    // Skip the player and essential scene objects
                    if (object === this.scene ||
                        object === this.player ||
                        (this.player && this.player.children.includes(object)) ||
                        object.isGridHelper ||
                        object.isLight) {
                        return;
                    }

                    // Check for untracked meshes with visual effects
                    if (object.isMesh || object.isLine || object.isPoints) {
                        // Only objects directly in the scene are considered stray
                        // (child objects will be handled by their parents)
                        if (object.parent === this.scene) {
                            objectsToRemove.push(object);
                        }
                    }
                });

                objectsToRemove.forEach(object => {
                    disposeMesh(object);
                });
            }

            clearGrids() {
                const grids = this.scene.children.filter(child => child instanceof THREE.GridHelper);
                grids.forEach(grid => this.scene.remove(grid));

                // Remove existing grid planes
                const gridPlanes = this.scene.children.filter(child =>
                    child.isGridPlane ||
                    (child.isMesh && child.geometry && child.geometry.type === 'PlaneGeometry')
                );
                gridPlanes.forEach(plane => this.scene.remove(plane));

                const theme = this.getTheme();
                const gridSize = 1000;
                const gridDivisions = 200;
                const gridColor = theme.grid;

                // Create main grid helper
                const gridHelper = new THREE.GridHelper(gridSize, gridDivisions, gridColor, gridColor);
                gridHelper.position.y = this.groundY - 0.4;
                gridHelper.material.transparent = true;
                gridHelper.material.opacity = 0.3;
                gridHelper.material.blending = THREE.AdditiveBlending;
                gridHelper.rotation.x = Math.PI / 2;
                gridHelper.isGridHelper = true;
                this.scene.add(gridHelper);

                // Create secondary grid helper (finer grid)
                const secondaryGridSize = 500;
                const secondaryGridDivisions = 50;
                const secondaryGridHelper = new THREE.GridHelper(secondaryGridSize, secondaryGridDivisions, gridColor, gridColor);
                secondaryGridHelper.position.y = this.groundY - 0.39;
                secondaryGridHelper.material.transparent = true;
                secondaryGridHelper.material.opacity = 0.4;
                secondaryGridHelper.material.blending = THREE.AdditiveBlending;
                secondaryGridHelper.rotation.x = Math.PI / 2;
                secondaryGridHelper.isGridHelper = true;
                this.scene.add(secondaryGridHelper);

                // Create the background grid plane
                const gridPlaneGeometry = new THREE.PlaneGeometry(gridSize, gridSize);
                const gridPlaneMaterial = new THREE.MeshBasicMaterial({
                    color: 0x0A0A44,
                    transparent: true,
                    opacity: 0.9
                });
                const gridPlane = new THREE.Mesh(gridPlaneGeometry, gridPlaneMaterial);
                gridPlane.position.y = this.groundY - 0.45;
                gridPlane.rotation.x = -Math.PI / 2;
                gridPlane.isGridPlane = true;
                this.scene.add(gridPlane);
            }

            createDeathEffect(x, y) {
                const theme = this.getTheme();
                const particleCount = 15;
                const particles = [];

                // Play death sound
                this.playSound('death');

                for (let i = 0; i < particleCount; i++) {
                    const size = 0.1 + Math.random() * 0.15;
                    const particleGeometry = new THREE.BoxGeometry(size, size, size);
                    const particleMaterial = new THREE.MeshBasicMaterial({
                        color: theme.player, // Use the fixed player color
                        transparent: true,
                        opacity: 0.8,
                        blending: THREE.AdditiveBlending
                    });
                    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                    particle.position.set(x, y, 0);
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 0.05 + Math.random() * 0.1;
                    particle.userData = {
                        velocityX: Math.cos(angle) * speed,
                        velocityY: Math.sin(angle) * speed,
                        rotationSpeed: (Math.random() - 0.5) * 0.2
                    };
                    this.scene.add(particle);
                    particles.push(particle);
                }
                const fadeAnimation = () => {
                    if (particles.length === 0 || !this.isRunning) return;
                    for (let i = particles.length - 1; i >= 0; i--) {
                        const particle = particles[i];
                        particle.position.x += particle.userData.velocityX;
                        particle.position.y += particle.userData.velocityY;
                        particle.userData.velocityY -= 0.002;
                        particle.rotation.z += particle.userData.rotationSpeed;
                        particle.material.opacity -= 0.01;
                        if (particle.material.opacity <= 0) {
                            this.scene.remove(particle);
                            particles.splice(i, 1);
                        }
                    }
                    if (particles.length > 0) {
                        requestAnimationFrame(fadeAnimation);
                    }
                };
                fadeAnimation();
            }

            // Add this new method to handle jumping
            jump() {
                // Don't allow jumping if game is over
                if (this.gameOverUI.style.display === 'block') return;

                // Prevent repeated jumping if already in the air and not near a platform
                const canJump = this.onGround || this.onPlatform ||
                    (this.playerVelocity.y > -3 && this.playerVelocity.y <= 0);

                if (canJump && !this.isJumping && this.isRunning && !this.isPaused) {
                    // Reset rotation when starting a new jump
                    this.player.rotation.z = 0;

                    this.playerVelocity.y = this.jumpForce;
                    this.isJumping = true;
                    this.onGround = false;
                    this.onPlatform = false;
                    this.createJumpParticles();

                    // Play jump sound
                    this.playSound('jump');
                }
            }
            
            animatePlayerEnteringPortal(portalX, portalY, completionCallback) {
                // Disable normal player movement during the animation
                this.isRunning = false;
                const originalVelocity = {...this.playerVelocity};
                this.playerVelocity = {x: 0, y: 0};
                
                // Create a full-screen overlay for the fade effect
                const overlay = document.createElement('div');
                overlay.style.position = 'fixed';
                overlay.style.top = '0';
                overlay.style.left = '0';
                overlay.style.width = '100%';
                overlay.style.height = '100%';
                overlay.style.backgroundColor = 'rgba(0, 0, 51, 0)'; // Start transparent with dark blue background
                overlay.style.transition = 'background-color 2s ease-in';
                overlay.style.zIndex = '9999';
                overlay.style.display = 'flex';
                overlay.style.justifyContent = 'center';
                overlay.style.alignItems = 'center';
                document.body.appendChild(overlay);
                
                // Create the teleporting text with neon effect similar to LEVEL 1
                const teleportText = document.createElement('div');
                teleportText.textContent = 'TELEPORTING';
                teleportText.style.fontFamily = 'monospace, sans-serif';
                teleportText.style.fontSize = '48px';
                teleportText.style.fontWeight = 'bold';
                teleportText.style.color = '#00FFFF'; // Cyan neon color
                teleportText.style.textShadow = '0 0 10px #00FFFF, 0 0 20px #00FFFF, 0 0 30px #00FFFF';
                teleportText.style.opacity = '0';
                teleportText.style.transition = 'opacity 1.5s ease-in';
                teleportText.style.letterSpacing = '4px';
                teleportText.style.textTransform = 'uppercase';
                teleportText.style.border = '3px solid #00FFFF';
                teleportText.style.borderRadius = '10px';
                teleportText.style.padding = '15px 30px';
                teleportText.style.boxShadow = '0 0 10px #00FFFF, 0 0 20px #00FFFF';
                overlay.appendChild(teleportText);
                
                // Start the animation sequence
                setTimeout(() => {
                    // Fade in the dark blue overlay
                    overlay.style.backgroundColor = 'rgba(0, 0, 51, 0.9)'; // Dark blue background like the image
                    
                    // Show the teleporting text after a short delay
                    setTimeout(() => {
                        teleportText.style.opacity = '1';
                        
                        // Create a pulsing effect for the text
                        let pulseIntensity = 1;
                        const pulseInterval = setInterval(() => {
                            pulseIntensity = pulseIntensity === 1 ? 1.5 : 1;
                            teleportText.style.textShadow = `0 0 ${10 * pulseIntensity}px #00FFFF, 0 0 ${20 * pulseIntensity}px #00FFFF, 0 0 ${30 * pulseIntensity}px #00FFFF`;
                            teleportText.style.boxShadow = `0 0 ${10 * pulseIntensity}px #00FFFF, 0 0 ${20 * pulseIntensity}px #00FFFF`;
                        }, 500);
                        
                        // Execute the callback and clean up after animation completes
                        setTimeout(() => {
                            clearInterval(pulseInterval);
                            
                            // Execute teleport callback
                            if (typeof completionCallback === 'function') {
                                completionCallback();
                            }
                            
                            // Reset player properties
                            this.player.visible = true;
                            this.player.rotation.z = 0;
                            this.playerVelocity = originalVelocity;
                            this.isRunning = true;
                        }, 2000);
                    }, 500);
                }, 100);
            }

            activateInvisibility() {
                this.isInvisible = true;
                this.isInvincible = true; // Make player invincible while invisible
                
                // Store original opacity values
                const originalOpacities = new Map();
                this.player.traverse((child) => {
                    if (child.material && child.material.opacity !== undefined) {
                        originalOpacities.set(child, child.material.opacity);
                        child.material.opacity *= 0.3; // Make player semi-transparent
                    }
                });
                
                // Create ethereal effect
                const etherealEffect = new THREE.Group();
                etherealEffect.name = 'etherealEffect';
                
                // Add ghostly trail effect
                const trailGeometry = new THREE.BoxGeometry(this.playerSize * 1.2, this.playerSize * 1.2, this.playerSize * 0.6);
                const trailMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00FFFF,
                    transparent: true,
                    opacity: 0.2,
                    blending: THREE.AdditiveBlending
                });
                const trail = new THREE.Mesh(trailGeometry, trailMaterial);
                etherealEffect.add(trail);
                
                // Add pulsing glow
                const glowAnimation = () => {
                    if (!this.isInvisible) {
                        this.player.remove(etherealEffect);
                        return;
                    }
                    const time = performance.now() * 0.001;
                    trail.material.opacity = 0.1 + Math.sin(time * 2) * 0.1;
                    trail.scale.set(
                        1 + Math.sin(time * 3) * 0.1,
                        1 + Math.sin(time * 2) * 0.1,
                        1
                    );
                    requestAnimationFrame(glowAnimation);
                };
                
                // Add the effect to the player
                this.player.add(etherealEffect);
                glowAnimation();
                
                // Clear existing timer if any
                if (this.invisibilityTimer) {
                    clearTimeout(this.invisibilityTimer);
                }
                
                // Set timer to deactivate invisibility
                this.invisibilityTimer = setTimeout(() => {
                    this.isInvisible = false;
                    this.isInvincible = false;
                    this.player.remove(etherealEffect);
                    
                    // Restore original opacity values
                    this.player.traverse((child) => {
                        if (originalOpacities.has(child)) {
                            child.material.opacity = originalOpacities.get(child);
                        }
                    });
                    
                    // Add reappearing effect
                    const reappearEffect = () => {
                        const particles = [];
                        const particleCount = 20;
                        
                        for (let i = 0; i < particleCount; i++) {
                            const particle = new THREE.Mesh(
                                new THREE.BoxGeometry(0.1, 0.1, 0.1),
                                new THREE.MeshBasicMaterial({
                                    color: 0x00FFFF,
                                    transparent: true,
                                    opacity: 0.8,
                                    blending: THREE.AdditiveBlending
                                })
                            );
                            
                            const angle = (i / particleCount) * Math.PI * 2;
                            const radius = 0.5;
                            particle.position.set(
                                Math.cos(angle) * radius,
                                Math.sin(angle) * radius,
                                0
                            );
                            
                            particle.userData.velocity = {
                                x: (Math.random() - 0.5) * 0.2,
                                y: (Math.random() - 0.5) * 0.2
                            };
                            
                            this.player.add(particle);
                            particles.push(particle);
                        }
                        
                        let duration = 0;
                        const animate = () => {
                            if (duration > 30) {
                                particles.forEach(p => this.player.remove(p));
                                return;
                            }
                            
                            particles.forEach(particle => {
                                particle.position.x += particle.userData.velocity.x;
                                particle.position.y += particle.userData.velocity.y;
                                particle.material.opacity -= 0.02;
                            });
                            
                            duration++;
                            requestAnimationFrame(animate);
                        };
                        animate();
                    };
                    reappearEffect();
                }, this.invisibilityDuration);
                
                // Play activation sound
                const invisibilitySound = new Audio();
                invisibilitySound.src = 'assets/coin.wav'; // Reuse coin sound for now
                invisibilitySound.volume = 0.3;
                invisibilitySound.play().catch(error => {
                    logDebug("Error playing invisibility sound: " + error.message);
                });
            }

            createBlackHoleExplosion(x, y) {
                const particleCount = 20;
                const particles = [];
                
                for (let i = 0; i < particleCount; i++) {
                    const angle = (i / particleCount) * Math.PI * 2;
                    const speed = 5 + Math.random() * 5;
                    
                    const particleGeometry = new THREE.CircleGeometry(0.1, 8);
                    const particleMaterial = new THREE.MeshBasicMaterial({
                        color: 0x6600ff,
                        transparent: true,
                        opacity: 0.8
                    });
                    
                    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                    particle.position.set(x, y, 0);
                    
                    particle.userData = {
                        velocityX: Math.cos(angle) * speed,
                        velocityY: Math.sin(angle) * speed,
                        life: 1.0
                    };
                    
                    this.scene.add(particle);
                    particles.push(particle);
                }
                
                // Create a function to update and remove particles
                const updateParticles = () => {
                    if (!this.isRunning) return;
                    
                    for (let i = particles.length - 1; i >= 0; i--) {
                        const particle = particles[i];
                        particle.position.x += particle.userData.velocityX * 0.016;
                        particle.position.y += particle.userData.velocityY * 0.016;
                        particle.userData.life -= 0.016 * 2;
                        particle.material.opacity = particle.userData.life;
                        
                        if (particle.userData.life <= 0) {
                            this.scene.remove(particle);
                            particles.splice(i, 1);
                        }
                    }
                    
                    if (particles.length > 0) {
                        requestAnimationFrame(updateParticles);
                    }
                };
                
                updateParticles();
            }
        }

        // Initialize game.
        const game = new Game();

        // Hide debug console by default, show only when 'D' key is pressed
        const debugConsole = document.getElementById('debug-console');
        if (debugConsole) debugConsole.style.display = 'none';

        // Add event listener for 'D' key to toggle debug console
        document.addEventListener('keydown', (event) => {
            if (event.key === 'D' || event.key === 'd') {
                if (debugConsole) {
                    debugConsole.style.display = debugConsole.style.display === 'none' ? 'block' : 'none';
                }
            }
        });


        logDebug("CONTROLS: Press SPACE or UP ARROW to jump");
        logDebug("Press RIGHT ARROW for temporary speed boost");
        logDebug("Game automatically moves forward");
        logDebug("Avoid spikes and collect coins!");
    }
</script>
</body>
</html> 