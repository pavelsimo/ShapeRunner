<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ShapeRunner</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Rajdhani:wght@500;700&display=swap');
        
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Orbitron', 'Rajdhani', sans-serif;
            color: #00FFFF;
        }
        
        canvas {
            display: block;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 10;
        }
        
        #score-display {
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px 15px;
            border: 2px solid #00FFFF;
            border-radius: 4px;
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            box-shadow: 0 0 10px #00FFFF, inset 0 0 5px #00FFFF;
            text-shadow: 0 0 5px #00FFFF;
            margin-bottom: 15px;
            display: inline-block;
            transition: all 0.2s ease;
            letter-spacing: 1px;
            animation: uiGlow 2s infinite alternate;
        }
        
        #score-display:hover {
            box-shadow: 0 0 15px #00FFFF, inset 0 0 8px #00FFFF;
        }
        
        #level-display {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px 15px;
            border: 2px solid #00FFFF;
            border-radius: 4px;
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            box-shadow: 0 0 10px #00FFFF, inset 0 0 5px #00FFFF;
            text-shadow: 0 0 5px #00FFFF;
            letter-spacing: 1px;
            z-index: 100;
            transition: all 0.2s ease;
            animation: uiGlow 2s infinite alternate;
        }
        
        #level-display:hover {
            box-shadow: 0 0 15px #00FFFF, inset 0 0 8px #00FFFF;
        }
        
        @keyframes uiGlow {
            from {
                box-shadow: 0 0 10px #00FFFF, inset 0 0 5px #00FFFF;
                text-shadow: 0 0 5px #00FFFF;
            }
            to {
                box-shadow: 0 0 15px #00FFFF, inset 0 0 8px #00FFFF;
                text-shadow: 0 0 8px #00FFFF;
            }
        }
        
        @keyframes levelUpdate {
            0% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.2); }
            100% { transform: translateX(-50%) scale(1); }
        }
        
        #pause-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 40px;
            height: 40px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 2px solid #00FFFF;
            border-radius: 4px;
            cursor: pointer;
            box-shadow: 0 0 10px #00FFFF, inset 0 0 5px #00FFFF;
            transition: all 0.2s ease;
            z-index: 100;
            animation: uiGlow 2s infinite alternate;
        }
        
        #pause-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 15px #00FFFF, inset 0 0 10px #00FFFF;
        }
        
        #pause-btn:active {
            transform: scale(0.95);
        }
        
        #pause-btn div {
            width: 5px;
            height: 20px;
            background-color: #00FFFF;
            margin: 0 3px;
            border-radius: 2px;
            box-shadow: 0 0 5px #00FFFF;
        }
        
        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background-color: rgba(0, 0, 0, 0.8);
            border: 2px solid #00FFFF;
            border-radius: 8px;
            padding: 20px 40px;
            box-shadow: 0 0 20px #00FFFF, inset 0 0 10px #00FFFF;
            display: none;
            z-index: 20;
        }
        
        #game-over h2 {
            font-size: 36px;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 10px #00FFFF;
            animation: neonPulse 1.5s infinite alternate;
        }
        
        #retry-btn {
            display: inline-block;
            background-color: transparent;
            color: #00FFFF;
            border: 2px solid #00FFFF;
            border-radius: 4px;
            padding: 10px 20px;
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            box-shadow: 0 0 10px #00FFFF;
            text-shadow: 0 0 5px #00FFFF;
            transition: all 0.2s ease;
            margin-top: 10px;
        }
        
        #retry-btn:hover {
            background-color: rgba(0, 255, 255, 0.2);
            transform: scale(1.1);
            box-shadow: 0 0 15px #00FFFF;
        }
        
        #retry-btn:active {
            transform: scale(0.95);
        }
        
        @keyframes neonPulse {
            from {
                text-shadow: 0 0 5px #00FFFF, 0 0 10px #00FFFF;
            }
            to {
                text-shadow: 0 0 10px #00FFFF, 0 0 20px #00FFFF, 0 0 30px #00FFFF;
            }
        }
        
        /* Debug console for errors */
        #debug-console {
            position: fixed;
            bottom: 10px;
            left: 10px;
            width: 80%;
            max-height: 150px;
            overflow-y: auto;
            background-color: rgba(0, 0, 0, 0.8);
            color: #FF5555;
            font-family: monospace;
            font-size: 12px;
            padding: 10px;
            border: 1px solid #FF0000;
            border-radius: 4px;
            z-index: 9999;
            display: none;
        }
    </style>
</head>
<body>
    <div id="ui">
        <div id="score-display">SCORE: 0</div>
    </div>
    
    <div id="level-display">LEVEL 1</div>
    
    <div id="pause-btn">
        <div></div>
        <div></div>
    </div>
    
    <div id="game-over">
        <h2>GAME OVER</h2>
        <div id="final-score">SCORE: 0</div>
        <button id="retry-btn">RETRY</button>
    </div>

    <div id="debug-console"></div>

    <!-- Load THREE.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // Debug logging
        const debug = document.getElementById('debug-console');
        debug.style.display = 'block'; // Always show initially
        
        function logDebug(message) {
            if (debug) {
                debug.innerHTML += `<div>${message}</div>`;
                debug.scrollTop = debug.scrollHeight;
            }
            console.log(message);
        }

        // Check if THREE is loaded
        if (typeof THREE === 'undefined') {
            logDebug("ERROR: THREE.js not loaded! Trying alternative CDN...");
            // Create a script element for the alternative CDN
            const script = document.createElement('script');
            script.src = "https://unpkg.com/three@0.128.0/build/three.min.js";
            script.onload = function() {
                logDebug("THREE.js loaded from alternative CDN");
                initGame();
            };
            script.onerror = function() {
                logDebug("CRITICAL ERROR: Could not load THREE.js from alternative source");
            };
            document.head.appendChild(script);
        } else {
            logDebug("THREE.js loaded successfully");
            initGame();
        }

        // Global error handling
        window.onerror = function(message, source, lineno, colno, error) {
            logDebug(`ERROR: ${message} at line ${lineno}:${colno}`);
        };

        // Wrap the game initialization in a function
        function initGame() {
            logDebug("Initializing ShapeRunner...");
            
            // Level data (embedded instead of loading from JSON files)
            const levelTitles = {
                start: {
                    title: "Starting Line",
                    description: "The player starts here on every level",
                    width: 10,
                    height: 8,
                    layout: [
                        "...........",
                        "...........",
                        "...........",
                        "...........",
                        "...........",
                        "....S......",
                        "BBBBBBBBBB.",
                        "..........."
                    ]
                },
                end: {
                    title: "Finish Line",
                    description: "The end of every level with the exit portal",
                    width: 10,
                    height: 8,
                    layout: [
                        "...........",
                        "...........",
                        "......E....",
                        ".....BBB...",
                        "...........",
                        "...........",
                        "BBBBBBBBBB.",
                        "..........."
                    ]
                },
                title1: {
                    title: "Simple Platforms",
                    description: "Basic platform layout with some spikes",
                    width: 20,
                    height: 8,
                    layout: [
                        ".....................",
                        ".....................",
                        "........C............",
                        "......BBBB...........",
                        "..BBB................",
                        ".....................",
                        "B.........BBB........",
                        "BBBBBBBBBBBBBBBBBBBBB"
                    ]
                },
                title2: {
                    title: "Jump and Slide",
                    description: "Jumps and slopes challenge",
                    width: 20,
                    height: 8,
                    layout: [
                        ".....................",
                        "............C........",
                        "..........BBBB.......",
                        "........./........C..",
                        "......../............",
                        "...J.../....C........",
                        "...B../...BBB........",
                        "BBBBBBBBBBBBBBBBBBBBB"
                    ]
                },
                title3: {
                    title: "Dangerous Path",
                    description: "Navigate through obstacles to find the key",
                    width: 20,
                    height: 8,
                    layout: [
                        ".....................",
                        "............K........",
                        "...........BBBB......",
                        ".....................",
                        ".....O...O...........",
                        "..BBB....BBB.........",
                        ".....................",
                        "BBBBBBBBBBBBBBBBBBBBB"
                    ]
                },
                title4: {
                    title: "Platform Gauntlet",
                    description: "Navigate through a challenging platform field",
                    width: 20,
                    height: 8,
                    layout: [
                        ".....................",
                        "..........C..........",
                        "BBBB..........BBB....",
                        "....B........B.......",
                        "....B........B..C....",
                        "....BBBBBBBBB........",
                        "............J........",
                        "BBBBBBBBBBBBBBBBBBBBB"
                    ]
                },
                title5: {
                    title: "Treasure Finale",
                    description: "Final section with a special collectible",
                    width: 20,
                    height: 8,
                    layout: [
                        ".....................",
                        "..................P..",
                        "...................B.",
                        "..........C..........",
                        "........BBBB.........",
                        ".....J................",
                        "...BBB................",
                        "^.^.^.^.^............"
                    ]
                },
                title6: {
                    title: "Cyan Platforms",
                    description: "Basic platform layout with Cyan color",
                    width: 20,
                    height: 8,
                    layout: [
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB"
                    ]
                },
                title7: {
                    title: "Purple Platforms",
                    description: "Basic platform layout with Purple color",
                    width: 20,
                    height: 8,
                    layout: [
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB"
                    ]
                },
                title8: {
                    title: "Orange Platforms",
                    description: "Basic platform layout with Orange color",
                    width: 20,
                    height: 8,
                    layout: [
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB"
                    ]
                },
                title9: {
                    title: "Green Platforms",
                    description: "Basic platform layout with Green color",
                    width: 20,
                    height: 8,
                    layout: [
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB"
                    ]
                },
                title10: {
                    title: "Red Platforms",
                    description: "Basic platform layout with Red color",
                    width: 20,
                    height: 8,
                    layout: [
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB"
                    ]
                },
                jump1: {
                    title: "Jump Pad 1",
                    description: "A simple jump pad",
                    width: 2,
                    height: 1,
                    layout: [
                        "  C  ",
                        "BBBBB"
                    ]
                },
                jump2: {
                    title: "Jump Pad 2",
                    description: "A simple jump pad",
                    width: 2,
                    height: 1,
                    layout: [
                        "  C  ",
                        "BBBBB"
                    ]
                },
                jump3: {
                    title: "Jump Pad 3",
                    description: "A simple jump pad",
                    width: 2,
                    height: 1,
                    layout: [
                        "  C  ",
                        "BBBBB"
                    ]
                },
                special1: {
                    title: "Special Coin 1",
                    description: "A special coin",
                    width: 1,
                    height: 1,
                    layout: [
                        "  P  "
                    ]
                },
                special2: {
                    title: "Special Coin 2",
                    description: "A special coin",
                    width: 3,
                    height: 1,
                    layout: [
                        "B B B"
                    ]
                },
                gap1: {
                    title: "Gap 1",
                    description: "A gap",
                    width: 2,
                    height: 1,
                    layout: [
                        "  C  ",
                        "B BBB"
                    ]
                },
                gap2: {
                    title: "Gap 2",
                    description: "A gap",
                    width: 2,
                    height: 1,
                    layout: [
                        "     ",
                        "BB BB"
                    ]
                },
                gap3: {
                    title: "Gap 3",
                    description: "A gap",
                    width: 2,
                    height: 1,
                    layout: [
                        "     ",
                        "BBB B"
                    ]
                },
                challenge1: {
                    title: "Challenge 1",
                    description: "A challenge section",
                    width: 2,
                    height: 1,
                    layout: [
                        "  C  ",
                        "BBBBB"
                    ]
                },
                challenge2: {
                    title: "Challenge 2",
                    description: "A challenge section",
                    width: 2,
                    height: 1,
                    layout: [
                        "BBBBB"
                    ]
                },
                challenge3: {
                    title: "Challenge 3",
                    description: "A challenge section",
                    width: 2,
                    height: 1,
                    layout: [
                        "BBBBB"
                    ]
                }
            };

            // LevelManager class
            class LevelManager {
                constructor(game) {
                    this.game = game;
                    this.currentLevel = 1;
                    this.maxLevels = 5;

                    // Level sections in 2D arrays where:
                    // B = block/platform, S = start, E = end/portal, C = coin/collectible
                    // J = jump pad, P = special collectible
                    this.levelTitles = {
                        // Starter section with player start position
                        "start": [
                            "     ",
                            "     ",
                            "     ",
                            "     ",
                            "S    ",
                            "     "
                        ],
                        
                        // End section with portal
                        "end": [
                            "     ",
                            "     ",
                            "     ",
                            "     ",
                            "E    ",
                            "     "
                        ],
                        
                        // Various title sections to compose levels
                        "title1": [
                            "     ",
                            "     ",
                            "  C  ",
                            "  B  ",
                            "     ",
                            "     "
                        ],
                        
                        "title2": [
                            "     ",
                            "  C  ",
                            "     ",
                            "    B",
                            "C    ",
                            "     "
                        ],
                        
                        "title3": [
                            "     ",
                            "C   C",
                            "     ",
                            "  B  ",
                            "  J  ",
                            "     "
                        ],
                        
                        "title4": [
                            "     ",
                            "     ",
                            "C C C",
                            "     ",
                            "     ",
                            "     "
                        ],
                        
                        "title5": [
                            "     ",
                            "   C ",
                            "  B  ",
                            " B   ",
                            "C    ",
                            "     "
                        ],
                        
                        "title6": [
                            "     ",
                            "C   C",
                            "     ",
                            "BB   ",
                            "     ",
                            "     "
                        ],
                        
                        "title7": [
                            "     ",
                            "   C ",
                            " C   ",
                            "   B ",
                            " B   ",
                            "     "
                        ],
                        
                        "title8": [
                            "     ",
                            "   C ",
                            "     ",
                            "B BBB",
                            "     ",
                            "     "
                        ],
                        
                        "title9": [
                            "     ",
                            "  P  ",
                            "     ",
                            "B B B",
                            "     ",
                            "     "
                        ],
                        
                        "title10": [
                            "     ",
                            "C   C",
                            "     ",
                            "     ",
                            "B   B",
                            "     "
                        ],
                        
                        "jump1": [
                            "     ",
                            "  C  ",
                            "     ",
                            "     ",
                            "  J  ",
                            "     "
                        ],
                        
                        "jump2": [
                            "  C  ",
                            "     ",
                            "     ",
                            "     ",
                            "  J  ",
                            "     "
                        ],
                        
                        "jump3": [
                            "     ",
                            "     ",
                            "  C  ",
                            "     ",
                            "  J  ",
                            "     "
                        ],
                        
                        "special1": [
                            "     ",
                            "     ",
                            "  P  ",
                            "     ",
                            "     ",
                            "     "
                        ],
                        
                        "special2": [
                            "     ",
                            "  P  ",
                            "     ",
                            "B B B",
                            "     ",
                            "     "
                        ],
                        
                        "gap1": [
                            "     ",
                            "  C  ",
                            "     ",
                            "     ",
                            "     ",
                            "B    "
                        ],
                        
                        "gap2": [
                            "     ",
                            "     ",
                            "     ",
                            "  C  ",
                            "     ",
                            "BB  B"
                        ],
                        
                        "gap3": [
                            "     ",
                            "     ",
                            "  C  ",
                            "     ",
                            "     ",
                            "B    "
                        ],
                        
                        "challenge1": [
                            "  C  ",
                            "     ",
                            "B   B",
                            "     ",
                            "  C  ",
                            "     "
                        ],
                        
                        "challenge2": [
                            "     ",
                            "  C  ",
                            "     ",
                            "B B B",
                            "     ",
                            "     "
                        ],
                        
                        "challenge3": [
                            "     ",
                            "C   C",
                            "     ",
                            "  B  ",
                            "  J  ",
                            "     "
                        ],
                    };
                }
                
                // Initialize the level manager
                async initialize() {
                    logDebug("Level manager initialized");
                    return true;
                }
                
                // Level is completed, go to next level
                nextLevel() {
                    this.currentLevel++;
                    if (this.currentLevel > this.maxLevels) {
                        this.currentLevel = 1; // Reset to level 1 after completing all levels
                    }
                    return this.currentLevel;
                }
                
                // Generate a complete level by combining multiple level titles
                generateLevel(levelNumber, difficulty = 1) {
                    try {
                        this.currentLevel = levelNumber;
                        
                        logDebug(`Generating level ${levelNumber} with difficulty ${difficulty}`);
                        
                        // Update level display
                        const levelDisplay = document.getElementById('level-display');
                        if (levelDisplay) {
                            levelDisplay.textContent = `LEVEL ${levelNumber}`;
                        }
                        
                        // Build the complete level by combining titles horizontally
                        // Each level title is a 2D array of ASCII characters
                        
                        // Start with a base set of empty rows
                        const maxHeight = 6; // All our sections are 6 rows tall
                        
                        // Initialize the combined level with empty rows
                        const combinedLevel = [];
                        for (let i = 0; i < maxHeight; i++) {
                            combinedLevel.push([]);
                        }
                        
                        // Function to append a title's layout to the combined level
                        const appendTitle = (title) => {
                            // For each row in the title's layout
                            for (let rowIndex = 0; rowIndex < title.length; rowIndex++) {
                                // Get the row string and convert to array of characters
                                const rowChars = title[rowIndex].split('');
                                
                                // Append these characters to the corresponding row in the combined level
                                combinedLevel[rowIndex] = combinedLevel[rowIndex].concat(rowChars);
                            }
                        };
                        
                        // Always start with the 'start' title
                        appendTitle(this.levelTitles['start']);
                        
                        // Add some middle sections based on the level number
                        // Select sections appropriate to this level
                        const middleSections = [];
                        
                        // Add standard title sections
                        middleSections.push(this.levelTitles[`title${levelNumber}`]);
                        
                        // Add a jump section for variety
                        middleSections.push(this.levelTitles[`jump${Math.min(levelNumber, 3)}`]);
                        
                        // Add another standard title section 
                        const altTitleNum = ((levelNumber + 2) % 10) + 1; // Different title than the first
                        middleSections.push(this.levelTitles[`title${altTitleNum}`]);
                        
                        // For higher levels, add special or gap sections
                        if (levelNumber > 2) {
                            // Add a special coin section
                            middleSections.push(this.levelTitles['special1']);
                            
                            // Add a gap section for challenge
                            const gapNum = Math.min(levelNumber - 2, 3);
                            middleSections.push(this.levelTitles[`gap${gapNum}`]);
                        }
                        
                        // Add one more standard section before the end
                        const finalTitleNum = ((levelNumber + 4) % 10) + 1;
                        middleSections.push(this.levelTitles[`title${finalTitleNum}`]);
                        
                        // Append all middle sections
                        middleSections.forEach(section => {
                            appendTitle(section);
                        });
                        
                        // Always end with the 'end' title
                        appendTitle(this.levelTitles['end']);
                        
                        // Convert the 2D array back to a string format
                        const levelString = combinedLevel.map(row => row.join('')).join('\n');
                        
                        logDebug("Level generation complete");
                        return levelString;
                    } catch (error) {
                        logDebug("Error generating level: " + error.message);
                        // Return a simple fallback level if generation fails
                        return "...........\n...........\n...........\n...........\n....S......\n...........\nBBBBBBBBBBB\n...........";
                    }
                }
            }

            // Main game class
            class Game {
                constructor() {
                    logDebug("Initializing game...");
                    
                    // UI elements
                    this.scoreDisplay = document.getElementById('score-display');
                    this.pauseBtn = document.getElementById('pause-btn');
                    this.gameOverUI = document.getElementById('game-over');
                    this.finalScore = document.getElementById('final-score');
                    this.retryBtn = document.getElementById('retry-btn');
                    
                    // Event listeners
                    this.pauseBtn.addEventListener('click', () => this.togglePause());
                    this.retryBtn.addEventListener('click', () => this.restart());
                    window.addEventListener('keydown', this.handleKeyDown.bind(this));
                    window.addEventListener('resize', this.handleResize.bind(this));
                    
                    // Game properties
                    this.isRunning = false;
                    this.isPaused = false;
                    this.score = 0;
                    this.playerSize = 1;
                    this.speed = 10;
                    this.jumpForce = 15;
                    this.gravity = 25;
                    this.groundY = -8;
                    
                    // Portal
                    this.portal = null;
                    this.portalPosition = { x: 0, y: 0 };
                    
                    // Level themes - colors for different levels
                    this.themes = [
                        { // Level 1 - Cyan (Default)
                            background: 0x0A0A55,
                            grid: 0x1144AA,
                            player: 0x00FFFF,
                            platform: 0x000033,
                            platformEdge: 0x00FFFF,
                            obstacle: 0x40FFFF,
                            collectible: 0xFFFF00,
                            portal: 0x00FFFF
                        },
                        { // Level 2 - Purple
                            background: 0x110033,
                            grid: 0x4400AA, 
                            player: 0xFF00FF,
                            platform: 0x220033,
                            platformEdge: 0xFF00FF,
                            obstacle: 0xFF00AA,
                            collectible: 0xFFFF00,
                            portal: 0xFF00FF
                        },
                        { // Level 3 - Green
                            background: 0x002222,
                            grid: 0x006644,
                            player: 0x00FF88,
                            platform: 0x003322,
                            platformEdge: 0x00FF88,
                            obstacle: 0x00CC66,
                            collectible: 0xFFFF00, 
                            portal: 0x00FF88
                        },
                        { // Level 4 - Orange
                            background: 0x221100,
                            grid: 0x663300,
                            player: 0xFF6600,
                            platform: 0x331100,
                            platformEdge: 0xFF6600,
                            obstacle: 0xFF8800,
                            collectible: 0xFFFF00,
                            portal: 0xFF6600
                        },
                        { // Level 5 - Blue
                            background: 0x000033,
                            grid: 0x0033CC,
                            player: 0x3399FF,
                            platform: 0x000044,
                            platformEdge: 0x3399FF,
                            obstacle: 0x0066FF,
                            collectible: 0xFFFF00,
                            portal: 0x3399FF
                        }
                    ];
                    
                    // Colors - will be set based on current theme
                    this.colors = {
                        background: 0x000033,
                        player: 0x00FFFF,
                        platform: 0x0066FF,
                        obstacle: 0xFF00FF,
                        collectible: 0xFFFF00
                    };
                    
                    // Level manager
                    this.levelManager = new LevelManager(this);
                    
                    // Initialize the game
                    this.init();
                }
                
                async init() {
                    try {
                        // Initialize level manager
                        await this.levelManager.initialize();
                        
                        // Create renderer
                        this.renderer = new THREE.WebGLRenderer({ antialias: true });
                        this.renderer.setSize(window.innerWidth, window.innerHeight);
                        document.body.appendChild(this.renderer.domElement);
                        
                        // Create scene
                        this.scene = new THREE.Scene();
                        this.scene.background = new THREE.Color(0x0A0A55); // Deeper blue like in the image
                        
                        // Create camera
                        const aspectRatio = window.innerWidth / window.innerHeight;
                        const cameraHeight = 20;
                        const cameraWidth = cameraHeight * aspectRatio;
                        this.camera = new THREE.OrthographicCamera(
                            -cameraWidth / 2, cameraWidth / 2,
                            cameraHeight / 2, -cameraHeight / 2,
                            0.1, 1000
                        );
                        this.camera.position.z = 10;
                        
                        // Add light
                        const light = new THREE.AmbientLight(0xFFFFFF, 1);
                        this.scene.add(light);
                        
                        // Create Tron grid
                        this.createGrid();
                        
                        // Create player
                        this.createPlayer();
                        
                        // Create level
                        this.createLevel();
                        
                        // Start animation loop
                        this.isRunning = true;
                        this.lastTime = performance.now();
                        this.animate();
                        
                        logDebug("Game initialized successfully");
                    } catch (error) {
                        logDebug("Error initializing game: " + error.message);
                    }
                }
                
                createGrid() {
                    // Grid size and properties
                    const gridSize = 1000;
                    const gridDivisions = 200; // Increased from 100 for more grid lines
                    const gridColor = 0x1144AA; // Darker blue grid lines to match image
                    
                    // Create grid with lines
                    const gridHelper = new THREE.GridHelper(gridSize, gridDivisions, gridColor, gridColor);
                    gridHelper.position.y = this.groundY - 0.4; // Slightly below ground
                    gridHelper.material.transparent = true;
                    gridHelper.material.opacity = 0.3; // Increased from 0.2 for better visibility
                    gridHelper.material.blending = THREE.AdditiveBlending;
                    this.scene.add(gridHelper);
                    
                    // Rotate grid to make it horizontal
                    gridHelper.rotation.x = Math.PI / 2;
                    
                    // Add a second grid with different sizing for a more complex grid pattern
                    const secondaryGridSize = 500;
                    const secondaryGridDivisions = 50;
                    const secondaryGridColor = 0x2266CC; // Slightly brighter blue for contrast
                    
                    const secondaryGridHelper = new THREE.GridHelper(secondaryGridSize, secondaryGridDivisions, secondaryGridColor, secondaryGridColor);
                    secondaryGridHelper.position.y = this.groundY - 0.39; // Slightly above the main grid
                    secondaryGridHelper.material.transparent = true;
                    secondaryGridHelper.material.opacity = 0.4;
                    secondaryGridHelper.material.blending = THREE.AdditiveBlending;
                    this.scene.add(secondaryGridHelper);
                    
                    // Rotate the secondary grid
                    secondaryGridHelper.rotation.x = Math.PI / 2;
                    
                    // Add a plane with a grid texture for additional effect
                    const gridPlaneGeometry = new THREE.PlaneGeometry(gridSize, gridSize);
                    const gridPlaneMaterial = new THREE.MeshBasicMaterial({
                        color: 0x0A0A44, // Very dark blue background
                        transparent: true,
                        opacity: 0.9
                    });
                    const gridPlane = new THREE.Mesh(gridPlaneGeometry, gridPlaneMaterial);
                    gridPlane.position.y = this.groundY - 0.45; // Just below the grid
                    gridPlane.rotation.x = -Math.PI / 2;
                    this.scene.add(gridPlane);
                }
                
                createPlayer() {
                    // Get current theme colors
                    const themeIndex = (this.levelManager.currentLevel - 1) % this.themes.length;
                    const theme = this.themes[themeIndex];
                    
                    // Create a composite player object to match the reference image
                    this.player = new THREE.Group();
                    this.player.position.set(-5, this.groundY + this.playerSize/2 + 0.5, 0);
                    this.scene.add(this.player);
                    
                    // Create the main square shape without rotation (matches image)
                    const mainGeometry = new THREE.BoxGeometry(this.playerSize, this.playerSize, this.playerSize * 0.5);
                    const mainMaterial = new THREE.MeshBasicMaterial({ 
                        color: theme.player,
                        transparent: true,
                        opacity: 0.9
                    });
                    const mainMesh = new THREE.Mesh(mainGeometry, mainMaterial);
                    // No rotation - keep as square
                    this.player.add(mainMesh);
                    this.playerMainMesh = mainMesh;
                    
                    // Create inner box
                    const innerGeometry = new THREE.BoxGeometry(this.playerSize * 0.6, this.playerSize * 0.6, this.playerSize * 0.5);
                    const innerMaterial = new THREE.MeshBasicMaterial({ 
                        color: theme.player, 
                        transparent: true,
                        opacity: 0.9
                    });
                    const innerMesh = new THREE.Mesh(innerGeometry, innerMaterial);
                    this.player.add(innerMesh);
                    
                    // Add bright center point
                    const centerGeometry = new THREE.BoxGeometry(this.playerSize * 0.2, this.playerSize * 0.2, this.playerSize * 0.2);
                    const centerMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xFFFFFF,
                        transparent: false
                    });
                    const centerMesh = new THREE.Mesh(centerGeometry, centerMaterial);
                    this.player.add(centerMesh);
                    
                    // Add edge lines 
                    const edges = new THREE.EdgesGeometry(mainGeometry);
                    const lineMaterial = new THREE.LineBasicMaterial({ 
                        color: theme.player, 
                        linewidth: 2
                    });
                    const wireframe = new THREE.LineSegments(edges, lineMaterial);
                    this.player.add(wireframe);
                    
                    // Create outer glow
                    const glowGeometry = new THREE.BoxGeometry(
                        this.playerSize * 1.3, 
                        this.playerSize * 1.3, 
                        this.playerSize * 0.5
                    );
                    const glowMaterial = new THREE.MeshBasicMaterial({
                        color: theme.player,
                        transparent: true,
                        opacity: 0.3,
                        blending: THREE.AdditiveBlending
                    });
                    const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
                    this.player.add(glowMesh);
                    this.playerGlow = glowMesh;
                    
                    // Trail particles have been removed per request
                    this.trailParticles = null;
                    
                    // Initialize jump particle system
                    this.jumpParticles = [];
                    this.jumpPath = null;
                    this.jumpHistoryPoints = [];
                    
                    // Player physics
                    this.playerVelocity = { x: 5, y: 0 }; // Set x velocity to 5 to move forward
                    this.isJumping = false;
                    this.onGround = false;
                    
                    // Initialize level display
                    this.levelDisplay = document.getElementById('level-display');
                    
                    logDebug("Player created with Tron-like appearance");
                }
                
                // Create jump particles effect
                createJumpParticles() {
                    // Clear any existing jump particles
                    this.jumpParticles.forEach(particle => {
                        this.scene.remove(particle);
                    });
                    this.jumpParticles = [];
                    
                    // Create new particles
                    const particleCount = 10;
                    for (let i = 0; i < particleCount; i++) {
                        const size = 0.1 + Math.random() * 0.2;
                        const particleGeometry = new THREE.BoxGeometry(size, size, size);
                        const particleMaterial = new THREE.MeshBasicMaterial({
                            color: 0x40FFFF,
                            transparent: true,
                            opacity: 0.7,
                            blending: THREE.AdditiveBlending
                        });
                        
                        const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                        
                        // Position around player's feet
                        const angle = Math.random() * Math.PI * 2;
                        const radius = 0.3 + Math.random() * 0.3;
                        const offsetX = Math.cos(angle) * radius;
                        const offsetY = Math.sin(angle) * radius;
                        
                        particle.position.set(
                            this.player.position.x + offsetX,
                            this.player.position.y - this.playerSize/2 + offsetY,
                            0
                        );
                        
                        // Add velocity for animation
                        particle.userData.velocityX = offsetX * 2;
                        particle.userData.velocityY = 2 + Math.random() * 3;
                        particle.userData.life = 1.0; // Full life
                        
                        this.scene.add(particle);
                        this.jumpParticles.push(particle);
                    }
                    
                    // Reset jump path tracking
                    this.jumpHistoryPoints = [];
                    this.jumpHistoryPoints.push(new THREE.Vector3(
                        this.player.position.x,
                        this.player.position.y,
                        0
                    ));
                    
                    // Remove any existing jump path
                    if (this.jumpPath) {
                        this.scene.remove(this.jumpPath);
                        this.jumpPath = null;
                    }
                }
                
                // Update jump path visualization
                updateJumpPath() {
                    // Add current position to jump history
                    this.jumpHistoryPoints.push(new THREE.Vector3(
                        this.player.position.x,
                        this.player.position.y,
                        0
                    ));
                    
                    // Keep only the recent history (last 20 points)
                    if (this.jumpHistoryPoints.length > 20) {
                        this.jumpHistoryPoints.shift();
                    }
                    
                    // Remove existing path
                    if (this.jumpPath) {
                        this.scene.remove(this.jumpPath);
                    }
                    
                    // Create curve from points
                    const curve = new THREE.CatmullRomCurve3(this.jumpHistoryPoints);
                    
                    // Instead of a basic line, create a variable-width tube
                    // First, create points along the curve
                    const numPoints = 50;
                    const points = curve.getPoints(numPoints);
                    
                    // Create a custom geometry for the variable-width path
                    const pathGeometry = new THREE.BufferGeometry();
                    const positions = [];
                    const indices = [];
                    
                    // Create a ribbon-like geometry with varying width
                    for (let i = 0; i < points.length; i++) {
                        const point = points[i];
                        
                        // Calculate width factor - thicker near the player (end of the curve)
                        // and thinner away from the player (start of the curve)
                        const widthFactor = i / points.length; // 0 at start, 1 at end (near player)
                        const width = 0.05 + widthFactor * 0.2; // Thin to thick
                        
                        // For each point, create two vertices perpendicular to the curve
                        let tangent;
                        if (i < points.length - 1) {
                            // Calculate tangent based on current and next point
                            tangent = new THREE.Vector3().subVectors(points[i + 1], point).normalize();
                        } else {
                            // For the last point, use the previous tangent
                            tangent = new THREE.Vector3().subVectors(point, points[i - 1]).normalize();
                        }
                        
                        // Create perpendicular vector (for 2D curve in XY plane)
                        const normal = new THREE.Vector3(-tangent.y, tangent.x, 0).normalize();
                        
                        // Create vertices on both sides of the curve
                        const v1 = new THREE.Vector3().addVectors(point, normal.clone().multiplyScalar(width));
                        const v2 = new THREE.Vector3().subVectors(point, normal.clone().multiplyScalar(width));
                        
                        // Add positions
                        positions.push(v1.x, v1.y, v1.z);
                        positions.push(v2.x, v2.y, v2.z);
                        
                        // Add indices to create triangles (except for the first point)
                        if (i > 0) {
                            const base = (i - 1) * 2;
                            indices.push(base, base + 1, base + 2); // First triangle
                            indices.push(base + 1, base + 3, base + 2); // Second triangle
                        }
                    }
                    
                    // Set attributes for the geometry
                    pathGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                    pathGeometry.setIndex(indices);
                    
                    // Create path material with fade effect
                    const pathMaterial = new THREE.MeshBasicMaterial({
                        color: 0x00FFFF,
                        transparent: true,
                        opacity: 0.6,
                        blending: THREE.AdditiveBlending,
                        side: THREE.DoubleSide
                    });
                    
                    // Create the path as a mesh
                    this.jumpPath = new THREE.Mesh(pathGeometry, pathMaterial);
                    this.scene.add(this.jumpPath);
                }
                
                createLevel() {
                    logDebug("Creating level...");
                    
                    // Clear existing level objects
                    if (this.platforms) {
                        this.platforms.forEach(platform => this.scene.remove(platform));
                    }
                    if (this.obstacles) {
                        this.obstacles.forEach(obstacle => this.scene.remove(obstacle));
                    }
                    if (this.collectibles) {
                        this.collectibles.forEach(coin => this.scene.remove(coin));
                    }
                    if (this.portal) {
                        this.scene.remove(this.portal);
                        this.portal = null;
                    }
                    
                    // Reset collections
                    this.platforms = [];
                    this.obstacles = [];
                    this.collectibles = [];
                    
                    // Get current theme
                    const themeIndex = (this.levelManager.currentLevel - 1) % this.themes.length;
                    const theme = this.themes[themeIndex];
                    
                    // Update scene background to match theme
                    this.scene.background = new THREE.Color(theme.background);
                    
                    // Create ground - darker with bright outline like in the image
                    const groundGeometry = new THREE.BoxGeometry(100, 0.5, 1);
                    const groundMaterial = new THREE.MeshBasicMaterial({ 
                        color: theme.platform, 
                        transparent: true,
                        opacity: 0.6
                    });
                    this.ground = new THREE.Mesh(groundGeometry, groundMaterial);
                    this.ground.position.set(0, this.groundY, 0);
                    this.scene.add(this.ground);
                    this.platforms.push(this.ground);
                    
                    // Add glow effect to ground
                    const groundEdges = new THREE.EdgesGeometry(groundGeometry);
                    const groundLineMaterial = new THREE.LineBasicMaterial({ 
                        color: theme.platformEdge, 
                        linewidth: 2
                    });
                    const groundWireframe = new THREE.LineSegments(groundEdges, groundLineMaterial);
                    this.ground.add(groundWireframe);
                    
                    // Add subtle glow at ground level
                    const groundGlowGeometry = new THREE.BoxGeometry(100, 0.05, 1.5);
                    const groundGlowMaterial = new THREE.MeshBasicMaterial({
                        color: theme.platformEdge,
                        transparent: true,
                        opacity: 0.15,
                        blending: THREE.AdditiveBlending
                    });
                    const groundGlow = new THREE.Mesh(groundGlowGeometry, groundGlowMaterial);
                    groundGlow.position.y = 0.3; // Slightly above the ground
                    this.ground.add(groundGlow);
                    
                    // Update grid colors
                    if (this.scene.children) {
                        this.scene.children.forEach(child => {
                            if (child instanceof THREE.GridHelper) {
                                // Remove old grid
                                this.scene.remove(child);
                            }
                        });
                    }
                    
                    // Create new grid with theme colors
                    const gridSize = 1000;
                    const gridDivisions = 200;
                    const gridColor = theme.grid;
                    
                    const gridHelper = new THREE.GridHelper(gridSize, gridDivisions, gridColor, gridColor);
                    gridHelper.position.y = this.groundY - 0.4; // Slightly below ground
                    gridHelper.material.transparent = true;
                    gridHelper.material.opacity = 0.3;
                    gridHelper.material.blending = THREE.AdditiveBlending;
                    this.scene.add(gridHelper);
                    
                    // Rotate grid to make it horizontal
                    gridHelper.rotation.x = Math.PI / 2;
                    
                    // Add a second grid with different sizing for a more complex grid pattern
                    const secondaryGridSize = 500;
                    const secondaryGridDivisions = 50;
                    const secondaryGridColor = gridColor;
                    
                    const secondaryGridHelper = new THREE.GridHelper(secondaryGridSize, secondaryGridDivisions, secondaryGridColor, secondaryGridColor);
                    secondaryGridHelper.position.y = this.groundY - 0.39; // Slightly above the main grid
                    secondaryGridHelper.material.transparent = true;
                    secondaryGridHelper.material.opacity = 0.4;
                    secondaryGridHelper.material.blending = THREE.AdditiveBlending;
                    this.scene.add(secondaryGridHelper);
                    
                    // Rotate the secondary grid
                    secondaryGridHelper.rotation.x = Math.PI / 2;
                    
                    // Generate level from level manager
                    const levelData = this.levelManager.generateLevel(this.levelManager.currentLevel, 2);
                    this.parseLevel(levelData);
                    
                    // Ensure we have at least some spikes for testing if none were created from level data
                    if (this.obstacles.length === 0) {
                        logDebug("No obstacles created from level data. Adding test spikes.");
                        this.createTestSpikes();
                    }
                    
                    logDebug("Level created with Tron-like effects");
                }
                
                // Create test spikes if no spikes are being created from level data
                createTestSpikes() {
                    // Add some test spikes at positions with appropriate spacing
                    const testPositions = [];
                    
                    // Start position
                    let posX = 0;
                    
                    // Create 8 test spikes with varied spacing
                    for (let i = 0; i < 8; i++) {
                        // Add small random variation to y position
                        const posY = this.groundY + 0.5 + (Math.random() * 0.1);
                        
                        // Add to positions
                        testPositions.push({ x: posX, y: posY });
                        
                        // Vary spacing between spikes (1.5 to 2.5 units)
                        posX += 1.5 + Math.random();
                    }
                    
                    // Create a second row of spikes further ahead
                    posX = 20;
                    for (let i = 0; i < 5; i++) {
                        const posY = this.groundY + 0.5 + (Math.random() * 0.1);
                        testPositions.push({ x: posX, y: posY });
                        posX += 1.3 + Math.random() * 1.2;
                    }
                    
                    // Create a cluster of 3 spikes together
                    const clusterX = 35;
                    testPositions.push(
                        { x: clusterX, y: this.groundY + 0.5 },
                        { x: clusterX + 1.2, y: this.groundY + 0.5 },
                        { x: clusterX + 2.4, y: this.groundY + 0.5 }
                    );
                    
                    // Create each test spike
                    const createdSpikes = [];
                    testPositions.forEach(pos => {
                        const spike = this.createSpikeAt(pos.x, pos.y);
                        createdSpikes.push(spike);
                    });
                    
                    logDebug(`Created ${testPositions.length} test spikes with varied spacing`);
                }
                
                parseLevel(levelData) {
                    const rows = levelData.split("\n");
                    
                    // Position tracking
                    let xPos = -40; // Start position
                    const tileSize = 2; // Size of each tile
                    
                    // Track spike positions for clustering
                    const spikes = [];
                    
                    // First pass - collect spike positions
                    for (let col = 0; col < rows[0].length; col++) {
                        for (let row = 0; row < rows.length; row++) {
                            // Invert row to make bottom row the ground level
                            const invertedRow = rows.length - 1 - row;
                            
                            // Get the character at this position
                            const char = rows[invertedRow][col];
                            
                            // Calculate y position - ensure everything starts from the ground level up
                            const yPos = this.groundY + 0.5 + row * tileSize;
                            
                            // Track spike positions
                            if (char === '^') {
                                spikes.push({ x: xPos, y: yPos });
                                logDebug(`Found spike at position: ${xPos}, ${yPos}`);
                            }
                        }
                        
                        // Move to the next column
                        xPos += tileSize;
                    }
                    
                    // Reset position for actual creation
                    xPos = -40;
                    
                    // Cluster the spikes
                    const clusteredSpikes = this.clusterSpikes(spikes);
                    
                    // Second pass - create level elements
                    for (let col = 0; col < rows[0].length; col++) {
                        for (let row = 0; row < rows.length; row++) {
                            // Invert row to make bottom row the ground level
                            const invertedRow = rows.length - 1 - row;
                            
                            // Get the character at this position
                            const char = rows[invertedRow][col];
                            
                            // Calculate y position - ensure everything starts from the ground level up
                            const yPos = this.groundY + 0.5 + row * tileSize;
                            
                            // Skip spike creation here as we'll handle it separately
                            if (char !== '^') {
                                this.createTile(char, xPos, yPos);
                            }
                        }
                        
                        // Move to the next column
                        xPos += tileSize;
                    }
                    
                    // Create clustered spikes
                    this.createSpikesClusters(clusteredSpikes);
                }
                
                // Cluster the spikes
                clusterSpikes(spikes) {
                    // This function is no longer needed - spikes have been removed
                    return [];
                }
                
                // Adjust spike positions to prevent intersections
                adjustSpikePositions(cluster) {
                    // This function is no longer needed - spikes have been removed
                    return [];
                }
                
                // Create spike clusters
                createSpikesClusters(clusters) {
                    // This function is no longer needed - spikes have been removed
                }
                
                // Create a single spike at the specified position
                createSpikeAt(x, y) {
                    // This function is no longer needed - spikes have been removed
                    return null;
                }
                
                handleKeyDown(event) {
                    if ((event.code === 'Space' || event.code === 'ArrowUp') && !this.isJumping && (this.onGround || this.onPlatform)) {
                        this.playerVelocity.y = this.jumpForce;
                        this.isJumping = true;
                        this.onGround = false;
                        this.onPlatform = false;
                        
                        // Create jump particles and start path tracking
                        this.createJumpParticles();
                    }
                    
                    // Increase speed when right arrow is pressed
                    if (event.code === 'ArrowRight') {
                        this.playerVelocity.x = 10; // Double speed temporarily
                        setTimeout(() => {
                            if (this.isRunning) this.playerVelocity.x = 5; // Return to normal speed after 0.5 seconds
                        }, 500);
                    }
                    
                    if (event.code === 'KeyP' || event.code === 'Escape') {
                        this.togglePause();
                    }
                }
                
                handleResize() {
                    const width = window.innerWidth;
                    const height = window.innerHeight;
                    
                    this.renderer.setSize(width, height);
                    
                    const aspectRatio = width / height;
                    const cameraHeight = 20;
                    const cameraWidth = cameraHeight * aspectRatio;
                    
                    this.camera.left = -cameraWidth / 2;
                    this.camera.right = cameraWidth / 2;
                    this.camera.top = cameraHeight / 2;
                    this.camera.bottom = -cameraHeight / 2;
                    this.camera.updateProjectionMatrix();
                }
                
                togglePause() {
                    this.isPaused = !this.isPaused;
                    logDebug("Game " + (this.isPaused ? "paused" : "resumed"));
                }
                
                restart() {
                    logDebug("Restarting game");
                    this.score = 0;
                    this.gameOverUI.style.display = 'none';
                    this.isRunning = true;
                    this.isPaused = false;
                    
                    // Reset player
                    this.player.position.set(-5, this.groundY + this.playerSize/2 + 0.5, 0);
                    this.playerVelocity.x = 5;
                    this.playerVelocity.y = 0;
                    this.isJumping = false;
                    
                    // Trail particles have been removed per request
                    
                    // Recreate level
                    this.createLevel();
                    
                    // Update UI
                    this.updateScoreDisplay();
                    this.updateLevelDisplay();
                }
                
                animate() {
                    requestAnimationFrame(this.animate.bind(this));
                    
                    if (!this.isRunning || this.isPaused) return;
                    
                    // Calculate delta time for smooth animation
                    const now = performance.now();
                    const deltaTime = (now - this.lastTime) / 1000; // in seconds
                    this.lastTime = now;
                    
                    // Limit delta time to avoid large jumps
                    const limitedDelta = Math.min(deltaTime, 0.1);
                    
                    // Update game state
                    this.update(limitedDelta);
                    
                    // Render scene
                    this.renderer.render(this.scene, this.camera);
                }
                
                update(deltaTime) {
                    // Apply gravity to player
                    this.playerVelocity.y -= this.gravity * deltaTime;
                    
                    // Limit vertical velocity
                    this.playerVelocity.y = Math.max(this.playerVelocity.y, -30);
                    
                    // Ensure player is always moving forward
                    if (this.playerVelocity.x < 5) {
                        this.playerVelocity.x = 5;
                        logDebug("Restoring forward velocity");
                    }
                    
                    // Update player position
                    this.player.position.x += this.playerVelocity.x * deltaTime;
                    this.player.position.y += this.playerVelocity.y * deltaTime;
                    
                    // Update jump particles
                    if (this.jumpParticles.length > 0) {
                        for (let i = this.jumpParticles.length - 1; i >= 0; i--) {
                            const particle = this.jumpParticles[i];
                            
                            // Update position based on velocity
                            particle.position.x += particle.userData.velocityX * deltaTime;
                            particle.position.y += particle.userData.velocityY * deltaTime;
                            
                            // Apply gravity to particles
                            particle.userData.velocityY -= 15 * deltaTime;
                            
                            // Reduce life
                            particle.userData.life -= deltaTime * 1.5;
                            
                            // Update opacity based on life
                            particle.material.opacity = particle.userData.life * 0.7;
                            
                            // Remove if life is depleted
                            if (particle.userData.life <= 0) {
                                this.scene.remove(particle);
                                this.jumpParticles.splice(i, 1);
                            }
                        }
                    }
                    
                    // Update jump path if jumping
                    if (this.isJumping && this.jumpHistoryPoints.length > 0) {
                        this.updateJumpPath();
                    }
                    
                    // Immediately remove jump path when not jumping
                    if (!this.isJumping && this.jumpPath) {
                        this.scene.remove(this.jumpPath);
                        this.jumpPath = null;
                        this.jumpHistoryPoints = [];
                    }
                    
                    // Trail particles have been removed per request
                    
                    // Ground collision
                    if (this.player.position.y - this.playerSize/2 < this.groundY + 0.5) { // Add a small offset to ensure player is on top
                        this.player.position.y = this.groundY + this.playerSize/2 + 0.5;
                        this.playerVelocity.y = 0;
                        this.isJumping = false;
                        this.onGround = true;
                        
                        // Immediately remove jump path when landing on ground
                        if (this.jumpPath) {
                            this.scene.remove(this.jumpPath);
                            this.jumpPath = null;
                            this.jumpHistoryPoints = [];
                        }
                    } else {
                        this.onGround = false;
                    }
                    
                    // Check collisions
                    this.checkCollisions();
                    
                    // Update portal animations
                    this.updatePortal(deltaTime);
                    
                    // Camera follows player
                    this.camera.position.x = this.player.position.x;
                    
                    // Update UI
                    this.score += deltaTime * 10;
                    this.updateScoreDisplay();
                    
                    // Animate player glow effect
                    if (this.playerGlow) {
                        this.playerGlow.scale.x = 1 + Math.sin(performance.now() * 0.005) * 0.1;
                        this.playerGlow.scale.y = 1 + Math.sin(performance.now() * 0.005) * 0.1;
                        this.playerGlow.scale.z = 1 + Math.sin(performance.now() * 0.005) * 0.1;
                    }
                    
                    // Additional player animation during motion - square player should not rotate
                    if (this.playerMainMesh) {
                        this.playerMainMesh.rotation.z = 0;
                    }
                    
                    // Keep player upright even while jumping (no rotation), matching the image
                    this.player.rotation.z = 0;
                    
                    // Animate other elements with glow effect
                    // Animate jump pads
                    this.platforms.forEach(platform => {
                        if (platform.userData.type === 'jumpPad' && platform.userData.glowMesh) {
                            const glow = platform.userData.glowMesh;
                            glow.scale.x = 1 + Math.sin(performance.now() * 0.01) * 0.2;
                            glow.scale.y = 1 + Math.sin(performance.now() * 0.01) * 0.2;
                            glow.material.opacity = 0.3 + Math.sin(performance.now() * 0.01) * 0.2;
                        }
                    });
                }
                
                checkCollisions() {
                    // Platform collisions
                    this.onPlatform = false;
                    
                    this.platforms.forEach(platform => {
                        if (platform === this.ground) return; // Skip ground platform
                        
                        const playerBottom = this.player.position.y - this.playerSize/2;
                        const playerTop = this.player.position.y + this.playerSize/2;
                        const playerLeft = this.player.position.x - this.playerSize/2;
                        const playerRight = this.player.position.x + this.playerSize/2;
                        
                        const platformWidth = platform.userData.width;
                        const platformHeight = platform.userData.height;
                        const platformTop = platform.position.y + platformHeight/2;
                        const platformBottom = platform.position.y - platformHeight/2;
                        const platformLeft = platform.position.x - platformWidth/2;
                        const platformRight = platform.position.x + platformWidth/2;
                        
                        // Check for collision
                        if (playerRight > platformLeft && playerLeft < platformRight &&
                            playerBottom < platformTop && playerTop > platformBottom) {
                            
                            // Coming from above (landing on platform)
                            if (this.playerVelocity.y < 0 && 
                                playerBottom - this.playerVelocity.y > platformTop - 0.1) { // Add small tolerance
                                
                                // Land on platform
                                this.player.position.y = platformTop + this.playerSize/2 + 0.01; // Small offset to prevent sticking
                                this.playerVelocity.y = 0;
                                this.isJumping = false;
                                this.onPlatform = true;
                                
                                // Immediately remove jump path when landing on platform
                                if (this.jumpPath) {
                                    this.scene.remove(this.jumpPath);
                                    this.jumpPath = null;
                                    this.jumpHistoryPoints = [];
                                }
                                
                                // Check if it's a jump pad
                                if (platform.userData.type === 'jumpPad') {
                                    this.playerVelocity.y = this.jumpForce * 1.5;
                                    this.isJumping = true;
                                    this.onPlatform = false;
                                }
                            }
                            // Hit ceiling
                            else if (this.playerVelocity.y > 0 && 
                                    playerTop - this.playerVelocity.y < platformBottom + 0.1) { // Add small tolerance
                                this.player.position.y = platformBottom - this.playerSize/2 - 0.01; // Small offset
                                this.playerVelocity.y = 0;
                            }
                        }
                    });
                    
                    // Obstacle collisions
                    this.obstacles.forEach(obstacle => {
                        const playerLeft = this.player.position.x - this.playerSize/2;
                        const playerRight = this.player.position.x + this.playerSize/2;
                        const playerBottom = this.player.position.y - this.playerSize/2;
                        const playerTop = this.player.position.y + this.playerSize/2;
                        
                        const obstacleWidth = obstacle.userData.width;
                        const obstacleHeight = obstacle.userData.height;
                        const obstacleLeft = obstacle.position.x - obstacleWidth/2;
                        const obstacleRight = obstacle.position.x + obstacleWidth/2;
                        const obstacleBottom = obstacle.position.y - obstacleHeight/2;
                        const obstacleTop = obstacle.position.y + obstacleHeight/2;
                        
                        // Ensure the obstacle is not below ground or hidden within ground
                        if (obstacleTop <= this.groundY + 0.5) {
                            return; // Skip obstacles that are hidden in the ground
                        }
                        
                        // Check for collision with reduced hitbox for better gameplay feel
                        if (playerRight > obstacleLeft + 0.2 && 
                            playerLeft < obstacleRight - 0.2 &&
                            playerBottom < obstacleTop - 0.2 && 
                            playerTop > obstacleBottom + 0.2) {
                            this.gameOver();
                        }
                    });
                    
                    // Collectible collisions
                    for (let i = this.collectibles.length - 1; i >= 0; i--) {
                        const coin = this.collectibles[i];
                        if (coin.userData.collected) continue;
                        
                        const playerLeft = this.player.position.x - this.playerSize/2;
                        const playerRight = this.player.position.x + this.playerSize/2;
                        const playerBottom = this.player.position.y - this.playerSize/2;
                        const playerTop = this.player.position.y + this.playerSize/2;
                        
                        const coinWidth = coin.userData.width;
                        const coinHeight = coin.userData.height;
                        const coinLeft = coin.position.x - coinWidth/2;
                        const coinRight = coin.position.x + coinWidth/2;
                        const coinBottom = coin.position.y - coinHeight/2;
                        const coinTop = coin.position.y + coinHeight/2;
                        
                        // Check for collision
                        if (playerRight > coinLeft && playerLeft < coinRight &&
                            playerBottom < coinTop && playerTop > coinBottom) {
                            // Collect coin
                            coin.userData.collected = true;
                            this.scene.remove(coin);
                            
                            // Add to score - check for special coin value
                            const coinValue = coin.userData.value || 100;
                            this.score += coinValue;
                            this.updateScoreDisplay();
                        }
                    }
                }
                
                updateScoreDisplay() {
                    this.scoreDisplay.textContent = `SCORE: ${Math.floor(this.score)}`;
                }
                
                updateLevelDisplay() {
                    const levelDisplay = document.getElementById('level-display');
                    if (levelDisplay) {
                        levelDisplay.textContent = `LEVEL ${this.levelManager.currentLevel}`;
                        
                        // Briefly highlight level display with animation when updated
                        levelDisplay.style.animation = 'none';
                        void levelDisplay.offsetWidth; // Trigger reflow
                        levelDisplay.style.animation = 'uiGlow 2s infinite alternate, levelUpdate 0.5s';
                    }
                }
                
                gameOver() {
                    logDebug("Game over");
                    this.isRunning = false;
                    this.finalScore.textContent = `SCORE: ${Math.floor(this.score)}`;
                    this.gameOverUI.style.display = 'block';
                }

                // Create a portal at the given position
                createPortal(x, y) {
                    // Remove any existing portal
                    if (this.portal) {
                        this.scene.remove(this.portal);
                        this.portal = null;
                    }
                    
                    // Get current theme colors
                    const themeIndex = (this.levelManager.currentLevel - 1) % this.themes.length;
                    const theme = this.themes[themeIndex];
                    const portalColor = 0x00FFFF; // Override with bright cyan color from image
                    
                    // Create portal group
                    this.portal = new THREE.Group();
                    this.portal.position.set(x, y, 0);
                    this.portalPosition = { x, y };
                    
                    // Create a slightly elliptical shape for the portal base using a scaled circle
                    const portalRadius = 1.2;
                    const portalDiscGeometry = new THREE.CircleGeometry(portalRadius, 32);
                    const portalDiscMaterial = new THREE.MeshBasicMaterial({
                        color: 0x000022, // Very dark blue, almost black
                        transparent: true,
                        opacity: 0.85,
                        side: THREE.DoubleSide
                    });
                    const portalDisc = new THREE.Mesh(portalDiscGeometry, portalDiscMaterial);
                    portalDisc.rotation.x = Math.PI / 2; // Rotate to face forward
                    portalDisc.scale.set(1, 1.2, 1); // Make slightly elliptical
                    this.portal.add(portalDisc);
                    
                    // Create the main ring/edge of the portal - using a custom approach for better control
                    const ringWidth = 0.15;
                    const segments = 16;
                    const ringGeometry = new THREE.RingGeometry(portalRadius - ringWidth, portalRadius, segments);
                    const ringMaterial = new THREE.MeshBasicMaterial({
                        color: portalColor,
                        transparent: true,
                        opacity: 0.9,
                        side: THREE.DoubleSide
                    });
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    ring.rotation.x = Math.PI / 2;
                    ring.scale.set(1, 1.2, 1); // Match the elliptical shape
                    this.portal.add(ring);
                    
                    // Add dark segments around the edge - more similar to the image
                    const segmentCount = 12;
                    for (let i = 0; i < segmentCount; i++) {
                        const angle = (i / segmentCount) * Math.PI * 2;
                        
                        // Create a rectangular segment with inner and outer parts for glow effect
                        const segmentGeometry = new THREE.BoxGeometry(0.25, 0.25, 0.1);
                        
                        // Core segment - darker version of the portal color
                        const darkerColor = new THREE.Color(portalColor).multiplyScalar(0.4);
                        const segmentMaterial = new THREE.MeshBasicMaterial({
                            color: darkerColor,
                            transparent: true,
                            opacity: 0.9
                        });
                        const segment = new THREE.Mesh(segmentGeometry, segmentMaterial);
                        
                        // Position around the elliptical ring with proper scaling
                        const xPos = Math.cos(angle) * portalRadius;
                        const yPos = Math.sin(angle) * portalRadius * 1.2; // Match elliptical shape
                        segment.position.set(xPos, yPos, 0.05);
                        
                        // Rotate to align with the ring
                        segment.rotation.z = angle + Math.PI/2;
                        
                        // Add glow effect around each segment
                        const glowGeometry = new THREE.BoxGeometry(0.35, 0.35, 0.15);
                        const glowMaterial = new THREE.MeshBasicMaterial({
                            color: portalColor,
                            transparent: true,
                            opacity: 0.5,
                            blending: THREE.AdditiveBlending
                        });
                        const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                        
                        // Store original position for animation
                        segment.userData.originalPos = { x: xPos, y: yPos };
                        segment.userData.angle = angle;
                        segment.userData.glowFactor = 0.7 + Math.random() * 0.6; // Different pulse rates
                        segment.userData.glowPhase = Math.random() * Math.PI * 2; // Different phases
                        
                        segment.add(glow);
                        this.portal.add(segment);
                    }
                    
                    // Create bright edge glow - inner ring
                    const edgeGlowGeometry = new THREE.RingGeometry(portalRadius - ringWidth - 0.05, portalRadius - ringWidth + 0.05, 32);
                    const edgeGlowMaterial = new THREE.MeshBasicMaterial({
                        color: portalColor,
                        transparent: true,
                        opacity: 0.9,
                        side: THREE.DoubleSide,
                        blending: THREE.AdditiveBlending
                    });
                    const edgeGlow = new THREE.Mesh(edgeGlowGeometry, edgeGlowMaterial);
                    edgeGlow.rotation.x = Math.PI / 2;
                    edgeGlow.scale.set(1, 1.2, 1); // Match elliptical shape
                    this.portal.add(edgeGlow);
                    
                    // Create outer glow effect - overall glow
                    const glowGeometry = new THREE.RingGeometry(portalRadius - 0.1, portalRadius + 0.4, 32);
                    const glowMaterial = new THREE.MeshBasicMaterial({
                        color: portalColor,
                        transparent: true,
                        opacity: 0.4,
                        blending: THREE.AdditiveBlending,
                        side: THREE.DoubleSide
                    });
                    const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                    glow.rotation.x = Math.PI / 2;
                    glow.scale.set(1, 1.2, 1); // Match elliptical shape
                    this.portal.add(glow);
                    
                    // Add wide outer glow for the spread effect seen in image
                    const wideGlowGeometry = new THREE.RingGeometry(portalRadius, portalRadius + 0.8, 32);
                    const wideGlowMaterial = new THREE.MeshBasicMaterial({
                        color: portalColor,
                        transparent: true,
                        opacity: 0.2,
                        blending: THREE.AdditiveBlending,
                        side: THREE.DoubleSide
                    });
                    const wideGlow = new THREE.Mesh(wideGlowGeometry, wideGlowMaterial);
                    wideGlow.rotation.x = Math.PI / 2;
                    wideGlow.scale.set(1, 1.2, 1); // Match elliptical shape
                    this.portal.add(wideGlow);
                    
                    // Add square particles similar to the image (more on left side)
                    this.portalParticles = [];
                    const particleCount = 30; // Increase count for more particles
                    
                    for (let i = 0; i < particleCount; i++) {
                        // Create square particles of varying sizes
                        const size = 0.04 + Math.random() * 0.1;
                        const particleGeometry = new THREE.BoxGeometry(size, size, size);
                        const particleMaterial = new THREE.MeshBasicMaterial({
                            color: portalColor,
                            transparent: true,
                            opacity: 0.5 + Math.random() * 0.5,
                            blending: THREE.AdditiveBlending
                        });
                        
                        const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                        
                        // Position with bias towards left side like in the image
                        let angle, radius;
                        const leftSide = Math.random() < 0.7; // 70% chance for left side
                        
                        if (leftSide) {
                            // Left side particles (more concentrated)
                            angle = Math.PI * 0.5 + (Math.random() - 0.5) * Math.PI; // Left side angle range
                            radius = portalRadius * 1.2 + Math.random() * 2.0; // Further from portal
                        } else {
                            // Right side particles (fewer)
                            angle = Math.PI * 1.5 + (Math.random() - 0.5) * Math.PI; // Right side angle range
                            radius = portalRadius * 1.1 + Math.random() * 1.2; // Closer to portal
                        }
                        
                        // Apply position with elliptical adjustment
                        particle.position.x = Math.cos(angle) * radius;
                        particle.position.y = Math.sin(angle) * radius * 1.2; // Match elliptical shape
                        particle.position.z = (Math.random() - 0.5) * 0.2;
                        
                        // Slight random rotation for visual interest
                        particle.rotation.z = Math.random() * Math.PI * 2;
                        
                        // Add movement data for animation
                        particle.userData.angle = angle;
                        particle.userData.radius = radius;
                        particle.userData.speed = 0.1 + Math.random() * 0.2; // Slower, subtle movement
                        particle.userData.pulseSpeed = 0.5 + Math.random() * 0.5;
                        particle.userData.originalSize = size;
                        particle.userData.driftX = (Math.random() - 0.5) * 0.2; // Left-right drift
                        particle.userData.driftY = (Math.random() - 0.5) * 0.2; // Up-down drift
                        
                        this.portal.add(particle);
                        this.portalParticles.push(particle);
                    }
                    
                    // Set portal collision data
                    this.portal.userData = {
                        type: 'portal',
                        width: 2.4,
                        height: 2.8 // Slightly larger for elliptical shape
                    };
                    
                    this.scene.add(this.portal);
                }
                
                // Update portal animations
                updatePortal(deltaTime) {
                    if (!this.portal) return;
                    
                    // Update swirling effects in the portal
                    this.portal.children.forEach(child => {
                        if (child.userData.rotationSpeed) {
                            child.rotation.z += deltaTime * child.userData.rotationSpeed * child.userData.rotationDirection;
                        }
                        
                        // Animate the glowing segments
                        if (child.userData.angle !== undefined) {
                            // Pulse the glow of the segments
                            const time = performance.now() * 0.001;
                            const glowIntensity = 0.5 + 0.4 * Math.sin(time * child.userData.glowFactor + child.userData.glowPhase);
                            
                            // Apply glow effect to the child's first child (the glow mesh)
                            if (child.children.length > 0) {
                                const glowMesh = child.children[0];
                                glowMesh.material.opacity = glowIntensity;
                                
                                // Slightly scale the glow mesh based on intensity
                                const scale = 1 + glowIntensity * 0.2;
                                glowMesh.scale.set(scale, scale, scale);
                                
                                // Subtle movement
                                const wiggle = Math.sin(time * 2 + child.userData.angle) * 0.02;
                                child.position.x = child.userData.originalPos.x + wiggle;
                                child.position.y = child.userData.originalPos.y + wiggle;
                            }
                        }
                    });
                    
                    // Pulse the glow effect
                    const glowFactor = 1 + Math.sin(performance.now() * 0.003) * 0.2;
                    this.portal.children.forEach(child => {
                        if (child.geometry && child.geometry.type.includes("RingGeometry")) {
                            // Pulse the ring geometries for glow effect
                            child.scale.set(glowFactor, glowFactor * 1.2, 1);
                        }
                    });
                    
                    // Update portal particles
                    if (this.portalParticles && this.portalParticles.length > 0) {
                        this.portalParticles.forEach(particle => {
                            // Use a combination of orbital and drift motion for more natural look
                            particle.userData.angle += deltaTime * particle.userData.speed;
                            
                            // Apply drift to position - creates the floating square effect from the image
                            particle.position.x += particle.userData.driftX * deltaTime;
                            particle.position.y += particle.userData.driftY * deltaTime;
                            
                            // Occasionally change drift direction to keep particles near the portal
                            if (Math.random() < 0.01) {
                                particle.userData.driftX = (Math.random() - 0.5) * 0.3;
                                particle.userData.driftY = (Math.random() - 0.5) * 0.3;
                            }
                            
                            // Reset particles that drift too far
                            const distanceFromCenter = Math.sqrt(
                                particle.position.x * particle.position.x + 
                                particle.position.y * particle.position.y
                            );
                            
                            if (distanceFromCenter > 4.0) {
                                // Reset position with bias towards left side like in the image
                                const leftSide = Math.random() < 0.7; // 70% chance for left side
                                
                                if (leftSide) {
                                    // Left side particles (more concentrated)
                                    particle.userData.angle = Math.PI * 0.5 + (Math.random() - 0.5) * Math.PI;
                                    particle.userData.radius = 1.2 * 1.2 + Math.random() * 2.0;
                                } else {
                                    // Right side particles (fewer)
                                    particle.userData.angle = Math.PI * 1.5 + (Math.random() - 0.5) * Math.PI;
                                    particle.userData.radius = 1.2 * 1.1 + Math.random() * 1.2;
                                }
                                
                                // Apply position with elliptical adjustment
                                particle.position.x = Math.cos(particle.userData.angle) * particle.userData.radius;
                                particle.position.y = Math.sin(particle.userData.angle) * particle.userData.radius * 1.2;
                            }
                            
                            // Pulse opacity for subtle glow effect
                            particle.material.opacity = 0.3 + Math.sin(performance.now() * 0.002 * particle.userData.pulseSpeed) * 0.3;
                            
                            // Slight rotation for more dynamic movement
                            particle.rotation.z += deltaTime * particle.userData.speed * 0.5;
                        });
                    }
                    
                    // Check if player has entered the portal
                    if (this.portal && this.portal.userData) {
                        const playerLeft = this.player.position.x - this.playerSize/2;
                        const playerRight = this.player.position.x + this.playerSize/2;
                        const playerBottom = this.player.position.y - this.playerSize/2;
                        const playerTop = this.player.position.y + this.playerSize/2;
                        
                        const portalLeft = this.portal.position.x - this.portal.userData.width/2;
                        const portalRight = this.portal.position.x + this.portal.userData.width/2;
                        const portalBottom = this.portal.position.y - this.portal.userData.height/2;
                        const portalTop = this.portal.position.y + this.portal.userData.height/2;
                        
                        // Check for collision with the portal
                        if (playerRight > portalLeft && 
                            playerLeft < portalRight &&
                            playerBottom < portalTop && 
                            playerTop > portalBottom) {
                            // Player has entered the portal
                            logDebug("Player entered portal - level complete!");
                            
                            // Immediately remove jump path if it exists
                            if (this.jumpPath) {
                                this.scene.remove(this.jumpPath);
                                this.jumpPath = null;
                                this.jumpHistoryPoints = [];
                            }
                            
                            // Clear any jump particles
                            if (this.jumpParticles && this.jumpParticles.length > 0) {
                                this.jumpParticles.forEach(particle => {
                                    this.scene.remove(particle);
                                });
                                this.jumpParticles = [];
                            }
                            
                            // Reset jump state
                            this.isJumping = false;
                            
                            // Go to next level
                            const nextLevelNumber = this.levelManager.nextLevel();
                            
                            // Update level display
                            this.updateLevelDisplay();
                            
                            // Create the new level
                            this.createLevel();
                        }
                    }
                }
                
                // Advance to the next level
                nextLevel() {
                    this.currentLevel++;
                    if (this.currentLevel > this.maxLevels) {
                        this.currentLevel = 1; // Reset to level 1 after completing all levels
                    }
                    return this.currentLevel;
                }

                createTile(type, x, y) {
                    // Get current theme colors
                    const themeIndex = (this.levelManager.currentLevel - 1) % this.themes.length;
                    const theme = this.themes[themeIndex];
                    
                    switch (type) {
                        case 'B': // Block/Platform
                            const platformGeometry = new THREE.BoxGeometry(2, 1, 1);
                            const platformMaterial = new THREE.MeshBasicMaterial({ 
                                color: theme.platform, 
                                transparent: true,
                                opacity: 0.8
                            });
                            const platform = new THREE.Mesh(platformGeometry, platformMaterial);
                            platform.position.set(x, y, 0);
                            platform.userData.type = 'platform';
                            platform.userData.width = 2;
                            platform.userData.height = 1;
                            this.scene.add(platform);
                            this.platforms.push(platform);
                            
                            // Add bright edges glow effect to platforms - themed color
                            const edges = new THREE.EdgesGeometry(platformGeometry);
                            const lineMaterial = new THREE.LineBasicMaterial({ 
                                color: theme.platformEdge, 
                                linewidth: 2
                            });
                            const wireframe = new THREE.LineSegments(edges, lineMaterial);
                            platform.add(wireframe);
                            
                            break;
                            
                        case 'C': // Coin
                            const coinGeometry = new THREE.CircleGeometry(0.5, 16);
                            const coinMaterial = new THREE.MeshBasicMaterial({ 
                                color: theme.collectible,
                                transparent: true,
                                opacity: 0.9,
                                side: THREE.DoubleSide
                            });
                            const coin = new THREE.Mesh(coinGeometry, coinMaterial);
                            coin.position.set(x, y, 0);
                            coin.userData.type = 'coin';
                            coin.userData.width = 1;
                            coin.userData.height = 1;
                            coin.userData.collected = false;
                            this.scene.add(coin);
                            this.collectibles.push(coin);
                            
                            // Add glow effect to coins
                            const coinGlowGeometry = new THREE.CircleGeometry(0.7, 16);
                            const coinGlowMaterial = new THREE.MeshBasicMaterial({
                                color: theme.collectible,
                                transparent: true,
                                opacity: 0.4,
                                blending: THREE.AdditiveBlending,
                                side: THREE.DoubleSide
                            });
                            const coinGlow = new THREE.Mesh(coinGlowGeometry, coinGlowMaterial);
                            coin.add(coinGlow);
                            
                            break;
                            
                        case 'E': // End of level - place portal
                            this.createPortal(x, y + 1);
                            break;
                            
                        case 'J': // Jump pad
                            const jumpPadGeometry = new THREE.BoxGeometry(1.5, 0.5, 1);
                            const jumpPadMaterial = new THREE.MeshBasicMaterial({ 
                                color: theme.collectible,
                                transparent: true,
                                opacity: 0.8
                            });
                            const jumpPad = new THREE.Mesh(jumpPadGeometry, jumpPadMaterial);
                            jumpPad.position.set(x, y, 0);
                            jumpPad.userData.type = 'jumpPad';
                            jumpPad.userData.width = 1.5;
                            jumpPad.userData.height = 0.5;
                            this.scene.add(jumpPad);
                            this.platforms.push(jumpPad);
                            
                            // Add edges glow effect to jump pads
                            const jumpPadEdges = new THREE.EdgesGeometry(jumpPadGeometry);
                            const jumpPadLineMaterial = new THREE.LineBasicMaterial({ 
                                color: theme.collectible, 
                                linewidth: 2
                            });
                            const jumpPadWireframe = new THREE.LineSegments(jumpPadEdges, jumpPadLineMaterial);
                            jumpPad.add(jumpPadWireframe);
                            
                            // Add pulse glow effect
                            const jumpPadGlowGeometry = new THREE.BoxGeometry(1.7, 0.7, 1.2);
                            const jumpPadGlowMaterial = new THREE.MeshBasicMaterial({
                                color: theme.collectible,
                                transparent: true,
                                opacity: 0.4,
                                blending: THREE.AdditiveBlending
                            });
                            const jumpPadGlow = new THREE.Mesh(jumpPadGlowGeometry, jumpPadGlowMaterial);
                            jumpPad.add(jumpPadGlow);
                            
                            // Store the glow mesh for animation
                            jumpPad.userData.glowMesh = jumpPadGlow;
                            break;
                            
                        case 'P': // Special collectible
                            const specialCoinGeometry = new THREE.CircleGeometry(0.7, 16);
                            const specialCoinMaterial = new THREE.MeshBasicMaterial({ 
                                color: 0x00FFAA, // Special teal-colored coin
                                transparent: true,
                                opacity: 0.9,
                                side: THREE.DoubleSide
                            });
                            const specialCoin = new THREE.Mesh(specialCoinGeometry, specialCoinMaterial);
                            specialCoin.position.set(x, y, 0);
                            specialCoin.userData.type = 'coin';
                            specialCoin.userData.width = 1.4;
                            specialCoin.userData.height = 1.4;
                            specialCoin.userData.collected = false;
                            // Special coin worth more points
                            specialCoin.userData.value = 500;
                            this.scene.add(specialCoin);
                            this.collectibles.push(specialCoin);
                            
                            // Add glow effect to special coin
                            const specialCoinGlowGeometry = new THREE.CircleGeometry(1, 16);
                            const specialCoinGlowMaterial = new THREE.MeshBasicMaterial({
                                color: 0x00FFAA,
                                transparent: true,
                                opacity: 0.4,
                                blending: THREE.AdditiveBlending,
                                side: THREE.DoubleSide
                            });
                            const specialCoinGlow = new THREE.Mesh(specialCoinGlowGeometry, specialCoinGlowMaterial);
                            specialCoin.add(specialCoinGlow);
                            break;
                            
                        case 'S': // Start position
                            // Move player to start position
                            if (this.player) {
                                // Position player above the ground/marker with proper offset
                                this.player.position.set(x, y + this.playerSize/2 + 0.1, 0);
                            }
                            break;
                    }
                }
            }

            // Initialize the game
            const game = new Game();
            
            // Keep debug console visible longer
            setTimeout(() => {
                const debugConsole = document.getElementById('debug-console');
                if (debugConsole) {
                    debugConsole.style.display = 'none';
                }
            }, 10000); // Show for 10 seconds instead of 3
            
            // Add keyboard control instructions
            logDebug("CONTROLS: Press SPACE or UP ARROW to jump");
            logDebug("Press RIGHT ARROW for temporary speed boost");
            logDebug("Game automatically moves forward");
            logDebug("Avoid spikes and collect coins!");
        }
    </script>
</body>
</html> 