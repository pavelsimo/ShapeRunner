<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ShapeRunner</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Rajdhani:wght@500;700&display=swap');
        
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Orbitron', 'Rajdhani', sans-serif;
            color: #00FFFF;
        }
        
        canvas {
            display: block;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 10;
        }
        
        #score-display {
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px 15px;
            border: 2px solid var(--theme-color, #00FFFF);
            border-radius: 4px;
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            box-shadow: 0 0 10px var(--theme-color, #00FFFF), inset 0 0 5px var(--theme-color, #00FFFF);
            text-shadow: 0 0 5px var(--theme-color, #00FFFF);
            margin-bottom: 15px;
            display: inline-block;
            transition: all 0.2s ease;
            letter-spacing: 1px;
            animation: uiGlow 2s infinite alternate;
            color: var(--theme-color, #00FFFF);
        }
        
        #score-display:hover {
            box-shadow: 0 0 15px var(--theme-color, #00FFFF), inset 0 0 8px var(--theme-color, #00FFFF);
        }
        
        #level-display {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px 15px;
            border: 2px solid var(--theme-color, #00FFFF);
            border-radius: 4px;
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            box-shadow: 0 0 10px var(--theme-color, #00FFFF), inset 0 0 5px var(--theme-color, #00FFFF);
            text-shadow: 0 0 5px var(--theme-color, #00FFFF);
            letter-spacing: 1px;
            z-index: 100;
            transition: all 0.2s ease;
            animation: uiGlow 2s infinite alternate;
            color: var(--theme-color, #00FFFF);
        }
        
        #level-display:hover {
            box-shadow: 0 0 15px var(--theme-color, #00FFFF), inset 0 0 8px var(--theme-color, #00FFFF);
        }
        
        @keyframes uiGlow {
            from {
                box-shadow: 0 0 10px var(--theme-color, #00FFFF), inset 0 0 5px var(--theme-color, #00FFFF);
                text-shadow: 0 0 5px var(--theme-color, #00FFFF);
            }
            to {
                box-shadow: 0 0 15px var(--theme-color, #00FFFF), inset 0 0 8px var(--theme-color, #00FFFF);
                text-shadow: 0 0 8px var(--theme-color, #00FFFF);
            }
        }
        
        @keyframes levelUpdate {
            0% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.2); }
            100% { transform: translateX(-50%) scale(1); }
        }
        
        #pause-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 40px;
            height: 40px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 2px solid var(--theme-color, #00FFFF);
            border-radius: 4px;
            cursor: pointer;
            box-shadow: 0 0 10px var(--theme-color, #00FFFF), inset 0 0 5px var(--theme-color, #00FFFF);
            transition: all 0.2s ease;
            z-index: 100;
            animation: uiGlow 2s infinite alternate;
        }
        
        #pause-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 15px var(--theme-color, #00FFFF), inset 0 0 10px var(--theme-color, #00FFFF);
        }
        
        #pause-btn:active {
            transform: scale(0.95);
        }
        
        #pause-btn div {
            width: 5px;
            height: 20px;
            background-color: var(--theme-color, #00FFFF);
            margin: 0 3px;
            border-radius: 2px;
            box-shadow: 0 0 5px var(--theme-color, #00FFFF);
        }
        
        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background-color: rgba(0, 0, 0, 0.8);
            border: 2px solid var(--theme-color, #00FFFF);
            border-radius: 8px;
            padding: 20px 40px;
            box-shadow: 0 0 20px var(--theme-color, #00FFFF), inset 0 0 10px var(--theme-color, #00FFFF);
            display: none;
            z-index: 20;
            color: var(--theme-color, #00FFFF);
        }
        
        #game-over h2 {
            font-size: 36px;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 10px var(--theme-color, #00FFFF);
            animation: neonPulse 1.5s infinite alternate;
        }
        
        #retry-btn {
            display: inline-block;
            background-color: transparent;
            color: var(--theme-color, #00FFFF);
            border: 2px solid var(--theme-color, #00FFFF);
            border-radius: 4px;
            padding: 10px 20px;
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            box-shadow: 0 0 10px var(--theme-color, #00FFFF);
            text-shadow: 0 0 5px var(--theme-color, #00FFFF);
            transition: all 0.2s ease;
            margin-top: 10px;
        }
        
        #retry-btn:hover {
            background-color: rgba(0, 255, 255, 0.2);
            transform: scale(1.1);
            box-shadow: 0 0 15px var(--theme-color, #00FFFF);
        }
        
        #retry-btn:active {
            transform: scale(0.95);
        }
        
        @keyframes neonPulse {
            from {
                text-shadow: 0 0 5px var(--theme-color, #00FFFF), 0 0 10px var(--theme-color, #00FFFF);
            }
            to {
                text-shadow: 0 0 10px var(--theme-color, #00FFFF), 0 0 20px var(--theme-color, #00FFFF), 0 0 30px var(--theme-color, #00FFFF);
            }
        }
        
        /* Debug console for errors */
        #debug-console {
            position: fixed;
            bottom: 10px;
            left: 10px;
            width: 80%;
            max-height: 150px;
            overflow-y: auto;
            background-color: rgba(0, 0, 0, 0.8);
            color: #FF5555;
            font-family: monospace;
            font-size: 12px;
            padding: 10px;
            border: 1px solid #FF0000;
            border-radius: 4px;
            z-index: 9999;
            display: none;
        }
        
        /* Dynamic theme colors */
        :root {
            --theme-color: #00FFFF;
        }
    </style>
</head>
<body>
    <div id="ui">
        <div id="score-display">SCORE: 0</div>
    </div>
    
    <div id="level-display">LEVEL 1</div>
    
    <div id="pause-btn">
        <div></div>
        <div></div>
    </div>
    
    <div id="game-over">
        <h2>GAME OVER</h2>
        <div id="final-score">SCORE: 0</div>
        <button id="retry-btn">RETRY</button>
    </div>

    <div id="debug-console"></div>

    <!-- Load THREE.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // Debug logging
        const debug = document.getElementById('debug-console');
        debug.style.display = 'block'; // Always show initially
        
        function logDebug(message) {
            if (debug) {
                debug.innerHTML += `<div>${message}</div>`;
                debug.scrollTop = debug.scrollHeight;
            }
            console.log(message);
        }

        // Check if THREE is loaded
        if (typeof THREE === 'undefined') {
            logDebug("ERROR: THREE.js not loaded! Trying alternative CDN...");
            // Create a script element for the alternative CDN
            const script = document.createElement('script');
            script.src = "https://unpkg.com/three@0.128.0/build/three.min.js";
            script.onload = function() {
                logDebug("THREE.js loaded from alternative CDN");
                initGame();
            };
            script.onerror = function() {
                logDebug("CRITICAL ERROR: Could not load THREE.js from alternative source");
            };
            document.head.appendChild(script);
        } else {
            logDebug("THREE.js loaded successfully");
            initGame();
        }

        // Global error handling
        window.onerror = function(message, source, lineno, colno, error) {
            logDebug(`ERROR: ${message} at line ${lineno}:${colno}`);
        };

        // Wrap the game initialization in a function
        function initGame() {
            logDebug("Initializing ShapeRunner...");
            
            // Level data (embedded instead of loading from JSON files)
            const levelTitles = {
                start: {
                    title: "Starting Line",
                    description: "The player starts here on every level",
                    width: 10,
                    height: 8,
                    layout: [
                        "...........",
                        "...........",
                        "...........",
                        "...........",
                        "...........",
                        "....S...W..",
                        "BBBBBBBBBB.",
                        "..........."
                    ]
                },
                end: {
                    title: "Finish Line",
                    description: "The end of every level with the exit portal",
                    width: 10,
                    height: 8,
                    layout: [
                        "...........",
                        "...........",
                        "......E....",
                        ".....BBB...",
                        "...........",
                        "...........",
                        "BBBBBBBBBB.",
                        "..........."
                    ]
                },
                title1: {
                    title: "Simple Platforms",
                    description: "Basic platform layout with some spikes",
                    width: 20,
                    height: 8,
                    layout: [
                        ".....................",
                        ".....................",
                        "........C............",
                        "......BBBB...........",
                        "..BBB................",
                        ".....................",
                        "B.........BBB........",
                        "BBBBBBBBBBBBBBBBBBBBB"
                    ]
                },
                title2: {
                    title: "Jump and Slide",
                    description: "Jumps and slopes challenge",
                    width: 20,
                    height: 8,
                    layout: [
                        ".....................",
                        "............C........",
                        "..........BBBB.......",
                        "........./........C..",
                        "......../............",
                        "...J.../....C........",
                        "...B../...BBB........",
                        "BBBBBBBBBBBBBBBBBBBBB"
                    ]
                },
                title3: {
                    title: "Dangerous Path",
                    description: "Navigate through obstacles to find the key",
                    width: 20,
                    height: 8,
                    layout: [
                        ".....................",
                        "............K........",
                        "...........BBBB......",
                        ".....................",
                        ".....O...O...........",
                        "..BBB....BBB.........",
                        ".....................",
                        "BBBBBBBBBBBBBBBBBBBBB"
                    ]
                },
                title4: {
                    title: "Platform Gauntlet",
                    description: "Navigate through a challenging platform field",
                    width: 20,
                    height: 8,
                    layout: [
                        ".....................",
                        "..........C..........",
                        "BBBB..........BBB....",
                        "....B........B.......",
                        "....B........B..C....",
                        "....BBBBBBBBB........",
                        "............J........",
                        "BBBBBBBBBBBBBBBBBBBBB"
                    ]
                },
                title5: {
                    title: "Treasure Finale",
                    description: "Final section with a special collectible",
                    width: 20,
                    height: 8,
                    layout: [
                        ".....................",
                        "..................P..",
                        "...................B.",
                        "..........C..........",
                        "........BBBB.........",
                        ".....J................",
                        "...BBB................",
                        "^.^.^.^.^............"
                    ]
                },
                title6: {
                    title: "Cyan Platforms",
                    description: "Basic platform layout with Cyan color",
                    width: 20,
                    height: 8,
                    layout: [
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB"
                    ]
                },
                title7: {
                    title: "Purple Platforms",
                    description: "Basic platform layout with Purple color",
                    width: 20,
                    height: 8,
                    layout: [
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB"
                    ]
                },
                title8: {
                    title: "Orange Platforms",
                    description: "Basic platform layout with Orange color",
                    width: 20,
                    height: 8,
                    layout: [
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB"
                    ]
                },
                title9: {
                    title: "Green Platforms",
                    description: "Basic platform layout with Green color",
                    width: 20,
                    height: 8,
                    layout: [
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB"
                    ]
                },
                title10: {
                    title: "Red Platforms",
                    description: "Basic platform layout with Red color",
                    width: 20,
                    height: 8,
                    layout: [
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB",
                        "BBBBBBBBBBBBBBBBBBBBB"
                    ]
                },
                jump1: {
                    title: "Jump Pad 1",
                    description: "A simple jump pad",
                    width: 2,
                    height: 1,
                    layout: [
                        "  C  ",
                        "BBBBB"
                    ]
                },
                jump2: {
                    title: "Jump Pad 2",
                    description: "A simple jump pad",
                    width: 2,
                    height: 1,
                    layout: [
                        "  C  ",
                        "BBBBB"
                    ]
                },
                jump3: {
                    title: "Jump Pad 3",
                    description: "A simple jump pad",
                    width: 2,
                    height: 1,
                    layout: [
                        "  C  ",
                        "BBBBB"
                    ]
                },
                special1: {
                    title: "Special Coin 1",
                    description: "A special coin",
                    width: 1,
                    height: 1,
                    layout: [
                        "  P  "
                    ]
                },
                special2: {
                    title: "Special Coin 2",
                    description: "A special coin",
                    width: 3,
                    height: 1,
                    layout: [
                        "B B B"
                    ]
                },
                gap1: {
                    title: "Gap 1",
                    description: "A gap",
                    width: 2,
                    height: 1,
                    layout: [
                        "  C  ",
                        "B BBB"
                    ]
                },
                gap2: {
                    title: "Gap 2",
                    description: "A gap",
                    width: 2,
                    height: 1,
                    layout: [
                        "     ",
                        "BB BB"
                    ]
                },
                gap3: {
                    title: "Gap 3",
                    description: "A gap",
                    width: 2,
                    height: 1,
                    layout: [
                        "     ",
                        "BBB B"
                    ]
                },
                challenge1: {
                    title: "Challenge 1",
                    description: "A challenge section",
                    width: 2,
                    height: 1,
                    layout: [
                        "  C  ",
                        "BBBBB"
                    ]
                },
                challenge2: {
                    title: "Challenge 2",
                    description: "A challenge section",
                    width: 2,
                    height: 1,
                    layout: [
                        "BBBBB"
                    ]
                },
                challenge3: {
                    title: "Challenge 3",
                    description: "A challenge section",
                    width: 2,
                    height: 1,
                    layout: [
                        "BBBBB"
                    ]
                }
            };

            // LevelManager class
            class LevelManager {
                constructor(game) {
                    this.game = game;
                    this.currentLevel = 1;
                    this.maxLevels = 5;

                    // Level sections in 2D arrays where:
                    // B = block/platform, S = start, E = end/portal, C = coin/collectible
                    // J = jump pad, P = special collectible
                    this.levelTitles = {
                        // Starter section with player start position
                        "start": [
                            "     ",
                            "     ",
                            "     ",
                            "     ",
                            "S    ",
                            "BBBBB"
                        ],
                        
                        // End section with portal
                        "end": [
                            "     ",
                            "     ",
                            "     ",
                            "     ",
                            "E    ",
                            "BBBBB"
                        ],
                        
                        // Various title sections to compose levels
                        "title1": [
                            "     ",
                            "     ",
                            "  C  ",
                            "  B  ",
                            "     ",
                            "BBBBB"
                        ],
                        
                        "title2": [
                            "     ",
                            "  C  ",
                            "     ",
                            "    B",
                            "C    ",
                            "BBBBB"
                        ],
                        
                        "title3": [
                            "     ",
                            "C   C",
                            "     ",
                            "  B  ",
                            "  J  ",
                            "BBBBB"
                        ],
                        
                        "title4": [
                            "     ",
                            "     ",
                            "C C C",
                            "     ",
                            "     ",
                            "BBBBB"
                        ],
                        
                        "title5": [
                            "     ",
                            "   C ",
                            "  B  ",
                            " B   ",
                            "C    ",
                            "BBBBB"
                        ],
                        
                        "title6": [
                            "     ",
                            "C   C",
                            "     ",
                            "BB   ",
                            "     ",
                            "BBBBB"
                        ],
                        
                        "title7": [
                            "     ",
                            "   C ",
                            " C   ",
                            "   B ",
                            " B   ",
                            "BBBBB"
                        ],
                        
                        "title8": [
                            "     ",
                            "   C ",
                            "     ",
                            "B BBB",
                            "     ",
                            "BBBBB"
                        ],
                        
                        "title9": [
                            "     ",
                            "  P  ",
                            "     ",
                            "B B B",
                            "     ",
                            "BBBBB"
                        ],
                        
                        "title10": [
                            "     ",
                            "C   C",
                            "     ",
                            "     ",
                            "B   B",
                            "BBBBB"
                        ],
                        
                        "title11": [
                            "     ",
                            " C C ",
                            "  B  ",
                            "     ",
                            "B   B",
                            "BBBBB"
                        ],
                        
                        "title12": [
                            "     ",
                            "  C  ",
                            " BBB ",
                            "     ",
                            "  C  ",
                            "BBBBB"
                        ],
                        
                        "title13": [
                            "  C  ",
                            "     ",
                            "B   B",
                            "     ",
                            " C C ",
                            "BBBBB"
                        ],
                        
                        "title14": [
                            "     ",
                            "C   C",
                            " B B ",
                            "  B  ",
                            "     ",
                            "BBBBB"
                        ],
                        
                        "title15": [
                            "     ",
                            "  C  ",
                            "     ",
                            "BBBBB",
                            "     ",
                            "BBBBB"
                        ],
                        
                        "title16": [
                            "  C  ",
                            "     ",
                            "  B  ",
                            "     ",
                            "  C  ",
                            "BBBBB"
                        ],
                        
                        "title17": [
                            "     ",
                            "C C C",
                            "     ",
                            "B B B",
                            "     ",
                            "BBBBB"
                        ],
                        
                        "title18": [
                            " C   ",
                            "   C ",
                            "     ",
                            " B B ",
                            "   B ",
                            "BBBBB"
                        ],
                        
                        "title19": [
                            "     ",
                            "  C  ",
                            "BB BB",
                            "     ",
                            "  C  ",
                            "BBBBB"
                        ],
                        
                        "title20": [
                            "C   C",
                            "     ",
                            " B B ",
                            "     ",
                            "  C  ",
                            "BBBBB"
                        ],
                        
                        "jump1": [
                            "     ",
                            "  C  ",
                            "     ",
                            "     ",
                            "  J  ",
                            "BBBBB"
                        ],
                        
                        "jump2": [
                            "  C  ",
                            "     ",
                            "     ",
                            "     ",
                            "  J  ",
                            "BBBBB"
                        ],
                        
                        "jump3": [
                            "     ",
                            "     ",
                            "  C  ",
                            "     ",
                            "  J  ",
                            "BBBBB"
                        ],
                        
                        "jump4": [
                            "   C ",
                            "     ",
                            "     ",
                            "     ",
                            " J   ",
                            "BBBBB"
                        ],
                        
                        "jump5": [
                            " C   ",
                            "     ",
                            "     ",
                            "     ",
                            "   J ",
                            "BBBBB"
                        ],
                        
                        "special1": [
                            "     ",
                            "     ",
                            "  P  ",
                            "     ",
                            "     ",
                            "BBBBB"
                        ],
                        
                        "special2": [
                            "     ",
                            "  P  ",
                            "     ",
                            "B B B",
                            "     ",
                            "BBBBB"
                        ],
                        
                        "special3": [
                            "     ",
                            " C C ",
                            "  P  ",
                            "     ",
                            " B B ",
                            "BBBBB"
                        ],
                        
                        "special4": [
                            "  C  ",
                            " C C ",
                            "  P  ",
                            "     ",
                            "  B  ",
                            "BBBBB"
                        ],
                        
                        "gap1": [
                            "     ",
                            "  C  ",
                            "     ",
                            "     ",
                            "     ",
                            "BB BB"
                        ],
                        
                        "gap2": [
                            "     ",
                            "     ",
                            "     ",
                            "  C  ",
                            "     ",
                            "BBB B"
                        ],
                        
                        "gap3": [
                            "     ",
                            "     ",
                            "  C  ",
                            "     ",
                            "     ",
                            "B BBB"
                        ],
                        
                        "gap4": [
                            "     ",
                            "  C  ",
                            "     ",
                            "     ",
                            "     ",
                            "B   B"
                        ],
                        
                        "gap5": [
                            "     ",
                            "  C  ",
                            "     ",
                            "  B  ",
                            "     ",
                            "BB BB"
                        ],
                        
                        "challenge1": [
                            "  C  ",
                            "     ",
                            "B   B",
                            "     ",
                            "  C  ",
                            "BBBBB"
                        ],
                        
                        "challenge2": [
                            "     ",
                            "  C  ",
                            "     ",
                            "B B B",
                            "     ",
                            "BBBBB"
                        ],
                        
                        "challenge3": [
                            "     ",
                            "C   C",
                            "     ",
                            "  B  ",
                            "  J  ",
                            "BBBBB"
                        ],
                        
                        "challenge4": [
                            " C C ",
                            "     ",
                            "B   B",
                            "     ",
                            "  J  ",
                            "BBBBB"
                        ],
                        
                        "challenge5": [
                            "     ",
                            "C C C",
                            "     ",
                            "BBBBB",
                            "     ",
                            "BB BB"
                        ],
                        
                        "advanced1": [
                            "  C  ",
                            "  B  ",
                            "  C  ",
                            "  B  ",
                            "  C  ",
                            "BBBBB"
                        ],
                        
                        "advanced2": [
                            "C   C",
                            "     ",
                            "B B B",
                            "     ",
                            "  P  ",
                            "BBBBB"
                        ],
                        
                        "advanced3": [
                            "     ",
                            "C   C",
                            " B B ",
                            "     ",
                            "  J  ",
                            "BB BB"
                        ],
                        
                        "advanced4": [
                            "  P  ",
                            "     ",
                            "B B B",
                            "     ",
                            "  J  ",
                            "BBBBB"
                        ],
                        
                        "advanced5": [
                            "C C C",
                            "     ",
                            "     ",
                            "B B B",
                            "     ",
                            "BB BB"
                        ],
                    };
                }
                
                // Initialize the level manager
                async initialize() {
                    logDebug("Level manager initialized");
                    return true;
                }
                
                // Level is completed, go to next level
                nextLevel() {
                    this.currentLevel++;
                    if (this.currentLevel > this.maxLevels) {
                        this.currentLevel = 1; // Reset to level 1 after completing all levels
                    }
                    return this.currentLevel;
                }
                
                // Generate a complete level by combining multiple level titles
                generateLevel(levelNumber, difficulty = 1) {
                    try {
                        this.currentLevel = levelNumber;
                        
                        logDebug(`Generating level ${levelNumber} with difficulty ${difficulty}`);
                        
                        // Update level display
                        const levelDisplay = document.getElementById('level-display');
                        if (levelDisplay) {
                            levelDisplay.textContent = `LEVEL ${levelNumber}`;
                        }
                        
                        // Build the complete level by combining titles horizontally
                        // Each level title is a 2D array of ASCII characters
                        
                        // Start with a base set of empty rows
                        const maxHeight = 6; // All our sections are 6 rows tall
                        
                        // Initialize the combined level with empty rows
                        const combinedLevel = [];
                        for (let i = 0; i < maxHeight; i++) {
                            combinedLevel.push([]);
                        }
                        
                        // Function to append a title's layout to the combined level
                        const appendTitle = (title) => {
                            // For each row in the title's layout
                            for (let rowIndex = 0; rowIndex < title.length; rowIndex++) {
                                // Get the row string and convert to array of characters
                                const rowChars = title[rowIndex].split('');
                                
                                // Append these characters to the corresponding row in the combined level
                                combinedLevel[rowIndex] = combinedLevel[rowIndex].concat(rowChars);
                            }
                        };
                        
                        // Always start with the 'start' title
                        appendTitle(this.levelTitles['start']);
                        
                        // Get all available title names, excluding 'start' and 'end'
                        const availableTitles = Object.keys(this.levelTitles).filter(
                            name => name !== 'start' && name !== 'end'
                        );
                        
                        // Determine how many sections to include - at least 20 tiles total (18 middle + start + end)
                        const baseNumSections = 18; // Ensure at least 20 tiles total
                        const additionalSections = Math.min(Math.floor(levelNumber / 2), 5); // Up to 5 more based on level
                        const numSections = baseNumSections + additionalSections;
                        
                        // Randomly select sections for this level
                        const selectedSections = [];
                        
                        for (let i = 0; i < numSections; i++) {
                            // Pick a random title from the available pool
                            const randomIndex = Math.floor(Math.random() * availableTitles.length);
                            const randomTitle = availableTitles[randomIndex];
                            
                            // Add to selected sections
                            selectedSections.push(this.levelTitles[randomTitle]);
                            
                            // For additional variety, don't remove titles from the pool
                            // This allows the same title to potentially appear multiple times
                            // but with decreasing probability as the level grows
                        }
                        
                        // Make sure we include at least one jump pad section in every level after level 1
                        if (levelNumber > 1) {
                            let hasJumpPad = false;
                            
                            // Check if any selected section has a jump pad (J)
                            for (const section of selectedSections) {
                                const sectionStr = section.join('');
                                if (sectionStr.includes('J')) {
                                    hasJumpPad = true;
                                    break;
                                }
                            }
                            
                            // If no jump pad was found, replace one random section with a jump section
                            if (!hasJumpPad) {
                                const jumpSections = ['jump1', 'jump2', 'jump3', 'jump4', 'jump5'];
                                const randomJump = jumpSections[Math.floor(Math.random() * jumpSections.length)];
                                const replaceIndex = Math.floor(Math.random() * selectedSections.length);
                                selectedSections[replaceIndex] = this.levelTitles[randomJump];
                            }
                        }
                        
                        // For levels 3+, ensure we have a special collectible (P) somewhere
                        if (levelNumber >= 3) {
                            let hasSpecial = false;
                            
                            // Check if any selected section has a special collectible (P)
                            for (const section of selectedSections) {
                                const sectionStr = section.join('');
                                if (sectionStr.includes('P')) {
                                    hasSpecial = true;
                                    break;
                                }
                            }
                            
                            // If no special collectible was found, replace one random section
                            if (!hasSpecial) {
                                const specialSections = ['special1', 'special2', 'special3', 'special4'];
                                const randomSpecial = specialSections[Math.floor(Math.random() * specialSections.length)];
                                // Don't replace the first or last section
                                const replaceIndex = 1 + Math.floor(Math.random() * (selectedSections.length - 2));
                                selectedSections[replaceIndex] = this.levelTitles[randomSpecial];
                            }
                        }
                        
                        // Append all selected sections
                        selectedSections.forEach(section => {
                            appendTitle(section);
                        });
                        
                        // Always end with the 'end' title - this contains the portal
                        appendTitle(this.levelTitles['end']);
                        
                        // Convert the 2D array back to a string format
                        const levelString = combinedLevel.map(row => row.join('')).join('\n');
                        
                        logDebug("Level generation complete");
                        return levelString;
                    } catch (error) {
                        logDebug("Error generating level: " + error.message);
                        // Return a simple fallback level if generation fails
                        return "...........\n...........\n...........\n...........\n....S......\n...........\nBBBBBBBBBBB\n...........";
                    }
                }
            }

            // Main game class
            class Game {
                constructor() {
                    logDebug("Initializing game...");
                    
                    // UI elements
                    this.scoreDisplay = document.getElementById('score-display');
                    this.pauseBtn = document.getElementById('pause-btn');
                    this.gameOverUI = document.getElementById('game-over');
                    this.finalScore = document.getElementById('final-score');
                    this.retryBtn = document.getElementById('retry-btn');
                    
                    // Event listeners
                    this.pauseBtn.addEventListener('click', () => this.togglePause());
                    this.retryBtn.addEventListener('click', () => this.restart());
                    window.addEventListener('keydown', this.handleKeyDown.bind(this));
                    window.addEventListener('resize', this.handleResize.bind(this));
                    
                    // Game properties
                    this.isRunning = false;
                    this.isPaused = false;
                    this.score = 0;
                    this.playerSize = 1;
                    this.speed = 10;
                    this.jumpForce = 15;
                    this.gravity = 25;
                    this.groundY = -8;
                    
                    // Portal
                    this.portal = null;
                    this.portalPosition = { x: 0, y: 0 };
                    
                    // Level themes - colors for different levels
                    this.themes = [
                        { // Level 1 - Cyan (Default)
                            background: 0x0A0A55,
                            grid: 0x1144AA,
                            player: 0x00FFFF,
                            platform: 0x000033,
                            platformEdge: 0x00FFFF,
                            obstacle: 0x40FFFF,
                            obstacleEdge: 0x00FFFF,
                            collectible: 0xFFFF00,
                            portal: 0x00FFFF,
                            portalEdge: 0x80FFFF,
                            jumpPad: 0x004466,
                            jumpPadEdge: 0x00FFFF,
                            scoreGlow: '#00FFFF',
                            levelGlow: '#00FFFF'
                        },
                        { // Level 2 - Purple
                            background: 0x110033,
                            grid: 0x4400AA, 
                            player: 0xFF00FF,
                            platform: 0x220033,
                            platformEdge: 0xFF00FF,
                            obstacle: 0xFF00AA,
                            obstacleEdge: 0xFF00FF,
                            collectible: 0xFFFF00,
                            portal: 0xFF00FF,
                            portalEdge: 0xFF80FF,
                            jumpPad: 0x440066,
                            jumpPadEdge: 0xFF00FF,
                            scoreGlow: '#FF00FF',
                            levelGlow: '#FF00FF'
                        },
                        { // Level 3 - Green
                            background: 0x002222,
                            grid: 0x006644,
                            player: 0x00FF88,
                            platform: 0x003322,
                            platformEdge: 0x00FF88,
                            obstacle: 0x00CC66,
                            obstacleEdge: 0x00FF88,
                            collectible: 0xFFFF00, 
                            portal: 0x00FF88,
                            portalEdge: 0x80FFB0,
                            jumpPad: 0x004433,
                            jumpPadEdge: 0x00FF88,
                            scoreGlow: '#00FF88',
                            levelGlow: '#00FF88'
                        },
                        { // Level 4 - Orange
                            background: 0x221100,
                            grid: 0x663300,
                            player: 0xFF6600,
                            platform: 0x331100,
                            platformEdge: 0xFF6600,
                            obstacle: 0xFF8800,
                            obstacleEdge: 0xFF6600,
                            collectible: 0xFFFF00,
                            portal: 0xFF6600,
                            portalEdge: 0xFFAA80,
                            jumpPad: 0x663300,
                            jumpPadEdge: 0xFF6600,
                            scoreGlow: '#FF6600',
                            levelGlow: '#FF6600'
                        },
                        { // Level 5 - Blue
                            background: 0x000033,
                            grid: 0x0033CC,
                            player: 0x3399FF,
                            platform: 0x000044,
                            platformEdge: 0x3399FF,
                            obstacle: 0x0066FF,
                            obstacleEdge: 0x3399FF,
                            collectible: 0xFFFF00,
                            portal: 0x3399FF,
                            portalEdge: 0x80C0FF,
                            jumpPad: 0x001144,
                            jumpPadEdge: 0x3399FF,
                            scoreGlow: '#3399FF',
                            levelGlow: '#3399FF'
                        }
                    ];
                    
                    // Colors - will be set based on current theme
                    this.colors = {
                        background: 0x000033,
                        player: 0x00FFFF,
                        platform: 0x0066FF,
                        obstacle: 0xFF00FF,
                        collectible: 0xFFFF00
                    };
                    
                    // Level manager
                    this.levelManager = new LevelManager(this);
                    
                    // Initialize the game
                    this.init();
                }
                
                async init() {
                    try {
                        // Initialize level manager
                        await this.levelManager.initialize();
                        
                        // Create renderer
                        this.renderer = new THREE.WebGLRenderer({ antialias: true });
                        this.renderer.setSize(window.innerWidth, window.innerHeight);
                        document.body.appendChild(this.renderer.domElement);
                        
                        // Create scene
                        this.scene = new THREE.Scene();
                        this.scene.background = new THREE.Color(0x0A0A55); // Deeper blue like in the image
                        
                        // Create camera
                        const aspectRatio = window.innerWidth / window.innerHeight;
                        const cameraHeight = 20;
                        const cameraWidth = cameraHeight * aspectRatio;
                        this.camera = new THREE.OrthographicCamera(
                            -cameraWidth / 2, cameraWidth / 2,
                            cameraHeight / 2, -cameraHeight / 2,
                            0.1, 1000
                        );
                        this.camera.position.z = 10;
                        
                        // Add light
                        const light = new THREE.AmbientLight(0xFFFFFF, 1);
                        this.scene.add(light);
                        
                        // Create Tron grid
                        this.createGrid();
                        
                        // Create player
                        this.createPlayer();
                        
                        // Create level
                        this.createLevel();
                        
                        // Initialize UI with correct theme colors
                        this.updateUITheme();
                        
                        // Start animation loop
                        this.isRunning = true;
                        this.lastTime = performance.now();
                        this.animate();
                        
                        logDebug("Game initialized successfully");
                    } catch (error) {
                        logDebug("Error initializing game: " + error.message);
                    }
                }
                
                createGrid() {
                    // Grid size and properties
                    const gridSize = 1000;
                    const gridDivisions = 200; // Increased from 100 for more grid lines
                    const gridColor = 0x1144AA; // Darker blue grid lines to match image
                    
                    // Create grid with lines
                    const gridHelper = new THREE.GridHelper(gridSize, gridDivisions, gridColor, gridColor);
                    gridHelper.position.y = this.groundY - 0.4; // Slightly below ground
                    gridHelper.material.transparent = true;
                    gridHelper.material.opacity = 0.3; // Increased from 0.2 for better visibility
                    gridHelper.material.blending = THREE.AdditiveBlending;
                    this.scene.add(gridHelper);
                    
                    // Rotate grid to make it horizontal
                    gridHelper.rotation.x = Math.PI / 2;
                    
                    // Add a second grid with different sizing for a more complex grid pattern
                    const secondaryGridSize = 500;
                    const secondaryGridDivisions = 50;
                    const secondaryGridColor = 0x2266CC; // Slightly brighter blue for contrast
                    
                    const secondaryGridHelper = new THREE.GridHelper(secondaryGridSize, secondaryGridDivisions, secondaryGridColor, secondaryGridColor);
                    secondaryGridHelper.position.y = this.groundY - 0.39; // Slightly above the main grid
                    secondaryGridHelper.material.transparent = true;
                    secondaryGridHelper.material.opacity = 0.4;
                    secondaryGridHelper.material.blending = THREE.AdditiveBlending;
                    this.scene.add(secondaryGridHelper);
                    
                    // Rotate the secondary grid
                    secondaryGridHelper.rotation.x = Math.PI / 2;
                    
                    // Add a plane with a grid texture for additional effect
                    const gridPlaneGeometry = new THREE.PlaneGeometry(gridSize, gridSize);
                    const gridPlaneMaterial = new THREE.MeshBasicMaterial({
                        color: 0x0A0A44, // Very dark blue background
                        transparent: true,
                        opacity: 0.9
                    });
                    const gridPlane = new THREE.Mesh(gridPlaneGeometry, gridPlaneMaterial);
                    gridPlane.position.y = this.groundY - 0.45; // Just below the grid
                    gridPlane.rotation.x = -Math.PI / 2;
                    this.scene.add(gridPlane);
                }
                
                createPlayer() {
                    // Get current theme colors
                    const themeIndex = (this.levelManager.currentLevel - 1) % this.themes.length;
                    const theme = this.themes[themeIndex];
                    
                    // Player size
                    this.playerSize = 1.0;
                    
                    // Create a composite player object to match the reference image
                    this.player = new THREE.Group();
                    this.player.position.set(-5, this.groundY + this.playerSize/2 + 0.5, 0);
                    this.scene.add(this.player);
                    
                    // Create the main square shape without rotation (matches image)
                    const mainGeometry = new THREE.BoxGeometry(this.playerSize, this.playerSize, this.playerSize * 0.5);
                    const mainMaterial = new THREE.MeshBasicMaterial({ 
                        color: theme.player, // Use theme player color
                        transparent: true,
                        opacity: 0.9
                    });
                    const mainMesh = new THREE.Mesh(mainGeometry, mainMaterial);
                    // No rotation - keep as square
                    this.player.add(mainMesh);
                    this.playerMainMesh = mainMesh;
                    
                    // Create inner box
                    const innerGeometry = new THREE.BoxGeometry(this.playerSize * 0.6, this.playerSize * 0.6, this.playerSize * 0.5);
                    const innerMaterial = new THREE.MeshBasicMaterial({ 
                        color: theme.player, // Use theme player color
                        transparent: true,
                        opacity: 0.9
                    });
                    const innerMesh = new THREE.Mesh(innerGeometry, innerMaterial);
                    this.player.add(innerMesh);
                    
                    // Add bright center point
                    const centerGeometry = new THREE.BoxGeometry(this.playerSize * 0.2, this.playerSize * 0.2, this.playerSize * 0.2);
                    const centerMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xFFFFFF, // Keep center white for contrast
                        transparent: false
                    });
                    const centerMesh = new THREE.Mesh(centerGeometry, centerMaterial);
                    this.player.add(centerMesh);
                    
                    // Add edge lines 
                    const edges = new THREE.EdgesGeometry(mainGeometry);
                    const lineMaterial = new THREE.LineBasicMaterial({ 
                        color: theme.playerEdge || theme.player, // Use theme player edge color or player color as fallback
                        linewidth: 2
                    });
                    const wireframe = new THREE.LineSegments(edges, lineMaterial);
                    this.player.add(wireframe);
                    this.playerWireframe = wireframe; // Store reference for theme updates
                    
                    // Create outer glow
                    const glowGeometry = new THREE.BoxGeometry(
                        this.playerSize * 1.3, 
                        this.playerSize * 1.3, 
                        this.playerSize * 0.5
                    );
                    const glowMaterial = new THREE.MeshBasicMaterial({
                        color: theme.player, // Use theme player color
                        transparent: true,
                        opacity: 0.3,
                        blending: THREE.AdditiveBlending
                    });
                    const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
                    this.player.add(glowMesh);
                    this.playerGlow = glowMesh;
                    
                    // Initialize jump particle system
                    this.jumpParticles = [];
                    this.jumpPath = null;
                    this.jumpHistoryPoints = [];
                    
                    // Player physics
                    this.playerVelocity = { x: 5, y: 0 }; // Set x velocity to 5 to move forward
                    this.isJumping = false;
                    this.onGround = false;
                    
                    // Initialize level display
                    this.levelDisplay = document.getElementById('level-display');
                    
                    // Store current player theme color to check for theme changes
                    this.currentPlayerThemeColor = theme.player;
                    
                    logDebug("Player created with Tron-like appearance using theme colors");
                }
                
                // Create jump particles effect
                createJumpParticles() {
                    // Get current theme colors
                    const themeIndex = (this.levelManager.currentLevel - 1) % this.themes.length;
                    const theme = this.themes[themeIndex];
                    const particleColor = theme.player; // Use player color for the particles
                    
                    // Clear any existing jump particles
                    this.jumpParticles.forEach(particle => {
                        this.scene.remove(particle);
                    });
                    this.jumpParticles = [];
                    
                    // Create new particles
                    const particleCount = 10;
                    for (let i = 0; i < particleCount; i++) {
                        const size = 0.1 + Math.random() * 0.2;
                        const particleGeometry = new THREE.BoxGeometry(size, size, size);
                        const particleMaterial = new THREE.MeshBasicMaterial({
                            color: particleColor,
                            transparent: true,
                            opacity: 0.7,
                            blending: THREE.AdditiveBlending
                        });
                        
                        const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                        
                        // Position around player's feet
                        const angle = Math.random() * Math.PI * 2;
                        const radius = 0.3 + Math.random() * 0.3;
                        const offsetX = Math.cos(angle) * radius;
                        const offsetY = Math.sin(angle) * radius;
                        
                        particle.position.set(
                            this.player.position.x + offsetX,
                            this.player.position.y - this.playerSize/2 + offsetY,
                            0
                        );
                        
                        // Add velocity for animation
                        particle.userData.velocityX = offsetX * 2;
                        particle.userData.velocityY = 2 + Math.random() * 3;
                        particle.userData.life = 1.0; // Full life
                        
                        this.scene.add(particle);
                        this.jumpParticles.push(particle);
                    }
                    
                    // Reset jump path tracking
                    this.jumpHistoryPoints = [];
                    this.jumpHistoryPoints.push(new THREE.Vector3(
                        this.player.position.x,
                        this.player.position.y,
                        0
                    ));
                    
                    // Remove any existing jump path
                    if (this.jumpPath) {
                        this.scene.remove(this.jumpPath);
                        this.jumpPath = null;
                    }
                }
                
                // Update jump path visualization
                updateJumpPath() {
                    // Get current theme colors
                    const themeIndex = (this.levelManager.currentLevel - 1) % this.themes.length;
                    const theme = this.themes[themeIndex];
                    const pathColor = theme.player; // Use player color for the path
                    
                    // Add current position to jump history
                    this.jumpHistoryPoints.push(new THREE.Vector3(
                        this.player.position.x,
                        this.player.position.y,
                        0
                    ));
                    
                    // Keep only the recent history (last 20 points)
                    if (this.jumpHistoryPoints.length > 20) {
                        this.jumpHistoryPoints.shift();
                    }
                    
                    // Remove existing path
                    if (this.jumpPath) {
                        this.scene.remove(this.jumpPath);
                    }
                    
                    // Create curve from points
                    const curve = new THREE.CatmullRomCurve3(this.jumpHistoryPoints);
                    
                    // Instead of a basic line, create a variable-width tube
                    // First, create points along the curve
                    const numPoints = 50;
                    const points = curve.getPoints(numPoints);
                    
                    // Create a custom geometry for the variable-width path
                    const pathGeometry = new THREE.BufferGeometry().setFromPoints(points);
                    const positions = [];
                    const indices = [];
                    
                    // Create a ribbon-like geometry with varying width
                    for (let i = 0; i < points.length; i++) {
                        const point = points[i];
                        
                        // Calculate width factor - thicker near the player (end of the curve)
                        // and thinner away from the player (start of the curve)
                        const widthFactor = i / points.length; // 0 at start, 1 at end (near player)
                        const width = 0.05 + widthFactor * 0.2; // Thin to thick
                        
                        // For each point, create two vertices perpendicular to the curve
                        let tangent;
                        if (i < points.length - 1) {
                            // Calculate tangent based on current and next point
                            tangent = new THREE.Vector3().subVectors(points[i + 1], point).normalize();
                        } else {
                            // For the last point, use the previous tangent
                            tangent = new THREE.Vector3().subVectors(point, points[i - 1]).normalize();
                        }
                        
                        // Create perpendicular vector (for 2D curve in XY plane)
                        const normal = new THREE.Vector3(-tangent.y, tangent.x, 0).normalize();
                        
                        // Create vertices on both sides of the curve
                        const v1 = new THREE.Vector3().addVectors(point, normal.clone().multiplyScalar(width));
                        const v2 = new THREE.Vector3().subVectors(point, normal.clone().multiplyScalar(width));
                        
                        // Add positions
                        positions.push(v1.x, v1.y, v1.z);
                        positions.push(v2.x, v2.y, v2.z);
                        
                        // Add indices to create triangles (except for the first point)
                        if (i > 0) {
                            const base = (i - 1) * 2;
                            indices.push(base, base + 1, base + 2); // First triangle
                            indices.push(base + 1, base + 3, base + 2); // Second triangle
                        }
                    }
                    
                    // Set attributes for the geometry
                    pathGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                    pathGeometry.setIndex(indices);
                    
                    // Create path material with fade effect - using theme color
                    const pathMaterial = new THREE.MeshBasicMaterial({
                        color: pathColor,
                        transparent: true,
                        opacity: 0.6,
                        blending: THREE.AdditiveBlending,
                        side: THREE.DoubleSide
                    });
                    
                    // Create the path as a mesh
                    this.jumpPath = new THREE.Mesh(pathGeometry, pathMaterial);
                    this.scene.add(this.jumpPath);
                }
                
                createLevel() {
                    // Clear existing level objects
                    this.clearLevel();
                    
                    // Reset collections
                    this.platforms = [];
                    this.obstacles = [];
                    this.collectibles = [];
                    this.floorTilePositions = [];
                    
                    // Update scene background color
                    const themeIndex = (this.levelManager.currentLevel - 1) % this.themes.length;
                    const theme = this.themes[themeIndex];
                    
                    // Update scene background color based on theme
                    this.scene.background = new THREE.Color(theme.background);
                    
                    // Update UI colors to match theme
                    document.getElementById('score-display').style.textShadow = 
                        `0 0 10px ${theme.scoreGlow}, 0 0 20px ${theme.scoreGlow}, 0 0 30px ${theme.scoreGlow}`;
                    document.getElementById('level-display').style.textShadow = 
                        `0 0 10px ${theme.levelGlow}, 0 0 20px ${theme.levelGlow}, 0 0 30px ${theme.levelGlow}`;
                    
                    // Generate level from level manager
                    const levelData = this.levelManager.generateLevel(this.levelManager.currentLevel, 2);
                    
                    // Parse level data
                    this.parseLevel(levelData);
                    
                    console.debug("Level created!");
                }
                
                // Create test spikes if no spikes are being created from level data
                createTestSpikes() {
                    // Add some test spikes at positions with appropriate spacing
                    const testPositions = [];
                    
                    // Start position
                    let posX = 0;
                    
                    // Create 8 test spikes with varied spacing
                    for (let i = 0; i < 8; i++) {
                        // Add small random variation to y position
                        const posY = this.groundY + 0.5 + (Math.random() * 0.1);
                        
                        // Add to positions
                        testPositions.push({ x: posX, y: posY });
                        
                        // Vary spacing between spikes (1.5 to 2.5 units)
                        posX += 1.5 + Math.random();
                    }
                    
                    // Create a second row of spikes further ahead
                    posX = 20;
                    for (let i = 0; i < 5; i++) {
                        const posY = this.groundY + 0.5 + (Math.random() * 0.1);
                        testPositions.push({ x: posX, y: posY });
                        posX += 1.3 + Math.random() * 1.2;
                    }
                    
                    // Create a cluster of 3 spikes together
                    const clusterX = 35;
                    testPositions.push(
                        { x: clusterX, y: this.groundY + 0.5 },
                        { x: clusterX + 1.2, y: this.groundY + 0.5 },
                        { x: clusterX + 2.4, y: this.groundY + 0.5 }
                    );
                    
                    // Create each test spike
                    const createdSpikes = [];
                    testPositions.forEach(pos => {
                        const spike = this.createSpikeAt(pos.x, pos.y);
                        createdSpikes.push(spike);
                    });
                    
                    logDebug(`Created ${testPositions.length} test spikes with varied spacing`);
                }
                
                parseLevel(levelData) {
                    const rows = levelData.split("\n");
                    
                    // Position tracking
                    let xPos = -40; // Start position
                    const tileSize = 2; // Size of each tile
                    
                    // Reset position for actual creation
                    xPos = -40;
                    
                    // First pass - create all level elements
                    for (let col = 0; col < rows[0].length; col++) {
                        for (let row = 0; row < rows.length; row++) {
                            // Invert row to make bottom row the ground level
                            const invertedRow = rows.length - 1 - row;
                            
                            // Get the character at this position
                            const char = rows[invertedRow][col];
                            
                            // Calculate y position with proper offset to ensure platforms are above floor
                            const yPos = this.groundY + 1.0 + row * tileSize;
                            
                            // Add a special check for bottom row floor tiles
                            const isBottomRow = (row === 0);
                            
                            // Special handling for floor tiles
                            if (char === 'B' && isBottomRow) {
                                // Create floor tile - add to floor positions
                                if (!this.floorTilePositions) {
                                    this.floorTilePositions = [];
                                }
                                this.floorTilePositions.push(xPos);
                                
                                // Mark this position as having a floor tile
                                logDebug(`Floor tile at ${xPos}`);
                            }
                            
                            // Create the appropriate tile based on the character
                            this.createTile(char, xPos, yPos, isBottomRow);
                        }
                        
                        // Move to the next column
                        xPos += tileSize;
                    }
                    
                    // After all tiles are processed, create the complete floor based on collected positions
                    this.createFloor();
                }
                
                createTile(type, x, y, isBottomRow) {
                    // Get current theme colors
                    const themeIndex = (this.levelManager.currentLevel - 1) % this.themes.length;
                    const theme = this.themes[themeIndex];
                    
                    // Check if this position would place the object too close to or below the floor
                    // For platforms, we need to check based on their height
                    const platformHeight = 1; // Standard platform height
                    const minYPosition = this.groundY + 0.5 + platformHeight/2;
                    
                    // Skip floor tiles at the bottom row - they'll be handled by createFloor
                    if (isBottomRow && type === 'B') {
                        return;
                    }
                    
                    switch (type) {
                        case 'B': // Block/Platform
                            // Skip creating platform if it would overlap with floor
                            if (y - platformHeight/2 <= this.groundY + 0.5) {
                                // Skip this platform as it would overlap with the floor
                                return;
                            }
                            
                            const platformGeometry = new THREE.BoxGeometry(2, 1, 1);
                            const platformMaterial = new THREE.MeshBasicMaterial({ 
                                color: theme.platform, 
                                transparent: true,
                                opacity: 0.8
                            });
                            const platform = new THREE.Mesh(platformGeometry, platformMaterial);
                            platform.position.set(x, y, 0);
                            platform.userData.type = 'platform';
                            platform.userData.width = 2;
                            platform.userData.height = 1;
                            this.scene.add(platform);
                            this.platforms.push(platform);
                            
                            // Add bright edges glow effect to platforms - themed color
                            const edges = new THREE.EdgesGeometry(platformGeometry);
                            const lineMaterial = new THREE.LineBasicMaterial({ 
                                color: theme.platformEdge, 
                                linewidth: 2
                            });
                            const wireframe = new THREE.LineSegments(edges, lineMaterial);
                            platform.add(wireframe);
                            
                            break;
                            
                        case 'W':
                            this.createTriangleSpike(x, y);
                            break;
                            
                        case 'V': // Downward spike - REMOVED as requested
                            console.log("Skipping spike at", x, y);
                            break;
                            
                        case 'S': // Start position
                            // Mark start position for player
                            this.startPosition = { x, y: y + 0.5 }; // Slight offset to place player above floor
                            
                            // Set player position if this is a new level
                            if (this.player) {
                                // Only set position if player exists
                                if (!this.player.hasMovedFromStart) {
                                    this.player.position.set(x, y + 0.5, 0);
                                }
                            }
                            break;
                            
                        case 'E': // End/portal
                            // Create portal at this position
                            this.createPortal(x, y + 1);
                            break;
                            
                        case 'C': // Collectible coin
                            this.createCollectible(x, y);
                            break;
                            
                        case 'J': // Jump pad
                            const jumpPadGeometry = new THREE.BoxGeometry(2, 0.5, 1);
                            const jumpPadMaterial = new THREE.MeshBasicMaterial({ 
                                color: 0xFFDD00, // Yellow color
                                transparent: true,
                                opacity: 0.8
                            });
                            const jumpPad = new THREE.Mesh(jumpPadGeometry, jumpPadMaterial);
                            jumpPad.position.set(x, y, 0);
                            jumpPad.userData.type = 'jumpPad';
                            jumpPad.userData.width = 2;
                            jumpPad.userData.height = 0.5;
                            this.scene.add(jumpPad);
                            
                            // Only add to platforms array (not obstacles)
                            this.platforms.push(jumpPad);
                            
                            // Add glow effect to jump pad
                            const jumpPadEdges = new THREE.EdgesGeometry(jumpPadGeometry);
                            const jumpPadLineMaterial = new THREE.LineBasicMaterial({ 
                                color: 0xFFFF00, // Bright yellow for edges
                                linewidth: 2
                            });
                            const jumpPadWireframe = new THREE.LineSegments(jumpPadEdges, jumpPadLineMaterial);
                            jumpPad.add(jumpPadWireframe);
                            
                            // Add glow effect
                            const glowGeometry = new THREE.BoxGeometry(2.2, 0.7, 1.1);
                            const glowMaterial = new THREE.MeshBasicMaterial({
                                color: 0xFFFF00, // Yellow glow
                                transparent: true,
                                opacity: 0.3,
                                side: THREE.BackSide
                            });
                            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                            jumpPad.add(glow);
                            
                            break;
                        case 'P': // Special collectible
                            this.createSpecialCollectible(x, y);
                            break;
                    }
                }
                
                createSpike(x, y, direction) {
                    console.log(`Creating DEADLY SPIKE at ${x}, ${y}, direction: ${direction}`);
                    
                    // Size of the spike
                    const spikeSize = 1.0;
                    const halfSize = spikeSize / 2;
                    
                    // Get current theme
                    const themeIndex = (this.levelManager.currentLevel - 1) % this.themes.length;
                    const theme = this.themes[themeIndex];
                    
                    // Create spike mesh with better triangle definition
                    let vertices;
                    
                    if (direction === 'up') {
                        // Upward spike vertices - triangle with point at top
                        vertices = new Float32Array([
                            -halfSize, 0, 0,      // left bottom
                            halfSize, 0, 0,       // right bottom
                            0, spikeSize, 0       // top point
                        ]);
                    } else {
                        // Downward spike vertices - triangle with point at bottom
                        vertices = new Float32Array([
                            -halfSize, 0, 0,      // left top
                            halfSize, 0, 0,       // right top
                            0, -spikeSize, 0      // bottom point
                        ]);
                    }
                    
                    // Create geometry
                    const geometry = new THREE.BufferGeometry();
                    geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                    geometry.setIndex([0, 1, 2]); // Create a face
                    geometry.computeVertexNormals();
                    
                    // Basic material for the spike - use RED for visibility
                    const material = new THREE.MeshBasicMaterial({
                        color: 0xFF0000, // Red color for clear visibility
                        side: THREE.DoubleSide
                    });
                    
                    // Create mesh
                    const spike = new THREE.Mesh(geometry, material);
                    
                    // Add outline
                    const outlineMaterial = new THREE.LineBasicMaterial({
                        color: 0xFFFFFF, // White outline
                        linewidth: 2
                    });
                    const outlineGeometry = new THREE.EdgesGeometry(geometry);
                    const outline = new THREE.LineSegments(outlineGeometry, outlineMaterial);
                    spike.add(outline);
                    
                    // Position the spike
                    spike.position.set(x, y, 0);
                    
                    // Make sure spike is NOT added to platforms array
                    // Add ONLY to obstacles array
                    this.scene.add(spike);
                    this.obstacles.push(spike);
                    console.log(`Added spike to obstacles array. Count: ${this.obstacles.length}`);
                    
                    // Setup user data for collision detection - CRITICAL
                    spike.userData = {
                        type: 'spike',
                        deadly: true,
                        direction: direction,
                        width: spikeSize,
                        height: spikeSize
                    };
                    
                    console.log("Spike created with userData:", spike.userData);
                    
                    return spike;
                }
                
                createFloor() {
                    if (!this.floorTilePositions || this.floorTilePositions.length === 0) {
                        logDebug("No floor tiles found in level data");
                        return;
                    }
                    
                    // Get current theme
                    const themeIndex = (this.levelManager.currentLevel - 1) % this.themes.length;
                    const theme = this.themes[themeIndex];
                    
                    // Sort positions to find min and max
                    const positions = [...this.floorTilePositions].sort((a, b) => a - b);
                    const minX = positions[0];
                    const maxX = positions[positions.length - 1];
                    const width = maxX - minX + 2; // Add 2 for tile width
                    const centerX = (maxX + minX) / 2;
                    
                    // Create the floor
                    const groundGeometry = new THREE.BoxGeometry(width, 0.5, 1);
                    const groundMaterial = new THREE.MeshBasicMaterial({ 
                        color: theme.platform, 
                                transparent: true,
                        opacity: 0.6
                    });
                    
                    this.ground = new THREE.Mesh(groundGeometry, groundMaterial);
                    this.ground.position.set(centerX, this.groundY, 0);
                    this.scene.add(this.ground);
                    this.platforms.push(this.ground);
                    
                    // Add glow effect to ground
                    const groundEdges = new THREE.EdgesGeometry(groundGeometry);
                    const groundLineMaterial = new THREE.LineBasicMaterial({ 
                        color: theme.platformEdge, 
                                linewidth: 2
                            });
                    const groundWireframe = new THREE.LineSegments(groundEdges, groundLineMaterial);
                    this.ground.add(groundWireframe);
                    
                    // Add subtle glow at ground level
                    const groundGlowGeometry = new THREE.BoxGeometry(width, 0.05, 1.5);
                    const groundGlowMaterial = new THREE.MeshBasicMaterial({
                        color: theme.platformEdge,
                                transparent: true,
                        opacity: 0.15,
                                blending: THREE.AdditiveBlending
                            });
                    const groundGlow = new THREE.Mesh(groundGlowGeometry, groundGlowMaterial);
                    groundGlow.position.y = 0.3; // Slightly above the ground
                    this.ground.add(groundGlow);
                    
                    logDebug(`Created floor from ${positions.length} tiles, width: ${width}`);
                }
                
                // Cluster the spikes
                clusterSpikes(spikes) {
                    // This function is no longer needed - spikes have been removed
                    return [];
                }
                
                // Adjust spike positions to prevent intersections
                adjustSpikePositions(cluster) {
                    // This function is no longer needed - spikes have been removed
                    return [];
                }
                
                // Create spike clusters
                createSpikesClusters(clusters) {
                    // This function is no longer needed - spikes have been removed
                }
                
                // Create a single spike at the specified position
                createSpikeAt(x, y) {
                    // This function is no longer needed - spikes have been removed
                    return null;
                }
                
                handleKeyDown(event) {
                    if ((event.code === 'Space' || event.code === 'ArrowUp') && !this.isJumping && (this.onGround || this.onPlatform)) {
                        this.playerVelocity.y = this.jumpForce;
                        this.isJumping = true;
                        this.onGround = false;
                        this.onPlatform = false;
                        
                        // Create jump particles and start path tracking
                        this.createJumpParticles();
                    }
                    
                    // Increase speed when right arrow is pressed
                    if (event.code === 'ArrowRight') {
                        this.playerVelocity.x = 10; // Double speed temporarily
                        setTimeout(() => {
                            if (this.isRunning) this.playerVelocity.x = 5; // Return to normal speed after 0.5 seconds
                        }, 500);
                    }
                    
                    if (event.code === 'KeyP' || event.code === 'Escape') {
                        this.togglePause();
                    }
                }
                
                handleResize() {
                    const width = window.innerWidth;
                    const height = window.innerHeight;
                    
                    this.renderer.setSize(width, height);
                    
                    const aspectRatio = width / height;
                    const cameraHeight = 20;
                    const cameraWidth = cameraHeight * aspectRatio;
                    
                    this.camera.left = -cameraWidth / 2;
                    this.camera.right = cameraWidth / 2;
                    this.camera.top = cameraHeight / 2;
                    this.camera.bottom = -cameraHeight / 2;
                    this.camera.updateProjectionMatrix();
                }
                
                togglePause() {
                    this.isPaused = !this.isPaused;
                    logDebug("Game " + (this.isPaused ? "paused" : "resumed"));
                }
                
                restart() {
                    logDebug("Restarting game");
                    this.score = 0;
                    this.gameOverUI.style.display = 'none';
                    this.isRunning = true;
                    this.isPaused = false;
                    
                    // Reset player
                    this.player.position.set(-5, this.groundY + this.playerSize/2 + 0.5, 0);
                    this.playerVelocity.x = 5;
                    this.playerVelocity.y = 0;
                    this.isJumping = false;
                    
                    // Trail particles have been removed per request
                    
                    // Recreate level
                    this.createLevel();
                    
                    // Update UI
                    this.updateScoreDisplay();
                    this.updateLevelDisplay();
                    this.updateUITheme(); // Ensure UI theme is updated
                }
                
                animate() {
                    requestAnimationFrame(this.animate.bind(this));
                    
                    if (!this.isRunning || this.isPaused) return;
                    
                    // Calculate delta time for smooth animation
                    const now = performance.now();
                    const deltaTime = (now - this.lastTime) / 1000; // in seconds
                    this.lastTime = now;
                    
                    // Limit delta time to avoid large jumps
                    const limitedDelta = Math.min(deltaTime, 0.1);
                    
                    // Update game state
                    this.update(limitedDelta);
                    
                    // Render scene
                    this.renderer.render(this.scene, this.camera);
                }
                
                update(deltaTime) {
                    // Apply gravity to player
                    this.playerVelocity.y -= this.gravity * deltaTime;
                    
                    // Limit vertical velocity
                    this.playerVelocity.y = Math.max(this.playerVelocity.y, -30);
                    
                    // Ensure player is always moving forward
                    if (this.playerVelocity.x < 5) {
                        this.playerVelocity.x = 5;
                        logDebug("Restoring forward velocity");
                    }
                    
                    // Update player position
                    this.player.position.x += this.playerVelocity.x * deltaTime;
                    this.player.position.y += this.playerVelocity.y * deltaTime;
                    
                    // Update jump particles
                    if (this.jumpParticles.length > 0) {
                        for (let i = this.jumpParticles.length - 1; i >= 0; i--) {
                            const particle = this.jumpParticles[i];
                            
                            // Update position based on velocity
                            particle.position.x += particle.userData.velocityX * deltaTime;
                            particle.position.y += particle.userData.velocityY * deltaTime;
                            
                            // Apply gravity to particles
                            particle.userData.velocityY -= 15 * deltaTime;
                            
                            // Reduce life
                            particle.userData.life -= deltaTime * 1.5;
                            
                            // Update opacity based on life
                            particle.material.opacity = particle.userData.life * 0.7;
                            
                            // Remove if life is depleted
                            if (particle.userData.life <= 0) {
                                this.scene.remove(particle);
                                this.jumpParticles.splice(i, 1);
                            }
                        }
                    }
                    
                    // Update jump path if jumping
                    if (this.isJumping && this.jumpHistoryPoints.length > 0) {
                        this.updateJumpPath();
                    }
                    
                    // Immediately remove jump path when not jumping
                    if (!this.isJumping && this.jumpPath) {
                            this.scene.remove(this.jumpPath);
                            this.jumpPath = null;
                        this.jumpHistoryPoints = [];
                    }
                    
                    // Trail particles have been removed per request
                    
                    // Ground collision
                    if (this.player.position.y - this.playerSize/2 < this.groundY + 0.5) { // Add a small offset to ensure player is on top
                        this.player.position.y = this.groundY + this.playerSize/2 + 0.5;
                        this.playerVelocity.y = 0;
                        this.isJumping = false;
                        this.onGround = true;
                        
                        // Immediately remove jump path when landing on ground
                        if (this.jumpPath) {
                                this.scene.remove(this.jumpPath);
                                this.jumpPath = null;
                            this.jumpHistoryPoints = [];
                        }
                    } else {
                        this.onGround = false;
                    }
                    
                    // Check collisions
                    this.checkCollisions();
                    
                    // Update portal animations
                    this.updatePortal(deltaTime);
                    
                    // Camera follows player
                    this.camera.position.x = this.player.position.x;
                    
                    // Update UI
                    this.score += deltaTime * 10;
                    this.updateScoreDisplay();
                    
                    // Animate player glow effect
                    if (this.playerGlow) {
                        this.playerGlow.scale.x = 1 + Math.sin(performance.now() * 0.005) * 0.1;
                        this.playerGlow.scale.y = 1 + Math.sin(performance.now() * 0.005) * 0.1;
                        this.playerGlow.scale.z = 1 + Math.sin(performance.now() * 0.005) * 0.1;
                    }
                    
                    // Additional player animation during motion - square player should not rotate
                    if (this.playerMainMesh) {
                        this.playerMainMesh.rotation.z = 0;
                    }
                    
                    // Keep player upright even while jumping (no rotation), matching the image
                    this.player.rotation.z = 0;
                    
                    // Animate other elements with glow effect
                    // Animate jump pads
                    this.platforms.forEach(platform => {
                        if (platform.userData.type === 'jumpPad' && platform.userData.glowMesh) {
                            const glow = platform.userData.glowMesh;
                            glow.scale.x = 1 + Math.sin(performance.now() * 0.01) * 0.2;
                            glow.scale.y = 1 + Math.sin(performance.now() * 0.01) * 0.2;
                            glow.material.opacity = 0.3 + Math.sin(performance.now() * 0.01) * 0.2;
                        }
                    });
                }
                
                checkCollisions() {
                    // DEBUG: Log the player position
                    console.log(`Player position: ${this.player.position.x.toFixed(2)}, ${this.player.position.y.toFixed(2)}`);
                    
                    // ---- FIRST check for SPIKE collisions - highest priority! ----
                    for (let i = 0; i < this.obstacles.length; i++) {
                        const obstacle = this.obstacles[i];
                        
                        // Skip invalid obstacles
                        if (!obstacle || !obstacle.userData) {
                            continue;
                        }
                        
                        // Only process spikes in this first pass
                        if (obstacle.userData.type !== 'spike') {
                            continue;
                        }
                        
                        console.log(`Checking spike at ${obstacle.position.x.toFixed(2)}, ${obstacle.position.y.toFixed(2)}`);
                        
                        // Player hitbox - make slightly larger for spikes to ensure detection
                        const playerLeft = this.player.position.x - this.playerSize/2;
                        const playerRight = this.player.position.x + this.playerSize/2;
                        const playerBottom = this.player.position.y - this.playerSize/2;
                        const playerTop = this.player.position.y + this.playerSize/2;
                        
                        // Spike hitbox calculation
                        const spikeSize = obstacle.userData.width || 1;
                        const spikeLeft = obstacle.position.x - spikeSize/2;
                        const spikeRight = obstacle.position.x + spikeSize/2;
                        let spikeBottom, spikeTop;
                        
                        if (obstacle.userData.direction === 'up') {
                            spikeBottom = obstacle.position.y;
                            spikeTop = obstacle.position.y + spikeSize;
                        } else { // down spike
                            spikeBottom = obstacle.position.y - spikeSize;
                            spikeTop = obstacle.position.y;
                        }
                        
                        // Check for collision with spike
                        if (playerRight > spikeLeft && 
                            playerLeft < spikeRight && 
                            playerBottom < spikeTop && 
                            playerTop > spikeBottom) {
                            
                            // PLAYER HIT A SPIKE!
                            console.log("SPIKE COLLISION DETECTED! GAME OVER!");
                            
                            // Create dramatic death effect
                            this.createDeathEffect(this.player.position.x, this.player.position.y);
                            
                            // End the game
                            this.gameOver();
                            return; // Exit immediately
                        }
                    }
                    
                    // ---- Then check for other OBSTACLE collisions ----
                    for (let i = 0; i < this.obstacles.length; i++) {
                        const obstacle = this.obstacles[i];
                        
                        // Skip invalid obstacles or spikes (already checked)
                        if (!obstacle || !obstacle.userData || obstacle.userData.type === 'spike') {
                            continue;
                        }
                        
                        // Player hitbox
                        const playerLeft = this.player.position.x - this.playerSize/2 + 0.1;
                        const playerRight = this.player.position.x + this.playerSize/2 - 0.1;
                        const playerBottom = this.player.position.y - this.playerSize/2 + 0.1;
                        const playerTop = this.player.position.y + this.playerSize/2 - 0.1;
                        
                        // Obstacle hitbox
                        const obstacleWidth = obstacle.userData.width || 1;
                        const obstacleHeight = obstacle.userData.height || 1;
                        const obstacleLeft = obstacle.position.x - obstacleWidth/2;
                        const obstacleRight = obstacle.position.x + obstacleWidth/2;
                        const obstacleBottom = obstacle.position.y - obstacleHeight/2;
                        const obstacleTop = obstacle.position.y + obstacleHeight/2;
                        
                        // Skip obstacles below ground
                        if (obstacleTop <= this.groundY + 0.5) {
                            continue;
                        }
                        
                        // Check for collision
                        if (playerRight > obstacleLeft && 
                            playerLeft < obstacleRight &&
                            playerBottom < obstacleTop && 
                            playerTop > obstacleBottom) {
                            
                            // Regular obstacle collision
                            this.gameOver();
                            return; // Exit immediately
                        }
                    }
                    
                    // ---- Then check for PLATFORM collisions ----
                    this.onPlatform = false;
                    
                    for (let i = 0; i < this.platforms.length; i++) {
                        const platform = this.platforms[i];
                        
                        // Skip ground
                        if (platform === this.ground) continue;
                        
                        // Skip invalid platforms
                        if (!platform || !platform.userData) {
                            continue;
                        }
                        
                        // Player hitbox
                        const playerBottom = this.player.position.y - this.playerSize/2;
                        const playerTop = this.player.position.y + this.playerSize/2;
                        const playerLeft = this.player.position.x - this.playerSize/2;
                        const playerRight = this.player.position.x + this.playerSize/2;
                        
                        // Platform hitbox
                        const platformWidth = platform.userData.width || 1;
                        const platformHeight = platform.userData.height || 1;
                        const platformTop = platform.position.y + platformHeight/2;
                        const platformBottom = platform.position.y - platformHeight/2;
                        const platformLeft = platform.position.x - platformWidth/2;
                        const platformRight = platform.position.x + platformWidth/2;
                        
                        // Check for collision
                        if (playerRight > platformLeft && playerLeft < platformRight &&
                            playerBottom < platformTop && playerTop > platformBottom) {
                            
                            // Coming from above (landing on platform)
                            if (this.playerVelocity.y < 0 && 
                                playerBottom - this.playerVelocity.y > platformTop - 0.1) {
                                
                                // Land on platform
                                this.player.position.y = platformTop + this.playerSize/2 + 0.01;
                                this.playerVelocity.y = 0;
                                this.isJumping = false;
                                this.onPlatform = true;
                                
                                // Remove jump path
                                if (this.jumpPath) {
                                    this.scene.remove(this.jumpPath);
                                    this.jumpPath = null;
                                    this.jumpHistoryPoints = [];
                                }
                                
                                // Check if it's a jump pad
                                if (platform.userData.type === 'jumpPad') {
                                    this.playerVelocity.y = this.jumpForce * 1.5;
                                    this.isJumping = true;
                                    this.onPlatform = false;
                                }
                            }
                            // Hit ceiling
                            else if (this.playerVelocity.y > 0 && 
                                    playerTop - this.playerVelocity.y < platformBottom + 0.1) {
                                this.player.position.y = platformBottom - this.playerSize/2 - 0.01;
                                this.playerVelocity.y = 0;
                            }
                        }
                    }
                    
                    // ---- Finally check for COLLECTIBLE collisions ----
                    for (let i = this.collectibles.length - 1; i >= 0; i--) {
                        const coin = this.collectibles[i];
                        if (!coin || coin.userData.collected) continue;
                        
                        const playerLeft = this.player.position.x - this.playerSize/2;
                        const playerRight = this.player.position.x + this.playerSize/2;
                        const playerBottom = this.player.position.y - this.playerSize/2;
                        const playerTop = this.player.position.y + this.playerSize/2;
                        
                        const coinWidth = coin.userData.width || 1;
                        const coinHeight = coin.userData.height || 1;
                        const coinLeft = coin.position.x - coinWidth/2;
                        const coinRight = coin.position.x + coinWidth/2;
                        const coinBottom = coin.position.y - coinHeight/2;
                        const coinTop = coin.position.y + coinHeight/2;
                        
                        // Check for collision
                        if (playerRight > coinLeft && playerLeft < coinRight &&
                            playerBottom < coinTop && playerTop > coinBottom) {
                            // Collect coin
                            coin.userData.collected = true;
                            this.scene.remove(coin);
                            
                            // Add to score
                            const coinValue = coin.userData.value || 100;
                            this.score += coinValue;
                            this.updateScoreDisplay();
                        }
                    }
                }
                
                updateScoreDisplay() {
                    this.scoreDisplay.textContent = `SCORE: ${Math.floor(this.score)}`;
                }
                
                updateLevelDisplay() {
                    const levelDisplay = document.getElementById('level-display');
                    if (levelDisplay) {
                        levelDisplay.textContent = `LEVEL ${this.levelManager.currentLevel}`;
                        
                        // Briefly highlight level display with animation when updated
                        levelDisplay.style.animation = 'none';
                        void levelDisplay.offsetWidth; // Trigger reflow
                        levelDisplay.style.animation = 'uiGlow 2s infinite alternate, levelUpdate 0.5s';
                    }
                    
                    // Update UI colors to match current theme
                    this.updateUITheme();
                }
                
                // Update UI elements to match the current theme
                updateUITheme() {
                    // Get current theme colors
                    const themeIndex = (this.levelManager.currentLevel - 1) % this.themes.length;
                    const theme = this.themes[themeIndex];
                    
                    // Convert theme color to CSS hex color
                    const themeColor = '#' + theme.platformEdge.toString(16).padStart(6, '0');
                    
                    // Update score display
                    const scoreDisplay = document.getElementById('score-display');
                    if (scoreDisplay) {
                        scoreDisplay.style.borderColor = themeColor;
                        scoreDisplay.style.boxShadow = `0 0 10px ${themeColor}, inset 0 0 5px ${themeColor}`;
                        scoreDisplay.style.textShadow = `0 0 5px ${themeColor}`;
                    }
                    
                    // Update level display
                    const levelDisplay = document.getElementById('level-display');
                    if (levelDisplay) {
                        levelDisplay.style.borderColor = themeColor;
                        levelDisplay.style.boxShadow = `0 0 10px ${themeColor}, inset 0 0 5px ${themeColor}`;
                        levelDisplay.style.textShadow = `0 0 5px ${themeColor}`;
                        levelDisplay.style.color = themeColor;
                    }
                    
                    // Update pause button
                    const pauseBtn = document.getElementById('pause-btn');
                    if (pauseBtn) {
                        pauseBtn.style.borderColor = themeColor;
                        pauseBtn.style.boxShadow = `0 0 10px ${themeColor}, inset 0 0 5px ${themeColor}`;
                        
                        // Update pause button bars
                        const pauseBars = pauseBtn.querySelectorAll('div');
                        pauseBars.forEach(bar => {
                            bar.style.backgroundColor = themeColor;
                            bar.style.boxShadow = `0 0 5px ${themeColor}`;
                        });
                    }
                    
                    // Update the keyframes animation dynamically using CSS variables
                    document.documentElement.style.setProperty('--theme-color', themeColor);
                }
                
                // Update the player's colors to match the current theme
                updatePlayerTheme() {
                    // Get current theme colors
                    const themeIndex = (this.levelManager.currentLevel - 1) % this.themes.length;
                    const theme = this.themes[themeIndex];
                    
                    // Check if player exists
                    if (!this.player) {
                        return;
                    }
                    
                    // Check if player theme color needs updating
                    if (this.currentPlayerThemeColor !== theme.player) {
                        // Update main mesh
                        if (this.playerMainMesh) {
                            this.playerMainMesh.material.color.set(theme.player);
                        }
                        
                        // Update inner mesh (find by size)
                        this.player.children.forEach(child => {
                            if (child.geometry && 
                                child.geometry.type === 'BoxGeometry' && 
                                child.geometry.parameters.width === this.playerSize * 0.6) {
                                child.material.color.set(theme.player);
                            }
                        });
                        
                        // Update edge wireframe
                        if (this.playerWireframe) {
                            this.playerWireframe.material.color.set(theme.playerEdge || theme.player);
                        }
                        
                        // Update glow
                        if (this.playerGlow) {
                            this.playerGlow.material.color.set(theme.player);
                        }
                        
                        // Update jump path if it exists
                        if (this.jumpPath && this.jumpPath.material) {
                            this.jumpPath.material.color.set(theme.player);
                        }
                        
                        // Update any active jump particles
                        if (this.jumpParticles && this.jumpParticles.length > 0) {
                            this.jumpParticles.forEach(particle => {
                                if (particle.material) {
                                    particle.material.color.set(theme.player);
                                }
                            });
                        }
                        
                        // Update stored color reference
                        this.currentPlayerThemeColor = theme.player;
                        
                        logDebug("Updated player theme colors");
                    }
                }
                
                gameOver() {
                    logDebug("Game over");
                    this.isRunning = false;
                    this.finalScore.textContent = `SCORE: ${Math.floor(this.score)}`;
                    this.gameOverUI.style.display = 'block';
                }

                // Create a portal at the given position
                createPortal(x, y) {
                    // Remove any existing portal
                    if (this.portal) {
                        this.scene.remove(this.portal);
                        this.portal = null;
                    }
                    
                    // Get current theme colors
                    const themeIndex = (this.levelManager.currentLevel - 1) % this.themes.length;
                    const theme = this.themes[themeIndex];
                    const portalColor = theme.portal; // Use the theme portal color instead of hard-coded cyan
                    
                    // Create portal group
                    this.portal = new THREE.Group();
                    this.portal.position.set(x, y, 0);
                    this.portalPosition = { x, y };
                    
                    // Create a slightly elliptical shape for the portal base using a scaled circle
                    const portalRadius = 1.2;
                    const portalDiscGeometry = new THREE.CircleGeometry(portalRadius, 32);
                    const portalDiscMaterial = new THREE.MeshBasicMaterial({
                        color: 0x000022, // Very dark blue, almost black
                        transparent: true,
                        opacity: 0.85,
                        side: THREE.DoubleSide
                    });
                    const portalDisc = new THREE.Mesh(portalDiscGeometry, portalDiscMaterial);
                    portalDisc.rotation.x = Math.PI / 2; // Rotate to face forward
                    portalDisc.scale.set(1, 1.2, 1); // Make slightly elliptical
                    this.portal.add(portalDisc);
                    
                    // Create the main ring/edge of the portal - using a custom approach for better control
                    const ringWidth = 0.15;
                    const segments = 16;
                    const ringGeometry = new THREE.RingGeometry(portalRadius - ringWidth, portalRadius, segments);
                    const ringMaterial = new THREE.MeshBasicMaterial({
                        color: portalColor,
                        transparent: true,
                        opacity: 0.9,
                        side: THREE.DoubleSide
                    });
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    ring.rotation.x = Math.PI / 2;
                    ring.scale.set(1, 1.2, 1); // Match the elliptical shape
                    this.portal.add(ring);
                    
                    // Add dark segments around the edge - more similar to the image
                    const segmentCount = 12;
                    for (let i = 0; i < segmentCount; i++) {
                        const angle = (i / segmentCount) * Math.PI * 2;
                        
                        // Create a rectangular segment with inner and outer parts for glow effect
                        const segmentGeometry = new THREE.BoxGeometry(0.25, 0.25, 0.1);
                        
                        // Core segment - darker version of the portal color
                        const darkerColor = new THREE.Color(portalColor).multiplyScalar(0.4);
                        const segmentMaterial = new THREE.MeshBasicMaterial({
                            color: darkerColor,
                            transparent: true,
                            opacity: 0.9
                        });
                        const segment = new THREE.Mesh(segmentGeometry, segmentMaterial);
                        
                        // Position around the elliptical ring with proper scaling
                        const xPos = Math.cos(angle) * portalRadius;
                        const yPos = Math.sin(angle) * portalRadius * 1.2; // Match elliptical shape
                        segment.position.set(xPos, yPos, 0.05);
                        
                        // Rotate to align with the ring
                        segment.rotation.z = angle + Math.PI/2;
                        
                        // Add glow effect around each segment
                        const glowGeometry = new THREE.BoxGeometry(0.35, 0.35, 0.15);
                        const glowMaterial = new THREE.MeshBasicMaterial({
                            color: portalColor,
                            transparent: true,
                            opacity: 0.5,
                            blending: THREE.AdditiveBlending
                        });
                        const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                        
                        // Store original position for animation
                        segment.userData.originalPos = { x: xPos, y: yPos };
                        segment.userData.angle = angle;
                        segment.userData.glowFactor = 0.7 + Math.random() * 0.6; // Different pulse rates
                        segment.userData.glowPhase = Math.random() * Math.PI * 2; // Different phases
                        
                        segment.add(glow);
                        this.portal.add(segment);
                    }
                    
                    // Create bright edge glow - inner ring
                    const edgeGlowGeometry = new THREE.RingGeometry(portalRadius - ringWidth - 0.05, portalRadius - ringWidth + 0.05, 32);
                    const edgeGlowMaterial = new THREE.MeshBasicMaterial({
                        color: portalColor,
                        transparent: true,
                        opacity: 0.9,
                        side: THREE.DoubleSide,
                        blending: THREE.AdditiveBlending
                    });
                    const edgeGlow = new THREE.Mesh(edgeGlowGeometry, edgeGlowMaterial);
                    edgeGlow.rotation.x = Math.PI / 2;
                    edgeGlow.scale.set(1, 1.2, 1); // Match elliptical shape
                    this.portal.add(edgeGlow);
                    
                    // Create outer glow effect - overall glow
                    const glowGeometry = new THREE.RingGeometry(portalRadius - 0.1, portalRadius + 0.4, 32);
                    const glowMaterial = new THREE.MeshBasicMaterial({
                        color: portalColor,
                        transparent: true,
                        opacity: 0.4,
                        blending: THREE.AdditiveBlending,
                        side: THREE.DoubleSide
                    });
                    const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                    glow.rotation.x = Math.PI / 2;
                    glow.scale.set(1, 1.2, 1); // Match elliptical shape
                    this.portal.add(glow);
                    
                    // Add wide outer glow for the spread effect seen in image
                    const wideGlowGeometry = new THREE.RingGeometry(portalRadius, portalRadius + 0.8, 32);
                    const wideGlowMaterial = new THREE.MeshBasicMaterial({
                        color: portalColor,
                        transparent: true,
                        opacity: 0.2,
                        blending: THREE.AdditiveBlending,
                        side: THREE.DoubleSide
                    });
                    const wideGlow = new THREE.Mesh(wideGlowGeometry, wideGlowMaterial);
                    wideGlow.rotation.x = Math.PI / 2;
                    wideGlow.scale.set(1, 1.2, 1); // Match elliptical shape
                    this.portal.add(wideGlow);
                    
                    // Add square particles similar to the image (more on left side)
                    this.portalParticles = [];
                    const particleCount = 30; // Increase count for more particles
                    
                    for (let i = 0; i < particleCount; i++) {
                        // Create square particles of varying sizes
                        const size = 0.04 + Math.random() * 0.1;
                        const particleGeometry = new THREE.BoxGeometry(size, size, size);
                        const particleMaterial = new THREE.MeshBasicMaterial({
                            color: portalColor,
                            transparent: true,
                            opacity: 0.5 + Math.random() * 0.5,
                            blending: THREE.AdditiveBlending
                        });
                        
                        const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                        
                        // Position with bias towards left side like in the image
                        let angle, radius;
                        const leftSide = Math.random() < 0.7; // 70% chance for left side
                        
                        if (leftSide) {
                            // Left side particles (more concentrated)
                            angle = Math.PI * 0.5 + (Math.random() - 0.5) * Math.PI; // Left side angle range
                            radius = portalRadius * 1.2 + Math.random() * 2.0; // Further from portal
                        } else {
                            // Right side particles (fewer)
                            angle = Math.PI * 1.5 + (Math.random() - 0.5) * Math.PI; // Right side angle range
                            radius = portalRadius * 1.1 + Math.random() * 1.2; // Closer to portal
                        }
                        
                        // Apply position with elliptical adjustment
                        particle.position.x = Math.cos(angle) * radius;
                        particle.position.y = Math.sin(angle) * radius * 1.2; // Match elliptical shape
                        particle.position.z = (Math.random() - 0.5) * 0.2;
                        
                        // Slight random rotation for visual interest
                        particle.rotation.z = Math.random() * Math.PI * 2;
                        
                        // Add movement data for animation
                        particle.userData.angle = angle;
                        particle.userData.radius = radius;
                        particle.userData.speed = 0.1 + Math.random() * 0.2; // Slower, subtle movement
                        particle.userData.pulseSpeed = 0.5 + Math.random() * 0.5;
                        particle.userData.originalSize = size;
                        particle.userData.driftX = (Math.random() - 0.5) * 0.2; // Left-right drift
                        particle.userData.driftY = (Math.random() - 0.5) * 0.2; // Up-down drift
                        
                        this.portal.add(particle);
                        this.portalParticles.push(particle);
                    }
                    
                    // Set portal collision data
                    this.portal.userData = {
                        type: 'portal',
                        width: 2.4,
                        height: 2.8 // Slightly larger for elliptical shape
                    };
                    
                    this.scene.add(this.portal);
                }
                
                // Update portal animations
                updatePortal(deltaTime) {
                    if (!this.portal) return;
                    
                    // Update swirling effects in the portal
                    this.portal.children.forEach(child => {
                        if (child.userData.rotationSpeed) {
                            child.rotation.z += deltaTime * child.userData.rotationSpeed * child.userData.rotationDirection;
                        }
                        
                        // Animate the glowing segments
                        if (child.userData.angle !== undefined) {
                            // Pulse the glow of the segments
                            const time = performance.now() * 0.001;
                            const glowIntensity = 0.5 + 0.4 * Math.sin(time * child.userData.glowFactor + child.userData.glowPhase);
                            
                            // Apply glow effect to the child's first child (the glow mesh)
                            if (child.children.length > 0) {
                                const glowMesh = child.children[0];
                                glowMesh.material.opacity = glowIntensity;
                                
                                // Slightly scale the glow mesh based on intensity
                                const scale = 1 + glowIntensity * 0.2;
                                glowMesh.scale.set(scale, scale, scale);
                                
                                // Subtle movement
                                const wiggle = Math.sin(time * 2 + child.userData.angle) * 0.02;
                                child.position.x = child.userData.originalPos.x + wiggle;
                                child.position.y = child.userData.originalPos.y + wiggle;
                            }
                        }
                    });
                    
                    // Pulse the glow effect
                    const glowFactor = 1 + Math.sin(performance.now() * 0.003) * 0.2;
                    this.portal.children.forEach(child => {
                        if (child.geometry && child.geometry.type.includes("RingGeometry")) {
                            // Pulse the ring geometries for glow effect
                            child.scale.set(glowFactor, glowFactor * 1.2, 1);
                        }
                    });
                    
                    // Update portal particles
                    if (this.portalParticles && this.portalParticles.length > 0) {
                        this.portalParticles.forEach(particle => {
                            // Use a combination of orbital and drift motion for more natural look
                            particle.userData.angle += deltaTime * particle.userData.speed;
                            
                            // Apply drift to position - creates the floating square effect from the image
                            particle.position.x += particle.userData.driftX * deltaTime;
                            particle.position.y += particle.userData.driftY * deltaTime;
                            
                            // Occasionally change drift direction to keep particles near the portal
                            if (Math.random() < 0.01) {
                                particle.userData.driftX = (Math.random() - 0.5) * 0.3;
                                particle.userData.driftY = (Math.random() - 0.5) * 0.3;
                            }
                            
                            // Reset particles that drift too far
                            const distanceFromCenter = Math.sqrt(
                                particle.position.x * particle.position.x + 
                                particle.position.y * particle.position.y
                            );
                            
                            if (distanceFromCenter > 4.0) {
                                // Reset position with bias towards left side like in the image
                                const leftSide = Math.random() < 0.7; // 70% chance for left side
                                
                                if (leftSide) {
                                    // Left side particles (more concentrated)
                                    particle.userData.angle = Math.PI * 0.5 + (Math.random() - 0.5) * Math.PI;
                                    particle.userData.radius = 1.2 * 1.2 + Math.random() * 2.0;
                                } else {
                                    // Right side particles (fewer)
                                    particle.userData.angle = Math.PI * 1.5 + (Math.random() - 0.5) * Math.PI;
                                    particle.userData.radius = 1.2 * 1.1 + Math.random() * 1.2;
                                }
                                
                                // Apply position with elliptical adjustment
                                particle.position.x = Math.cos(particle.userData.angle) * particle.userData.radius;
                                particle.position.y = Math.sin(particle.userData.angle) * particle.userData.radius * 1.2;
                            }
                            
                            // Pulse opacity for subtle glow effect
                            particle.material.opacity = 0.3 + Math.sin(performance.now() * 0.002 * particle.userData.pulseSpeed) * 0.3;
                            
                            // Slight rotation for more dynamic movement
                            particle.rotation.z += deltaTime * particle.userData.speed * 0.5;
                        });
                    }
                    
                    // Check if player has entered the portal
                    if (this.portal && this.portal.userData) {
                        // Calculate distance between player and portal center
                        const distanceToPortal = Math.sqrt(
                            Math.pow(this.player.position.x - this.portal.position.x, 2) +
                            Math.pow(this.player.position.y - this.portal.position.y, 2)
                        );
                        
                        // Distance threshold to trigger proximity teleport (4 units)
                        const proximityThreshold = 4.0;
                        
                        // Original collision detection
                        const playerLeft = this.player.position.x - this.playerSize/2;
                        const playerRight = this.player.position.x + this.playerSize/2;
                        const playerBottom = this.player.position.y - this.playerSize/2;
                        const playerTop = this.player.position.y + this.playerSize/2;
                        
                        const portalLeft = this.portal.position.x - this.portal.userData.width/2;
                        const portalRight = this.portal.position.x + this.portal.userData.width/2;
                        const portalBottom = this.portal.position.y - this.portal.userData.height/2;
                        const portalTop = this.portal.position.y + this.portal.userData.height/2;
                        
                        // Player is either touching the portal OR close enough to it
                        if ((playerRight > portalLeft && 
                            playerLeft < portalRight &&
                            playerBottom < portalTop && 
                            playerTop > portalBottom) || 
                            distanceToPortal < proximityThreshold) {
                            
                            // Visual indicator that proximity detection triggered (only for proximity)
                            if (distanceToPortal < proximityThreshold && 
                                !(playerRight > portalLeft && 
                                  playerLeft < portalRight &&
                                  playerBottom < portalTop && 
                                  playerTop > portalBottom)) {
                                logDebug("Portal proximity detected - teleporting!");
                            } else {
                                logDebug("Player entered portal - level complete!");
                            }
                            
                            // Immediately remove jump path if it exists
                            if (this.jumpPath) {
                                this.scene.remove(this.jumpPath);
                                this.jumpPath = null;
                                this.jumpHistoryPoints = [];
                            }
                            
                            // Clear any jump particles
                            if (this.jumpParticles && this.jumpParticles.length > 0) {
                                this.jumpParticles.forEach(particle => {
                                    this.scene.remove(particle);
                                });
                                this.jumpParticles = [];
                            }
                            
                            // Reset jump state
                            this.isJumping = false;
                            
                            // Go to next level
                            const nextLevelNumber = this.levelManager.nextLevel();
                            
                            // Update level display
                            this.updateLevelDisplay();
                            
                            // Create the new level
                            this.createLevel();
                        }
                    }
                }
                
                // Advance to the next level
                nextLevel() {
                    this.currentLevel++;
                    if (this.currentLevel > this.maxLevels) {
                        this.currentLevel = 1; // Reset to level 1 after completing all levels
                    }
                    return this.currentLevel;
                }

                createCollectible(x, y) {
                    // Get current theme colors
                    const themeIndex = (this.levelManager.currentLevel - 1) % this.themes.length;
                    const theme = this.themes[themeIndex];
                    
                    // Create a collectible object
                    const collectibleGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                    const collectibleMaterial = new THREE.MeshBasicMaterial({
                        color: theme.collectible,
                        transparent: true,
                        opacity: 0.9
                    });
                    const collectible = new THREE.Mesh(collectibleGeometry, collectibleMaterial);
                    collectible.position.set(x, y, 0);
                    collectible.userData.type = 'coin';
                    collectible.userData.width = 1;
                    collectible.userData.height = 1;
                    collectible.userData.collected = false;
                    this.scene.add(collectible);
                    this.collectibles.push(collectible);
                    
                    // Add glow effect to collectibles
                    const collectibleGlowGeometry = new THREE.BoxGeometry(0.7, 0.7, 0.7);
                    const collectibleGlowMaterial = new THREE.MeshBasicMaterial({
                        color: theme.collectible,
                        transparent: true,
                        opacity: 0.4,
                        blending: THREE.AdditiveBlending
                    });
                    const collectibleGlow = new THREE.Mesh(collectibleGlowGeometry, collectibleGlowMaterial);
                    collectible.add(collectibleGlow);
                    
                    // Add special collectible effect
                    const specialEffectGeometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
                    const specialEffectMaterial = new THREE.MeshBasicMaterial({
                        color: theme.collectible,
                        transparent: true,
                        opacity: 0.5,
                        blending: THREE.AdditiveBlending
                    });
                    const specialEffect = new THREE.Mesh(specialEffectGeometry, specialEffectMaterial);
                    specialEffect.position.set(0, 0.25, 0.1);
                    collectible.add(specialEffect);
                    
                    // Add special collectible sound
                    const sound = new Audio();
                    sound.src = 'path/to/special-collectible-sound.mp3';
                    sound.autoplay = false;
                    collectible.userData.sound = sound;
                }

                createSpecialCollectible(x, y) {
                    // Get current theme colors
                    const themeIndex = (this.levelManager.currentLevel - 1) % this.themes.length;
                    const theme = this.themes[themeIndex];
                    
                    // Create a special collectible object
                    const specialCollectibleGeometry = new THREE.BoxGeometry(0.7, 0.7, 0.7);
                    const specialCollectibleMaterial = new THREE.MeshBasicMaterial({
                        color: 0x00FFAA, // Special teal-colored collectible
                        transparent: true,
                        opacity: 0.9
                    });
                    const specialCollectible = new THREE.Mesh(specialCollectibleGeometry, specialCollectibleMaterial);
                    specialCollectible.position.set(x, y, 0);
                    specialCollectible.userData.type = 'special';
                    specialCollectible.userData.width = 1.4;
                    specialCollectible.userData.height = 1.4;
                    specialCollectible.userData.collected = false;
                    // Special collectible worth more points
                    specialCollectible.userData.value = 500;
                    this.scene.add(specialCollectible);
                    this.collectibles.push(specialCollectible);
                    
                    // Add glow effect to special collectible
                    const specialCollectibleGlowGeometry = new THREE.BoxGeometry(0.9, 0.9, 0.9);
                    const specialCollectibleGlowMaterial = new THREE.MeshBasicMaterial({
                        color: 0x00FFAA,
                        transparent: true,
                        opacity: 0.4,
                        blending: THREE.AdditiveBlending
                    });
                    const specialCollectibleGlow = new THREE.Mesh(specialCollectibleGlowGeometry, specialCollectibleGlowMaterial);
                    specialCollectible.add(specialCollectibleGlow);
                    
                    // Add special collectible sound
                    const sound = new Audio();
                    sound.src = 'path/to/special-collectible-sound.mp3';
                    sound.autoplay = false;
                    specialCollectible.userData.sound = sound;
                }

                clearLevel() {
                    if (this.platforms) {
                        this.platforms.forEach(platform => this.scene.remove(platform));
                    }
                    if (this.obstacles) {
                        this.obstacles.forEach(obstacle => this.scene.remove(obstacle));
                    }
                    if (this.collectibles) {
                        this.collectibles.forEach(coin => this.scene.remove(coin));
                    }
                    if (this.portal) {
                        this.scene.remove(this.portal);
                        this.portal = null;
                    }
                    if (this.ground) {
                        this.scene.remove(this.ground);
                        this.ground = null;
                    }
                    
                    // Clear grid and UI theme elements
                    this.clearGrids();
                    this.updateUITheme();
                    this.updatePlayerTheme();
                }
                
                clearGrids() {
                    // Remove existing grids
                    if (this.scene.children) {
                        this.scene.children.forEach(child => {
                            if (child instanceof THREE.GridHelper) {
                                this.scene.remove(child);
                            }
                        });
                    }
                    
                    // Add new themed grids
                    const themeIndex = (this.levelManager.currentLevel - 1) % this.themes.length;
                    const theme = this.themes[themeIndex];
                    
                    // Create main grid with theme colors
                    const gridSize = 1000;
                    const gridDivisions = 200;
                    const gridColor = theme.grid;
                    
                    const gridHelper = new THREE.GridHelper(gridSize, gridDivisions, gridColor, gridColor);
                    gridHelper.position.y = this.groundY - 0.4; // Slightly below ground
                    gridHelper.material.transparent = true;
                    gridHelper.material.opacity = 0.3;
                    gridHelper.material.blending = THREE.AdditiveBlending;
                    this.scene.add(gridHelper);
                    
                    // Rotate grid to make it horizontal
                    gridHelper.rotation.x = Math.PI / 2;
                    
                    // Add a second grid with different sizing for a more complex grid pattern
                    const secondaryGridSize = 500;
                    const secondaryGridDivisions = 50;
                    const secondaryGridColor = gridColor;
                    
                    const secondaryGridHelper = new THREE.GridHelper(secondaryGridSize, secondaryGridDivisions, secondaryGridColor, secondaryGridColor);
                    secondaryGridHelper.position.y = this.groundY - 0.39; // Slightly above the main grid
                    secondaryGridHelper.material.transparent = true;
                    secondaryGridHelper.material.opacity = 0.4;
                    secondaryGridHelper.material.blending = THREE.AdditiveBlending;
                    this.scene.add(secondaryGridHelper);
                    
                    // Rotate the secondary grid
                    secondaryGridHelper.rotation.x = Math.PI / 2;
                }

                createDeathEffect(x, y) {
                    // Get current theme colors
                    const themeIndex = (this.levelManager.currentLevel - 1) % this.themes.length;
                    const theme = this.themes[themeIndex];
                    
                    // Create particle explosion effect
                    const particleCount = 15;
                    const particles = [];
                    
                    for (let i = 0; i < particleCount; i++) {
                        // Create particles with sizes that vary slightly
                        const size = 0.1 + Math.random() * 0.15;
                        const particleGeometry = new THREE.BoxGeometry(size, size, size);
                        
                        // Use player color for particles
                        const particleMaterial = new THREE.MeshBasicMaterial({
                            color: theme.player,
                            transparent: true,
                            opacity: 0.8,
                            blending: THREE.AdditiveBlending
                        });
                        
                        const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                        
                        // Position at player location
                        particle.position.set(x, y, 0);
                        
                        // Add random velocity
                        const angle = Math.random() * Math.PI * 2;
                        const speed = 0.05 + Math.random() * 0.1;
                        particle.userData.velocityX = Math.cos(angle) * speed;
                        particle.userData.velocityY = Math.sin(angle) * speed;
                        
                        // Add rotation
                        particle.userData.rotationSpeed = (Math.random() - 0.5) * 0.2;
                        
                        // Add the particle to the scene
                        this.scene.add(particle);
                        particles.push(particle);
                    }
                    
                    // Create a fade-out effect
                    const fadeAnimation = () => {
                        if (particles.length === 0 || !this.isRunning) return;
                        
                        // Update each particle's position and opacity
                        for (let i = particles.length - 1; i >= 0; i--) {
                            const particle = particles[i];
                            
                            // Update position
                            particle.position.x += particle.userData.velocityX;
                            particle.position.y += particle.userData.velocityY;
                            
                            // Add gravity effect
                            particle.userData.velocityY -= 0.002;
                            
                            // Update rotation
                            particle.rotation.z += particle.userData.rotationSpeed;
                            
                            // Reduce opacity
                            particle.material.opacity -= 0.01;
                            
                            // Remove particle when it's no longer visible
                            if (particle.material.opacity <= 0) {
                                this.scene.remove(particle);
                                particles.splice(i, 1);
                            }
                        }
                        
                        // Continue animation if there are still particles
                        if (particles.length > 0) {
                            requestAnimationFrame(fadeAnimation);
                        }
                    };
                    
                    // Start the animation
                    fadeAnimation();
                }
            }

            // Initialize the game
            const game = new Game();
            
            // Keep debug console visible longer
            setTimeout(() => {
                const debugConsole = document.getElementById('debug-console');
                if (debugConsole) {
                    debugConsole.style.display = 'none';
                }
            }, 10000); // Show for 10 seconds instead of 3
            
            // Add keyboard control instructions
            logDebug("CONTROLS: Press SPACE or UP ARROW to jump");
            logDebug("Press RIGHT ARROW for temporary speed boost");
            logDebug("Game automatically moves forward");
            logDebug("Avoid spikes and collect coins!");
        }
    </script>
</body>
</html> 